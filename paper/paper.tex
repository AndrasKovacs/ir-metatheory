
%% build: latexmk -pdf -pvc paper.tex

\documentclass[acmsmall,screen,review,anonymous]{acmart}
%% \documentclass[nonacm,acmsmall]{acmart}
%% \documentclass[acmsmall]{acmart}
%% \raggedbottom

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.newcomm  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%% --------------------------------------------------------------------------------

%% \usepackage{xcolor}
%% \usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
%% \usepackage{bm}
%% \usepackage{mathtools}
%% \usepackage{stmaryrd}
%% \usepackage[title]{appendix}

\newcommand{\mit}[1]{{\mathsf{#1}}}
\newcommand{\msf}[1]{{\mathsf{#1}}}
\newcommand{\mbf}[1]{{\mathbf{#1}}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\push}{\mathsf{push}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\data}{\mbf{data}}
\newcommand{\U}{\msf{U}}
\newcommand{\Set}{\msf{Set}}
\newcommand{\where}{\mbf{where}}
\newcommand{\Nat}{\msf{Nat}}
\newcommand{\zero}{\msf{zero}}
\newcommand{\suc}{\msf{suc}}
\newcommand{\Nil}{\msf{Nil}}
\newcommand{\Cons}{\msf{Cons}}
\newcommand{\El}{\msf{El}}
\newcommand{\Lift}{\msf{Lift}}
\newcommand{\lup}{\uparrow}
\newcommand{\ldown}{\downarrow}
\newcommand{\Sig}{\msf{Sig}}
\newcommand{\Code}{\msf{Code}}
\newcommand{\Tag}{\msf{Tag}}
\newcommand{\case}{\mbf{case}}
\newcommand{\of}{\mbf{of}}
\newcommand{\ttt}{\msf{tt}}
\newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}
\newcommand{\ir}{{ir}}
\newcommand{\el}{{el}}
\newcommand{\ix}{{ix}}
\newcommand{\IR}{\msf{IR}}
\newcommand{\ih}{{ih}}
\newcommand{\intro}{\msf{intro}}
\newcommand{\IH}{\msf{IH}}
\newcommand{\map}{\msf{map}}
\newcommand{\elim}{\msf{elim}}
\newcommand{\inj}{\msf{inj}}
\newcommand{\tr}{\msf{tr}}
\newcommand{\fst}{\msf{fst}}
\newcommand{\snd}{\msf{snd}}
\newcommand{\IIR}{\msf{IIR}}
\newcommand{\Sigr}[1]{\lfloor #1 \rfloor}
\newcommand{\floord}[1]{\lfloor #1 \rfloor}
\newcommand{\ora}[1]{\overrightarrow{#1}}
\newcommand{\ola}[1]{\overleftarrow{#1}}
\newcommand{\ap}{\msf{ap}}
\newcommand{\Bool}{\msf{Bool}}
\newcommand{\Level}{\msf{Level}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\id}{\msf{id}}

\newcommand{\Con}{\msf{Con}}
\newcommand{\Sub}{\msf{Sub}}
\newcommand{\Ty}{\msf{Ty}}
\newcommand{\Tm}{\msf{Tm}}
\newcommand{\ext}{\triangleright}
\newcommand{\w}{\circ}
\newcommand{\lam}{\msf{lam}}
\newcommand{\app}{\msf{app}}
\newcommand{\bapp}{\$}
\newcommand{\proj}{\msf{proj}}
\newcommand{\exfalso}{\msf{exfalso}}
\newcommand{\true}{\msf{true}}
\newcommand{\false}{\msf{false}}
\newcommand{\BoolElim}{\msf{BoolElim}}
\newcommand{\fun}{\Rightarrow}
\newcommand{\SigElim}{\msf{SigElim}}
\newcommand{\Id}{\msf{Id}}
\newcommand{\refl}{\msf{refl}}
\newcommand{\J}{\msf{J}}
\newcommand{\G}{\mbb{G}}
\newcommand{\Path}{\msf{Path}}
\newcommand{\here}{\msf{here}}
\newcommand{\Ssw}{S^{*\w}}

\newcommand{\insigma}{\msf{in}\!\!-\!\!\sigma}
\newcommand{\indelta}{\msf{in}\!\!-\!\!\delta}

\newcommand{\Sb}{S^{*\circ}}
\newcommand{\Sbe}{{\floord{S^{*\circ}}\,\here}}
\newcommand{\PSbe}{{(\floord{S^{*\circ}}\,\here)}}
\newcommand{\Elintro}{\msf{El\!\!-\!\!intro}}
\newcommand{\elimbeta}{\elim\!-\!\!\beta}

%% --------------------------------------------------------------------------------

%%
%% end of the preamble, start of the body of the document source.
%% \hypersetup{draft}
\begin{document}


\title{Canonicity for Indexed Inductive-Recursive Types}

\author{András Kovács}
\orcid{0000-0002-6375-9781}
\affiliation{%
  \institution{University of Gothenburg \& Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}
\email{andrask@chalmers.se}


\begin{abstract}
We prove canonicity for a Martin-Löf type theory that supports a countable universe hierarchy where
each universe supports indexed inductive-recursive (IIR) types. We proceed in two steps. First, we
construct IIR types from inductive-recursive (IR) types and other basic type formers, in order to
simplify the subsequent canonicity proof. The constructed IIR types support the same definitional
computation rules that are available in Agda's native IIR implementation. Second, we give a
canonicity proof for IR types, building on the established method of gluing along the global
sections functor. The main idea is to encode the canonicity predicate for each IR type using a
metatheoretic IIR type.
\end{abstract}

%% \begin{CCSXML}
%% \end{CCSXML}
%% \ccsdesc[500]{Theory of computation~Type theory}
%% \ccsdesc[500]{Software and its engineering~Source code generation}
%% \keywords{}

\maketitle

\section{Introduction}\label{sec:introduction}

Instances of inductive-recursive (IR) definitions were first used by
\citet{martin1975intuitionistic,martinlof84sambin}. General definitions of IR types were formalized
by \citet{DBLP:journals/jsyml/Dybjer00} and
\citet{dybjer99finite,DBLP:journals/jlp/DybjerS06,DBLP:journals/apal/DybjerS03}, who also developed
set-theoretic, realizability and categorical semantics. A common application of IR is to define
custom universe hierarchies inside a type theory. In the proof assistant Agda, we can use IR to
define a universe that is closed under our choice of type formers:
\begin{alignat*}{3}
  & \mbf{mutual} \\
  & \quad\data\,\Code : \Set_0\,\where \\
  & \quad\quad \Nat' : \Code\\
  & \quad\quad \Pi' \hspace{0.8em} : (A : \Code) \to (\El\,A \to \Code) \to \Code
  & \\
  & \\
  & \quad\El : \Code \to \Set_0 \\
  & \quad\El\,\Nat'\hspace{1.5em}  = \Nat \\
  & \quad\El\,(\Pi'\,A\,B) = (a : \El\,A) \to \El\,(B\,a)
\end{alignat*}
Here, $\Code$ is a type of codes of types which behaves as a custom Tarski-style universe. This
universe, unlike the ambient $\Set_0$ universe, supports an induction principle and can be used to
define type-generic functions. Indexed induction-recursion (IIR) additionally allows indexing
$\Code$ over some type, which lets us define inductive-recursive predicates \cite{DBLP:journals/jlp/DybjerS06}.

An important application of IR has been to develop semantics for object theories that support
universe hierarchies. IR has been used in normalization proofs
\cite{DBLP:journals/pacmpl/0001OV18,DBLP:journals/pacmpl/PujetT23,DBLP:journals/pacmpl/AbelDE23}, in
modeling first-class universe levels \cite{first-class-univ} and proving canonicity for them
\cite{DBLP:journals/corr/abs-2502-20485}. Other applications are in characterizing domains of
partial functions \cite{DBLP:conf/tphol/BoveC01} and in generic programming over type
descriptions \cite{diehl2017fully}.

IIR has been supported in Agda 2 since the early days of the system \cite{DBLP:conf/tphol/BoveDN09},
and it is also available in Idris 1 \cite{DBLP:journals/jfp/Brady13} and Idris 2
\cite{DBLP:conf/ecoop/Brady21}. In these systems, IR has been implemented in the ``obvious'' way,
supporting closed program execution in compiler backends and normalization during type checking, but
without any formal justification.

Our \textbf{main contribution} is to \textbf{show canonicity} for a Martin-Löf type theory that
supports a countable universe hierarchy, where each universe supports indexed inductive-recursive
types. Canonicity means that every closed term is definitionally equal to a canonical
term. Canonical terms are built only from constructors; for instance, a canonical natural number
term is a numeral. Hence, canonicity justifies evaluation for closed terms. The outline of our
development is as follows.

\begin{enumerate}
\item In Section \ref{sec:specification} we specify what it means to support IR and IIR, using
  Dybjer and Setzer's rules with minor modifications \cite{DBLP:journals/apal/DybjerS03}. We use
  first-class signatures, meaning that descriptions of (I)IR types are given as ordinary inductive
  types internally.
\item In Section \ref{sec:iir-construction} we construct IIR types from IR types and other basic
  type formers. This allows us to only consider IR types in the subsequent canonicity proof, which
  is a significant simplification. In the construction of IIR types, we lose some definitional
  equalities when IIR signatures are neutral, but we still get the same computation rules that are
  available for Agda and Idris' IIR types. We formalize the construction in Agda.
\item In Section \ref{sec:canonicity}, we give a proof-relevant logical predicate interpretation of
  the type theory, from which canonicity follows. Our method is based on a type-theoretic flavor of
  gluing along the global sections functor \cite{gluing,coquand2018canonicity}. The main challenge
  here is to give a logical predicate interpretation of IR types. We do this by using IIR in the
  metatheory: from each object-theoretic signature we compute a metatheoretic IIR signature which
  encodes the canonicity predicate for the corresponding IR type.  We formalize the predicate
  interpretation of IR types in Agda, using a shallow embedding of the syntax of the object
  theory. Hence, there is a gap between the Agda version and the fully formal construction, but we
  argue that it is a modest gap. \todo{We'll see the actual gap}
\end{enumerate}

\section{Specification for (I)IR Types}\label{sec:specification}

In this section we describe the object type theory, focusing on the specification of IR and IIR
types. We do not yet go into the formal details; instead, we shall mostly work with internal
definitions in an Agda-like syntax. In Section \ref{sec:object-theory} we will give a more rigorous
specification that is based on categories-with-families.

\subsection{Basic Type Formers}\label{sec:basic-type-formers}
We have a countable hierarchy of Russell-style universes, written as $\U_i$, where $i$ is an
external natural number. We have $\U_i : \U_{i + 1}$.

We have $\Pi$-types as $(x : A) \to B\,x$, which has type $\U_{\max(i,\,j)}$ when $A : \U_i$ and $B
: A \to \U_j$. We use Agda-style implicit function types for convenience, as $\{x : A\} \to B\,x$,
to mark that a function argument should be inferred from context. We sometimes omit the type of an
implicit argument and write $\{x\} \to B\,x$.  Also, we may omit the implicit quantification
entirely: if there are variables in a type which are not quantified anywhere, they are understood
to be implicitly quantified with a $\Pi$-type.

$\Sigma$-types: for $A : \U_i$ and $B : A \to \U_j$, we have $((x : A) \times B\,x) :
\U_{\max(i,\,j)}$.  We write $\blank,\blank$ for pairing and $\fst$ and $\snd$ for projections. We
have the unit type $\top : \U_i$ with unique inhabitant $\ttt$. We have $\Bool : \U_0$ for
Booleans. We have intensional identity types, as $t = u : \U_i$ for $t : A : \U_i$. We define (by
identity elimination) a transport operation $\tr : \{A : \U_i\}(P : A \to \U_j)\{x\,y : A\} \to x =
y \to P\,x \to P\,y$. We derive some other type formers below.
\begin{itemize}
  \item We define a universe lifting operation $\Lift : \U_i \to \U_{\max(i,\,j)}$ such that
    $\Lift\,A$ is definitionally isomorphic to $A$, by setting $\Lift\,A$ to $A \times \top_j$. We
    write the wrapping operation as $\lup\,:\,A \to \Lift\,A$ with inverse $\ldown$.
  \item We define the empty type $\bot : \U_0$ as $\true = \false$.
  \item We can define finite sum types from $\bot$, $\Sigma$ and $\Bool$. These are useful
    as ``constructor tags'' in inductive types.
\end{itemize}
We write $\blank\!\!\equiv\!\!\blank$ for definitional equality and write definitions with $:\equiv$.

\subsection{IR Types}\label{sec:ir-specification}
The object theory additionally supports inductive-recursive types. On a high level, the
specification consists of the following.
\begin{enumerate}
\item A type of signatures. Each signature describes an IR type. Also, we internally define some
  functions on signatures which are required in the specification of other rules.
\item Rules for type formation, term formation and the recursive function, with a computation rule
  for the recursive function.
\item The induction principle with a $\beta$-rule.
\end{enumerate}

\subsubsection{IR signatures}\label{sec:ir-signatures}
Signatures are parameterized by the following data:
\begin{itemize}
\item The level $i$ is the size of the IR type that is being specified.
\item The level $j$ is the size of the recursive output type.
\item $O : \U_j$ is the output type.
\end{itemize}
IR signatures are specified by the following inductive type. We only mark $i$ and $O$ as parameters to $\Sig$,
since $j$ is inferable from $O$.
\begin{alignat*}{4}
  &\data\, \Sig_i\,O : \U_{\max(i+1,\,j)}\,\where\\
  &\quad \iota\hspace{0.25em}  : O \to \Sig_i\,O \\
  &\quad \sigma               : (A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O \\
  &\quad \delta\hspace{0.1em} : (A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O
\end{alignat*}
Formally, we can view $\Sig$ in two ways: it is either a primitive inductive family \cite{inductivefamilies} or
it is defined as a $\msf{W}$-type \cite{whynotw}. The choice is not crucial, but in this paper
we treat $\Sig$ as a native inductive type, in order to avoid encoding overheads.

\begin{example}\label{ex:code-signature}
We reproduce the Agda example from Section \ref{sec:introduction}. First, we need an enumeration
type to represent the constructor labels of $\Code$. We assume this as $\Tag : \U_0$ with
constructors $\Nat'$ and $\Pi'$. We also assume $\Nat : \U_0$ for natural numbers and a
right-associative $\blank\!\$\!\blank$ operator for function application.
\begin{alignat*}{4}
  & S : \Sig_0\,\U_0\\
  & S :\equiv \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nat' \to \iota\,\Nat \\
  & \quad \Pi'\hspace{0.85em} \to \delta\,\top\,\$\,\lambda\,{ElA}.\, \delta\,({ElA}\,\ttt)\,\$\,\lambda\,{ElB}.\,
      \iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)
\end{alignat*}
First, we introduce a choice between two constructors by $\sigma\,\Tag$. In the $\Nat'$ branch, we
specify that the recursive function maps the constructor to $\Nat$. In the $\Pi'$ branch, we first
introduce a single inductive constructor field by $\delta\,\top$, where $\top$ sets the number of
introduced fields. The naming of the freshly bound variable ${ElA}$ is meant to suggest that it
represents the recursive function's output for the inductive field. It has type $\top \to \U_0$.
Next, we introduce $({ElA}\,\ttt)$-many inductive fields, and bind ${ElB} : {ElA}\,\ttt \to \U_0$ to
represent the corresponding recursive output. Finally, $\iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)$
specifies the output of the recursive function for a $\Pi'$ constructor.
\end{example}

Our signatures are identical to those in \cite{DBLP:journals/apal/DybjerS03}, except for
one difference.  We have countable universe levels, while Dybjer and Setzer use a logical framework
presentation with only three universes, $\msf{set}$, $\msf{stype}$ and $\msf{type}$, where
$\msf{set}$ contains the inductively specified type, $\msf{stype}$ contains the non-inductive
constructor arguments and $\msf{type}$ contains the recursive output type and the type of
signatures.

\subsubsection{Type and term formation}\label{sec:ir-type-and-term-formation}

In this section we also follow Dybjer and Setzer, with minor differences of notation, and also
accounting for the refinement of universe levels.

First, assuming $i$ and $O : \U_j$, a signature $S : \Sig_i\,O$ can be interpreted as a function
from $(A : \U_i) \times (A \to O)$ to $(A : \U_i) \times (A \to O)$. This can be extended to an
endofunctor on the slice category $\U_i/O$, but in the following we only need the action on
objects. We split this action to two functions, to aid readability:
\begin{alignat*}{3}
  &\rlap{$\blank_0 : \Sig_i\,O \to (\ir : \U_i) \to (\ir \to O) \to \U_i$} \\
  &(\iota\,o)_0    \,&&\ir\,\el && \hspace{-0.7em}:\equiv \top\\
  &(\sigma\,A\,S)_0\,&&\ir\,\el && \hspace{-0.7em}:\equiv (a : A) \times (S\,a)_0\,\ir\,\el\\
  &(\delta\,A\,S)_0\,&&\ir\,\el && \hspace{-0.7em}:\equiv (f : A \to \ir) \times (S\,(\el \circ f))_0\,\ir\,\el\\
  & && &&\\
  &\rlap{$\blank_1 : (S : \Sig_i\,O) \to S_0\,\ir\,\el \to O$} \\
  &(\iota\,o)_1    \,&&x       && :\equiv o\\
  &(\sigma\,A\,S)_1\,&&(a,\,x) && :\equiv (S\,a)_1\,x\\
  &(\delta\,A\,S)_1\,&&(f,\,x) && :\equiv (S\,(\el \circ f))_1\,x
\end{alignat*}
Although we use Agda-like pattern matching notation above, these functions are formally defined by
the elimination principle of $\Sig$. Also note the quantification of the $i$ and $j$ universe
levels. The object theory does not support universe polymorphism, so this quantification is
understood to happen in the metatheory. The introduction rules are the following.
\begin{alignat*}{3}
  &\IR                && : (S : \Sig_i\,O) \to \U_i\\
  &\El                && : \IR\,S \to O\\
  &\intro             && : S_0\,(\IR\,S)\,\El \to \IR\,S\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x
\end{alignat*}
Above, we leave some rule arguments implicit, like $S$ in $\El$, $\intro$ and
$\msf{El\!\!-\!\!intro}$. The rule $\msf{El\!\!-\!\!intro}$ specifies a definitional equality.  Note
that these rules are not internal definitions but part of the specification of the object
theory. Hence, they are also assumed to be stable under object-theoretic substitution. On a high
level, the introduction rules express the existence of an $S$-algebra where we view $S$ as an
endofunctor on $\U_i/O$.

\subsubsection{Elimination}\label{sec:ir-elimination}

We again follow \citet{DBLP:journals/apal/DybjerS03}. We assume a universe level
$k$ that specifies the size of the type into which we eliminate. We define two additional functions
on signatures:
\begin{alignat*}{3}
  &\rlap{$\blank_\IH : (S : \Sig_i\,O)(P : \ir \to \U_k) \to S_0\,\ir\,\el \to \U_{\max(i,\,k)}$} \\
  &(\iota\,o)_\IH    \,&&P\,x       &&:\equiv \top \\
  &(\sigma\,A\,S)_\IH\,&&P\,(a,\,x) &&:\equiv (S\,a)_\IH\,P\,x \\
  &(\delta\,A\,S)_\IH\,&&P\,(f,\,x) &&:\equiv ((a : A) \to P\,(f\,a)) \times (S\,(\el \circ f))_\IH\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-7em}\rlap{$\blank_\map : (S : \Sig_i\,O)(P : \ir \to \U_k) \to ((x : \ir) \to P\,x) \to (x : S_0\,\ir\,\el) \to S_\IH\,P\,x$} \\
  &\hspace{-7em}(\iota\,o)_\map    \,&&P\,h\,x       &&:\equiv\,\ttt \\
  &\hspace{-7em}(\sigma\,A\,S)_\map\,&&P\,h\,(a,\,x) &&:\equiv (S\,a)_\map\,P\,h\,x \\
  &\hspace{-7em}(\delta\,A\,S)_\map\,&&P\,h\,(f,\,x) &&:\equiv (h \circ f,\,(S\,(\el \circ f))_\map\,P\,h\,x)
\end{alignat*}
$\blank_\IH$ stands for ``induction hypothesis'': it specifies having a witness of a predicate $P$ for
each inductive field in a value of $S_0\,\ir\,\el$. $S_\map$ maps over $S_0\,\ir\,\el$, applying the
section $h : (x : \ir) \to P\,x$ to each inductive field. Elimination is specified as follows.
\begin{alignat*}{3}
  &\elim           &&: (P : \IR\,S \to \U_k) \to ((x : S_0\,(\IR\,S)\,\El) \to S_\IH\,P\,x \to P\,(\intro\,x)) \to (x : \IR\,S) \to P\,x \\
  &\elim\!-\!\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x)
\end{alignat*}
If we have function extensionality, this specification of elimination can be shown to be equivalent
to the initiality of $(\IR\,S,\,\El)$ as an $S$-algebra \cite[Section~4.4]{DBLP:journals/apal/DybjerS03}.

\subsection{IIR Types}\label{sec:iir}

In IIR signatures, the sole deviation from Dybjer and Setzer is again our use of countable universe
levels \cite{DBLP:journals/jlp/DybjerS06}. Since IIR is quite similar to IR, we present the rules with
minimal commentary.

\subsubsection{Signatures}\label{sec:iir-signatures} We assume levels $i$, $j$, $k$, an indexing type $I : \U_k$ and a type family
for the recursive output as $O : I \to \U_j$. Signatures are as follows.
\begin{alignat*}{4}
  &\data\, \Sig_i\,I\,O : \U_{\max(i+1,\,j,\,k)}\,\where\\
  &\quad \iota\hspace{0.25em}  : (i : I) \to O\,i \to \Sig_i\,I\,O \\
  &\quad \sigma                : (A : \U_i) \to (A \to \Sig_i\,I\,O) \to \Sig_i\,I\,O \\
  &\quad \delta\hspace{0.1em}  : (A : \U_i)(\ix : A \to I) \to (((a : A) \to O\,(\ix\,a)) \to \Sig_i\,I\,O) \to \Sig_i\,I\,O
\end{alignat*}

\begin{example}\label{ex:vector} We reproduce length-indexed vectors as an IIR type. We assume $A : \U_0$ for a type of elements in the vector,
and a type $\Tag : \U_0$ with inhabitants $\Nil'$ and $\Cons'$.
\begin{alignat*}{4}
  & S : \Sig_0\,\Nat\,(\lambda\,\_.\,\top)\\
  & S :\equiv \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nil'\hspace{0.85em} \to \iota\,\zero\,\ttt \\
  & \quad \Cons'\to \sigma\,\Nat\,\$\,\lambda\,n.\,\sigma\,A\,\$\,\lambda\,\_.\,\delta\,\top\,(\lambda\,\_.\,n)\,\$\,\lambda\,\_.\,\iota\,(\suc\,n)\,\ttt
\end{alignat*}
We set $O$ to be constant $\top$ because vectors do not have an associated recursive function. In
the $\Nil'$ case, we simply set the constructor index to $\zero$. In the $\Cons'$ case, we introduce
a non-inductive field, binding $n$ for the length of the tail of the vector. Then, when we introduce
the inductive field using $\delta$, we use $(\lambda\,\_.\,n)$ to specify that the length of the
(single) inductive field is indeed $n$. Finally, the length of the $\Cons'$ constructor is $\suc\,n$.
\end{example}

\subsubsection{Type and term formation}\label{sec:iir-type-and-term-formation}
$\blank_0$ and $\blank_1$ are similar to before:
\begin{alignat*}{4}
  &\hspace{-6em}\rlap{$\blank_0 : \Sig_i\,I\,O \to (\ir : I \to \U_{\max(i,\,k)}) \to (\{i : I\} \to \ir\,i \to O\,i) \to I \to \U_{\max(i,\,k)}$} \\
  &\hspace{-6em}(\iota\,i'\,o)     _0\,&&\ir\,\el\,i &&\hspace{-0.2em} :\equiv \Lift\,(i' = i)\\
  &\hspace{-6em}(\sigma\,A\,S)     _0\,&&\ir\,\el\,i &&\hspace{-0.2em} :\equiv (a : A) \times (S\,a)_0\,\ir\,\el\,i\\
  &\hspace{-6em}(\delta\,A\,\ix\,S)_0\,&&\ir\,\el\,i &&\hspace{-0.2em} :\equiv
              (f : (a : A) \to \ir\,(\ix\,a)) \times (S\,(\el \circ f))_0\,\ir\,\el\,i\\
  &\hspace{-6em} && &&\\
  &\hspace{-6em}\rlap{$\blank_1 : (S : \Sig_i\,I\,O) \to S_0\,\ir\,\el\,i \to O\,i$} \\
  &\hspace{-6em}(\iota\,i'\,o)_1\,     &&\hspace{-0.1em}(\lup x) && \hspace{-0.2em}:\equiv \tr\,O\,x\,o\\
  &\hspace{-6em}(\sigma\,A\,S)_1\,     &&\hspace{-0.1em}(a,\,x)  && \hspace{-0.2em}:\equiv (S\,i)_1\,x\\
  &\hspace{-6em}(\delta\,A\,\ix\,S)_1\,&&\hspace{-0.1em}(f,\,x)  && \hspace{-0.2em}:\equiv (S\,(\el \circ f))_1\,x
\end{alignat*}
Note the transport in $\tr\,O\,x\,o$: this is necessary, since $o$ has type $O\,i'$ while the
required type is $O\,i$. The type and term formation rules are the following.
\begin{alignat*}{4}
  &\IIR               && : (S : \Sig_i\,I\,O) \to I \to \U_{\max(i,\,k)}\\
  &\El                && : \IIR\,S\,i \to O\,i\\
  &\intro             && : S_0\,(\IIR\,S)\,\El\,i \to \IIR\,S\,i\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x
\end{alignat*}
\subsubsection{Elimination}\label{sec:iir-elimination} $\blank_\IH$, $\blank_\map$ and elimination are
as follows. We assume a level $l$ for the target type of elimination.
\begin{alignat*}{3}
  &\rlap{$\blank_\IH : (S : \Sig_i\,I\,O)(P : \{i : I\}\to \ir\,i \to \U_l) \to S_0\,\ir\,\el\,i \to \U_{\max(i,\,l)}$} \\
  &(\iota\,i\,o)_\IH \,&&P\,x       &&:\equiv \top \\
  &(\sigma\,A\,S)_\IH\,&&P\,(a,\,x) &&:\equiv (S\,a)_\IH\,P\,x \\
  &(\delta\,A\,\ix\,S)_\IH\,&&P\,(f,\,x) &&:\equiv ((a : A) \to P\,(f\,a)) \times (S\,(\el \circ f))_\IH\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-3em}\rlap{$\blank_\map : (S : \Sig_i\,I\,O)(P : \{i : I\}\to \ir\,i \to \U_l)$}\\
  &\hspace{-3em}\rlap{$\hspace{3em}\to (\{i : I\}(x : \ir\,i) \to P\,x) \to (x : S_0\,\ir\,\el\,i) \to S_\IH\,P\,x$} \\
  &\hspace{-3em}(\iota\,o)_\map    \,&&P\,h\,x       &&:\equiv\,\ttt \\
  &\hspace{-3em}(\sigma\,A\,S)_\map\,&&P\,h\,(a,\,x) &&:\equiv (S\,a)_\map\,P\,h\,x \\
  &\hspace{-3em}(\delta\,A\,S)_\map\,&&P\,h\,(f,\,x) &&:\equiv (h \circ f,\,(S\,(\el \circ f))_\map\,P\,h\,x)
\end{alignat*}
\begin{alignat*}{3}
  &\elim           &&: (P : \{i : I\}\to \IIR\,S\,i \to \U_l) \to (\{i : I\}(x : S_0\,(\IIR\,S)\,\El\,i) \to S_\IH\,P\,x \to P\,(\intro\,x))\\
  &                && \hspace{0.7em}\to (x : \IIR\,S\,i) \to P\,x \\
  &\elim\!-\!\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x)
\end{alignat*}
\emph{Notation.} We overload $\El$, $\intro$ and $\elim$ for IR and IIR types, but we will sometimes disambiguate them
with a subscript, e.g.\ as $\intro_\IR$ or $\intro_\IIR$.

\section{Construction of IIR Types}\label{sec:iir-construction}

We proceed to construct IIR types from IR types and other basic type formers. We assume $i$, $j$,
$k$, $I : \U_k$ and $O : I \to \U_j$, and also assume definitions for IIR signatures and the four
operations ($\blank_0$, $\blank_1$, $\blank_\IH$, $\blank_\map$). The task is to define $\IR$,
$\El$, $\elim$ and $\elim\!-\!\!\beta$. We use some abbreviations in the following:
\begin{itemize}
\item $\Sig_\IIR$ abbreviates the IIR signature type $\Sig_i\,I\,O$.
\item $\Sig_\IR$ abbreviates the IR signature type $\Sig_{\max(i,\,k)}\,((i : I) \times O\,i)$.
\end{itemize}
In a nutshell, the main idea in this section is to represent IIR signatures as IR signatures
together with a well-indexing predicate on algebras. First, we define an encoding function for
signatures:
\begin{alignat*}{4}
  & \rlap{$\Sigr{\blank} : \Sig_\IIR \to \Sig_\IR$}\\
  & \Sigr{\iota\,i\,o}       &&:\equiv \hspace{0.5em} &&\iota\,(i,\,o)\\
  & \Sigr{\sigma\,A\,S}      &&:\equiv \hspace{0.5em} &&\sigma\,(\Lift\,A)\,(\lambda\,a.\,\Sigr{S\,\ldown\!a})\\
  & \Sigr{\delta\,A\,\ix\,S} &&:\equiv \hspace{0.5em} &&\delta\,(\Lift\,A)\,\$\,\lambda\,f.\\
  &  &&                                &&\sigma\,((a : A) \to \fst\,(f\,(\lup\!a)) = \ix\,a)\,\$\,\lambda\,p.\\
  &  &&                                &&\Sigr{S\,(\lambda\,a.\,\tr\,O\,(p\,a)\,(\snd\,(f\,(\lup\! a))))}
\end{alignat*}
There are two points of interest. First, the encoded IR signature has the recursive output type $(i
: I) \times O\,i$, which lets us interpret $\iota\,i\,o$ as $\iota\,(i,\,o)$. Second, in the
interpretation of $\delta$, we already need to enforce well-indexing for inductive fields, or else
we cannot recursively proceed with the translation. We solve this by adding an \emph{extra field} in
the output signature, which contains a well-indexing witness of type $((a : A) \to \fst\,(f\,(\lup\!a)) = \ix\,a)$.
This lets us continue the translation for $S$, by fixing up the return type of $f$ by a transport.

\emph{Note on prior work.} Hancock et al.\ described the same translation from small IIR signatures
to small IR signatures \cite[Section~6]{DBLP:conf/tlca/HancockMGMA13}. However, they only presented
the translation of signatures, without the rest of the construction. Also, constructions and results
for small IR do not generally transfer to our case of ``large'' IR.

\begin{example} We compute the translation of the length-indexed vector signature from Example \ref{ex:vector}.
\begin{alignat*}{4}
  & \floord{S} : \Sig\,(\Nat \times \top)\\
  & \floord{S} \equiv \sigma\,(\Lift\,\Tag)\,\$\,\lambda\,t.\,\case \ldown\!t\,\of \\
  & \quad \Nil'\hspace{0.85em} \to \iota\,(\zero,\,\ttt) \\
  & \quad \Cons'\to \sigma\,(\Lift\,\Nat)\,\$\,\lambda\,n.\,\sigma\,(\Lift\,A)\,\$\,\lambda\,\_.\\
  & \quad \hspace{4em}  \delta\,(\Lift\,\top)\,\$\,\lambda\,f.\,\sigma\,((x : \top) \to \fst\,(f\,(\lup\!x)) = n)\,\$\,\lambda\,p.\\
  & \quad \hspace{4em}  \iota\,(\suc\,(\ldown\!n),\,\ttt)
\end{alignat*}
The first $\Nat$ component of the recursive result serves as the index. In the $\Cons'$ case we
have a single inductive field whose length is enforced with the extra $\sigma\,((x : \top) \to
\fst\,(f\,(\lup\!x)) = n)$.

\end{example}

\subsection{Type and Term Formers}\label{sec:iir-construction-type-term} Since the encoding of signatures
already ensures the well-indexing of inductive fields in constructors, it only remains to ensure
that the ``top-level'' index matches the externally supplied index. We define the $\IIR$ and $\El$
rules as follows.
\begin{alignat*}{3}
  &\IIR : \Sig_\IIR \to I \to \U_{\max(i,\,k)}                         && \El : \IIR\,S\,i \to O\,i \\
  &\IIR\,S\,i :\equiv (x : \IR\,\Sigr{S}) \times \fst\,(\El\,x) = i \hspace{3em}&& \El\,(x,\,p) :\equiv \tr\,O\,p\,(\snd\,(\El\,x))
\end{alignat*}
The following shorthand describes the data that we get when we peel off an $\intro$ from an $\IIR\,S\,i$ value:
\begin{alignat*}{4}
  &\blank_{\floord{0}} : (S : \Sig_\IR) \to I \to \U_{\max(i,\,k)}\\
  &S_{\floord{0}}\,i :\equiv (x : \floord{S}_0\,(\IR\,S)\,\El) \times \fst\,(S_1\,x) = i
\end{alignat*}
Now, we can show that $S_{\floord{0}}\,i$ is equivalent to $S_0\,(\IIR\,S)\,\El\,i$, by induction on
$S$. The induction is straightforward and we omit it here. We name the components of the equivalence
as follows:\footnote{In the Agda formalization, we
compute $\tau$ by induction on $S$, although it could be generically recovered from the other
four components as well \cite[Section~4.2]{hottbook}.}
\begin{alignat*}{4}
  &\ora{S_0} &&: S_0\,(\IIR\,S)\,\El\,i \to S_{\floord{0}}\,i \\
  &\ola{S_0} &&: S_{\floord{0}}\,i \to S_0\,(\IIR\,S)\,\El\,i \\
  &\eta      &&: \{x\} \to \ola{S_0}\,(\ora{S_0}\,x) = x \\
  &\epsilon  &&: \{x\} \to \ora{S_0}\,(\ola{S_0}\,x) = x \\
  &\tau      &&: \{x\} \to \ap\,\ora{S_0}\,(\eta\,x) = \epsilon\,(\ola{S_0}\,x)
\end{alignat*}
This is a half adjoint equivalence \cite[Section~4.2]{hottbook}. We will shortly use the coherence
witness $\tau$ to rearrange some transports. Next, we show that the two $\blank_1$ operations are
the same, modulo the previous equivalence, again by induction on IIR signatures.
\[\blank_{\floord{1}} : (S : \Sig_\IIR)(x : S_0\,(\IIR\,S)\,\El\,i) \to \tr\,O\,(\snd\,(\ora{S_0}\,x))\,(\snd\,(\floord{S}_1\,(\fst\,(\ora{S_0}\,x)))) = S_1\,x\]
This lets us define the other introduction rules as well.
\begin{alignat*}{3}
  &\intro    : S_0\,(\IIR\,S)\,\El\,i \to \IIR\,S\,i && \msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x \\
  &\intro\,x :\equiv (\intro_\IR\,(\fst\,(\ora{S_0}\,x)),\,\snd\,(\ora{S_0}\,x)) \quad\quad\quad&& \msf{El\!\!-\!\!intro} && :\equiv S_{\floord{1}}\,x
\end{alignat*}

\subsection{Elimination}\label{sec:iir-construction-elimination}

We assume a level $l$ for the elimination target. Recall the type of $\elim$:
\begin{alignat*}{3}
  &\elim :\,           &&(P : \{i : I\}\to \IIR\,S\,i \to \U_l)\\
  &                \quad\to && (f : \{i : I\}(x : S_0\,(\IIR\,S)\,\El\,i) \to S_\IH\,P\,x \to P\,(\intro\,x))\\
  &                \quad\to && (x : \IIR\,S\,i) \to P\,x
\end{alignat*}
Also recall that $x : \IIR\,S\,i$ is given as a pair of some $x : \IR\,\Sigr{S}$ and $p : \fst\,(\El\,x) = i$.
The idea is to use IR elimination on $x : \IR\,\floord{S}$ while adjusting both $P$ and $f$ to operate
on the appropriate data. We will use the following induction motive. Note that we generalize the induction goal
over the $p$ witness.
\begin{alignat*}{3}
  &\floord{P} : \IR\,\floord{S} \to \U_{\max(k,\,l)} \\
  &\floord{P}\,x :\equiv \{i : I\}(p : \fst\,(\El\,x) = i) \to P\,(x,\,p)
\end{alignat*}
Now, we have
\begin{alignat*}{3}
  & \elim_\IR\,\floord{P} : ((x : \floord{S}_0\,(\IR\,\floord{S})\,\El) \to \floord{S}_\IH\,\floord{P}\,x \to \floord{P}\,(\intro\,x))
       \to (x : \IR\,\floord{S}) \to \floord{P}\,x.
\end{alignat*}
We adjust $f$ to obtain the next argument to $\elim_\IR\,\floord{P}$. $f$ takes $S_\IH\,P\,x$ as input,
so we need a ``backwards'' conversion:
\begin{alignat*}{3}
  & \ola{S_\IH} : \{x : S_{\floord{0}}\,i\} \to \floord{S}_\IH\,\floord{P}\,(\fst\,x) \to S_\IH\,P\,(\ola{S_0}\,x)
\end{alignat*}
This is again defined by easy induction on $S$. The induction method $\floord{f}$ is as follows.
\begin{alignat*}{3}
  &\floord{f} : (x : \floord{S}_0\,(\IR\,\floord{S})\,\El) \to \floord{S}_\IH\,\floord{P}\,x \to \floord{P}\,(\intro\,x)\\
  &\floord{f}\,x\,\ih\,p :\equiv \tr\,\bigl(\lambda\,(x,\,p).\,P\,(\intro\,x,\,p)\bigr)\,\bigl(\epsilon\,(x,\,p)\bigr)\,
                                      \bigl(f\,(\ola{S_0}\,(x,\,p))\,(\ola{S_\IH}\,\ih)\bigr)
\end{alignat*}
Thus, the definition of elimination is:
\[ \elim\,P\,f\,(x,\,p) :\equiv \elim_\IR\,\floord{P}\,\floord{f}\,x\,p \]
Only the $\beta$-rule remains to be constructed:
\[ \elim\!-\!\!\beta : \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x) \]
Computing definitions on the \textbf{left hand side}, we get:
\begin{alignat*}{3}
  & \tr\, &&(\lambda\,(x,\,p).\,P\,(\intro\,x,\,p))\\
  &       &&(\epsilon\,(\ora{S_0}\,x))\\
  &       &&(f\,(\ola{S_0}\,(\ora{S_0}\,x))\,(\ola{S_\IH}\,(\floord{S}_\map\,\floord{P}\,(\lambda\,x\,p.\,\elim\,P\,f\,(x,\,p))\,(\fst\,(\ora{S_0}\,x)))))
\end{alignat*}
Next, we prove by induction on $S$ that $\blank_\map$ commutes with $\ora{S_0}$:
\[ S_{\floord{\map}} : \forall\,f\,x.\,\,S_\map\,P\,(\lambda\,(x,\,p).\,f\,x\,p)\,x = \tr\,\bigl(S_\IH\,P\bigr)\,\bigl(\eta\,x\bigr)\,\bigl(\ola{S_\IH}\,(\floord{S}_\map\,\floord{P}\,f\,(\fst\,(\ora{S_0}\,x)))\bigr)\]
Using this equation to rewrite the \textbf{right hand side}, we get:
\begin{alignat*}{3}
  f\,x\,\Bigl(\tr\,\bigl(S_\IH\,P\bigr)\,\bigl(\eta\,x\bigr)\,\bigl(\ola{S_\IH}\,(\floord{S}_\map\,\floord{P}\,(\lambda\,x\,p.\,\elim\,P\,f\,(x,\,p))\,(\fst\,(\ora{S_0}\,x)))\bigr)\Bigr)
\end{alignat*}
This is promising; on the left hand side we transport the result of $f$, while on the right hand
side we transport the argument of $f$. Now, the identification on the left is
$\epsilon\,(\ora{S_0}\,x)$, while we have $\eta\,x$ on the right. However, we have $\tau\,x :
\ap\,(\ora{S_0})\,(\eta\,x) = \epsilon\,(\ora{S_0}\,x)$, which can be used in conjunction with
standard transport lemmas to match up the two sides. This concludes the construction of IIR types.

\subsection{Strictness}
We briefly analyze the strictness of computation for constructed IIR types. Clearly, since the
construction is defined by induction on IIR signatures, we only have propositional
$\msf{El\!\!-\!\!intro}$ and $\elim\!-\!\!\beta$ in the general case where an IIR signature can be
neutral.

However, we still support the same definitional IIR computation rules as Agda and Idris. That is
because Agda and Idris only have second-class IIR signatures. There, signatures consist of
constructors with fixed configurations of fields, where constructors are disambiguated by canonical
name tags. $\El$ applied to a constructor computes definitionally, and so does the elimination
principle when applied to a constructor. Using our IIR types, we encode Agda IIR types as follows:
\begin{itemize}
\item We have $\sigma\,\Tag\,S$ on the top to represent constructor tags.
\item In $S$, we immediately pattern match on the tag.
\item All other $\Sig$ subterms are canonical in the rest of the signature.
\end{itemize}
Thus, if we apply $\El$ or $\elim$ to a value with a canonical tag, we compute past the branching on
the tag and then compute all the way on the rest of the signature. In the Agda supplement, we provide
length-indexed vectors and the $\Code$ universe as examples for constructed IIR types with strict
computation rules.

\subsection{Mechanization}

We formalized Section \ref{sec:iir-construction} in Agda. For the assumption of IR, we verbatim
reproduced the specification in Section \ref{sec:ir-specification}, turning $\IR$ into an inductive
type and $\El$ and $\elim$ into recursive functions. The functions are not recognized as terminating
by Agda, so we disable terminating checking for them. Alternatively, we could use rewrite rules
\cite{DBLP:journals/pacmpl/CockxTW21}; the two versions are the same except that rewrite rules have
a performance cost in type checking and evaluation that we prefer to avoid.

One small difference is that our object theory does not have internal universe levels, so we
understand level quantification to happen in a metatheory, while in Agda we use native universe
polymorphism.

\section{Canonicity}\label{sec:canonicity}

In this section we prove canonicity for the object theory extended with IR types. First, we specify
the metatheory and the object theory in more detail.

\subsection{Metatheory}\label{sec:metatheory}

\subsubsection{Specification} The metatheory supports the following:
\begin{itemize}
  \item A countable universe hierarchy and basic type formers as described in Section \ref{sec:basic-type-formers}.
    We write universes as $\Set_i$ instead of $\U_i$, to avoid confusion with object-theoretic
    universes.
  \item Equality reflection. Hence, in the following we will only use $\blank\!=\!\blank$ to denote
    metatheoretic equality, and we also write definitions with $:=$.
  \item Universe levels $\omega$ and $\omega+1$, where $\Set_\omega : \Set_{\omega + 1}$ and $\Set_{\omega + 1}$
        is a ``proper type'' that is not contained in any universe. $\Set_\omega$ and $\Set_{\omega + 1}$ are
        also closed under basic type formers.
  \item IR types (thus IIR types as well) in $\Set_i$ when $i$ is finite.
  \item An internal type of finite universe levels. This is similar to Agda's internal type of
    finite levels, called $\Level$ \cite{agdadocs}. The reason for this feature is the following. The
    object theory has countable levels represented as natural numbers, and we have to interpret
    those numbers as metatheoretic levels in the canonicity model, to correctly specify sizes of
    reducibility predicates.
  \item The syntax of the object theory as a quotient inductive-inductive type \cite{ttintt,DBLP:journals/corr/abs-2302-08837}, to be
    described in the following section.
\end{itemize}
\emph{Notation:} $\Lift$ is derivable the same way as we have seen, but we will make all
lifting implicit in the metatheory. In the object theory, explicit lifting is advisable, because
we talk about strict computation and canonicty, so we want to be precise about definitional
content. In the metatheory, we have equality reflection, so we can be more loose.

\subsubsection{Consistency of the metatheory}

\todo{TODO}

\subsection{The Object Theory}\label{sec:object-theory}

Informally, the object theory is a Martin-Löf type theory that supports basic type formers as
described in Section \ref{sec:basic-type-formers} and IR types as described in Section
\ref{sec:ir-specification}. More formally, the object theory is given as a quotient
inductive-inductive type. The sets, operations and equations that we give in the following together
constitute the inductive signature.

\subsubsection{Core substitution calculus} The basic judgmental structure is given
as a category with families (CwF) \cite{Dybjer96internaltype,cwfs} where types are additionally annotated with levels.
Concretely, we have
\begin{itemize}
\item A category of contexts and substitutions. We have $\Con : \Set_0$ for contexts and $\Sub : \Con \to \Con \to \Set_0$
  for substitutions. The empty context $\emptycon$ is the terminal object with the unique substitution $\epsilon : \Sub\,\Gamma\,\emptycon$.
  We write $\id$ for identity substitutions and $\blank\!\circ\!\blank$ for substitution composition.
\item Level-indexed types, as $\Ty : \Con \to \Nat \to \Set_0$, together with the functorial substitution operation
      $\blank[\blank] : \Ty\,\Delta\,i \to \Sub\,\Gamma\,\Delta \to \Ty\,\Gamma\,i$.
\item Terms as $\Tm : (\Gamma : \Con) \to \Ty\,\Gamma\,i \to \Set_0$, with functorial substitution operation
  $\blank[\blank] : \Tm\,\Delta\,A \to (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,A[\sigma]$.
  \emph{Notation:} both type and term substitution binds stronger than function application, so
  for example $\Tm\,\Gamma\,A[\sigma]$ means $\Tm\,\Gamma\,(A[\sigma])$.
\item Context comprehension, consisting of a context extension operation $\blank\!\ext\!\blank : (\Gamma : \Con) \to \Ty\,\Gamma\,i \to \Con$,
  weakening morphism $\p : \Sub\,(\Gamma\ext A)\,\Gamma$, zero variable $\q : \Tm\,(\Gamma\ext A)\,A[\p]$ and substitution extension $\blank,\!\blank : (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,A[\sigma] \to \Sub\,\Gamma\,(\Delta\ext A)$, such that the following equations hold:
  \begin{alignat*}{3}
    &\p \circ (\sigma,\,t)     &&= \sigma \\
    &\q[\sigma,\,t]            &&= t \\
    &(\p,\,\q)                 &&= \id \\
    &(\sigma,\,t) \circ \delta &&= (\sigma \circ \delta,\,t[\delta])
  \end{alignat*}
  Note that a De Bruijn index $N$ is represented as $\q[\p^N]$, where $\p^N$ is $N$-fold composition
  of weakening.
\end{itemize}

\subsubsection{Universes} We have Russell-style universes, where sets of terms of universes are identified with sets of types.
Concretely, we have $\U : (i : \Nat) \to \Ty\,\Gamma\,(i + 1)$ such that $\U_i[\sigma] = \U_i$ and
$\Tm\,\Gamma\,\U_i = \Ty\,\Gamma\,i$.  This lets us implicitly convert between types and terms with
universe types. Additionally, we specify that this casting operation commutes with substitution, so
substituting $t : \Tm\,\Gamma\,\U_i$ as a term and then casting to a type is the same as first
casting and then substituting as a type. Since we omit casts and overload $\blank[\blank]$, this
rule looks trivial in our notation, but it still has to be assumed.

\subsubsection{Functions} We have $\Pi : (A : \Ty\,\Gamma\,i) \to \Ty\,(\Gamma \ext A)\,j \to \Ty\,\Gamma\,\max(i,\,j)$
such that $(\Pi\,A\,B)[\sigma] = \Pi\,A[\sigma]\,B[\sigma\circ\p,\,\q]$.  Terms are specified by
$\app : \Tm\,\Gamma\,(\Pi\,A\,B) \to \Tm\,(\Gamma\ext A)\,B$ and its definitional inverse $\lam :
\Tm\,(\Gamma\ext A)\,B \to \Tm\,\Gamma\,(\Pi\,A\,B)$. This isomorphism is natural in $\Gamma$,
i.e.\ we have a substitution rule $(\lam\,t)[\sigma\circ\p,\,\q] = \lam\,t[\sigma]$.

\paragraph{Notation \& conventions} So far we have used standard definitions, but now we develop some
notations and conventions that are more tailored to our use case. CwF combinators and De Bruijn
indices get very hard to read when we get to more complicated rules like those in the specification
of IR types.

\begin{itemize}
\item Assuming $t : \Tm\,\Gamma\,(\Pi\,A\,B)$ and $u : \Tm\,\Gamma\,A$, traditional binary function
  application can be derived as $(\app\,t)[\id,\,u] : \Tm\,\Gamma\,B[\id,\,u]$. We overload the
  metatheoretic whitespace operator for this kind of object-level application.
\item We may give a name to a binder (a binder can be a context extension or a $\Pi$, $\Sigma$ or
  $\lam$ binder), and in the scope of the binder all occurrence of the name is desugared to a De
  Bruijn index.  We write $\Pi$-types using the same notation as in the metatheory. For example, $(A
  : \U_i) \to A \to A$ is desugared to $\Pi\,\U_i\,(\Pi\,\q\,\q[\p])$. We also reuse the notation
  and behavior of implicit functions. We write object-level lambda abstraction as $\lam\,x.t$.
\item
  In the following we specify all type and term formers as \emph{term constants with an iterated
  $\Pi$-type}.  For example, we will specify $\Id : \Tm\,\Gamma\,((A : \U_i) \to A \to A \to \U_i)$,
  instead of abstracting over $A : \Ty\,\Gamma\,i$ and $t,\,u : \Tm\,\Gamma\,A$. In the general, the
  two flavors are inter-derivable, but sticking to object-level functions lets us consistently use
  the sugar for named binders. Also, specifying stability under substitution becomes very simple: a
  substituted term constant is computed to the same constant (but living in a possibly different
  context). For example, if $\sigma : \Sub\,\Gamma\,\Delta$, then $\Id[\sigma] = \Id$ specifies
  stability under substitution for the identity type former. Hence, we shall omit substitution rules
  in the following.
\end{itemize}

\subsubsection{Sigma types} We have
\begin{alignat*}{3}
  &\Sigma        &&: \Tm\,\Gamma\,((A : \U_i) \to (A \to \U_j) \to \U_{\max(i,\,j)}) \\
  &\blank,\blank &&: \Tm\,\Gamma\,(\{A : \U_i\}\{B : A \to \U_j\}(t : A) \to B\,t \to \Sigma\,A\,B)\\
  &\fst          &&: \Tm\,\Gamma\,(\{A : \U_i\}\{B : A \to \U_j\} \to \Sigma\,A\,B \to A)\\
  &\snd          &&: \Tm\,\Gamma\,(\{A : \U_i\}\{B : A \to \U_j\}(t : \Sigma\,A\,B) \to B\,(\fst\,t))
\end{alignat*}
such that $\fst\,(t,\,u) = t$, $\snd\,(t,\,u) = u$ and $(\fst\,t,\,\snd\,u) = t$.

\subsubsection{Unit} We have $\top_i : \Tm\,\Gamma\,\U_i$ with the unique inhabitant $\ttt$.

\subsubsection{Booleans} Type formation is $\Bool : \Tm\,\Gamma\,\U_0$ with constructors $\true$ and $\false$. Elimination is as follows.
\begin{alignat*}{3}
  &\BoolElim : \Tm\,\Gamma\,((P : \Bool \to \U_i) \to P\,\true \to P\,\false \to (b : \Bool) \to P\,b)\\
  & \BoolElim\,P\,t\,f\,\true\hspace{0.2em} = t\\
  & \BoolElim\,P\,t\,f\,\false = f
\end{alignat*}

\subsubsection{Identity type}
\begin{alignat*}{3}
  &\Id   &&: \Tm\,\Gamma\,((A : \U_i) \to A \to A \to \U_i)\\
  &\refl &&: \Tm\,\Gamma\,(\{A : \U_i\}(t : A) \to \Id\,A\,t\,t)
\end{alignat*}
\begin{alignat*}{3}
  &\J : \Tm\,\Gamma\,(\{A : \U_i\}\{x : A\}(P : (y : A) \to \Id\,A\,x\,y \to \U_k)\\
  & \hspace{3.5em}\to P\,(\refl\,x) \to \{y : A\}(p : \Id\,A\,x\,y) \to P\,y\,p)&&
  &\\
  &\J\,P\,r\,(\refl\,x) = r
\end{alignat*}

\subsubsection{IR types} First, we specify the type of signatures as an inductive type. We assume levels $i$
and $j$.
\begin{alignat*}{3}
  &\Sig_i  &&: \Tm\,\Gamma\,((O : \U_j) \to \U_{\max(i+1,\,j)})\\
  &\iota   &&: \Tm\,\Gamma\,(\{O : \U_j\} \to O \to \Sig_i\,O)\\
  &\sigma  &&: \Tm\,\Gamma\,(\{O : \U_j\}(A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O)\\
  &\delta  &&: \Tm\,\Gamma\,(\{O : \U_j\}(A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O)
\end{alignat*}
\begin{alignat*}{3}
  &\SigElim : \Tm\,\Gamma\,(\{O : \U_j\}(P : \Sig_i\,O \to \U_k)\\
  &           \hspace{2.2em}\to ((o : O) \to P\,(\iota\,o))\\
  &           \hspace{2.2em}\to ((A : \U_i)(S : A \to \Sig_i\,O) \to ((a : A) \to P\,(S\,a)) \to P\,(\sigma\,A\,S))\\
  &           \hspace{2.2em}\to ((A : \U_i)(S : (A \to O) \to \Sig_i\,O) \to ((f : A \to O) \to P\,(S\,f)) \to P\,(\delta\,A\,S))\\
  &           \hspace{2.2em}\to (S : \Sig_i\,O) \to P\,S)\\
  &\\
  &\SigElim\,P\,i\,s\,d\,(\iota\,o) \hspace{1.1em} = i\\
  &\SigElim\,P\,i\,s\,d\,(\sigma\,A\,S) = s\,A\,S\,(\lam\,a.\,\SigElim\,P[\p]\,i[\p]\,s[\p]\,d[\p]\,(S[\p]\,a))\\
  &\SigElim\,P\,i\,s\,d\,(\delta\,A\,S) \hspace{0.1em}= d\,A\,S\,(\lam\,f.\,\SigElim\,P[\p]\,i[\p]\,s[\p]\,d[\p]\,(S[\p]\,f))
\end{alignat*}
Note the $[\p]$ weakenings in the computation rules: $P$, $i$, $s$, $d$, and $S$ are all terms
quantified in some implicit context $\Gamma$, so when we mention them under an extra binder, we have
to weaken them. Hence, we cannot fully avoid explicit substitution operations by using named
binders. We already saw rest of the specification in Section \ref{sec:ir-specification} so we only give a short
summary.
\begin{itemize}
\item $\blank_0$, $\blank_1$, $\blank_\map$ and $\blank_\IH$ are defined by $\SigElim$ and they satisfy the same definitional equations
  as in Section \ref{sec:ir-specification}.
\item $\IR$, $\El$, $\intro$, $\elim$ are all specified as term constants that are only parameterized over contexts and some universe levels.
\end{itemize}

\subsection{Canonicity of the Object Theory}\label{sec:canonicity-model}

On a high level, canonicity is proved by induction over the syntax of the object theory. Since the
syntax is a quotient inductive-inductive type, it supports an induction principle, which we do not
write out fully here, and only use one particular instance of it. Formally, the induction principle
takes a \emph{displayed model} as an argument, which corresponds to a bundle of induction motives
and methods, and proofs that quotient equations are respected
\cite[Chapter~4]{DBLP:journals/corr/abs-2302-08837}. We could present the current construction as a
displayed model. However, we find it a bit more readable to instead use an Agda-like notation, where
we specify the resulting \emph{section} of the displayed model, which consists of a collection of
mutual functions, mapping out from the syntax, which have action on constructors and respect all
quotient equations.

\emph{Notation:} in the following we write $\Tm\,A$ to mean $\Tm\,\emptycon\,A$, and
$\Sub\,\Gamma$ to mean $\Sub\,\emptycon\,\Gamma$. This will reduce clutter since we will mostly work
with closed terms and substitutions.

We aim to define the following functions by induction on object syntax.
\begin{alignat*}{3}
  &\blank^\w : (\Gamma : \Con)      && \to \Sub\,\Gamma \to \Set_\omega\\
  &\blank^\w : (A : \Ty\,\Gamma\,i) && \to \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to \Tm\,A[\gamma] \to \Set_i\\
  &\blank^\w : (\sigma : \Sub\,\Gamma\,\Delta) && \to \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to \Delta^\w\,(\sigma \circ \gamma)\\
  &\blank^\w : (t : \Tm\,\Gamma\,A) && \to \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to A^\w\,\gamma^\w\,t[\gamma]
\end{alignat*}

It is a proof-relevant logical predicate interpretation, an instance of a construction called
\emph{Artin gluing} \cite[Exposé~4,~Section~9.5]{SGA4} or \emph{categorical gluing}. The concrete
formulation that we use is the type-theoretic gluing by \citet{gluing}. This is parameterized by a
weak morphism between models of the object type theory. In our case, we take this morphism to be the
global sections functor between the syntax and a standard $\Set$ model. This means that we build
predicates over closed substitutions and closed terms. Coquand's canonicity proof also uses the same
definitions as ours \cite{coquand2018canonicity}.

The type-theoretic gluing is a variation of gluing which uses dependent type families
instead of the fibered families of the categorical flavor. The type-theoretic style becomes valuable
when we get to the interpretation of more complicated type formers, where it is easier to use than
diagrammatic reasoning.

\subsubsection{Interpretation of the CwF and the basic type formers}

This was described in the mentioned sources \cite{gluing,coquand2018canonicity}. Additionally,
the code supplement \cite{formalisation} to \cite{DBLP:conf/mpc/KaposiKK19} has an Agda
formalization of the canonicity model with the exact same universe setup and basic type formers that
we use. Therefore we only present the parts here which are relevant to the interpretation of IR
types. The interpretation of empty and extended contexts is as follows.
\begin{alignat*}{3}
  &\emptycon^\w\,&&\gamma                 &&:= \top \\
  &(\Gamma\ext A)^\w\,&&(\gamma,\,\alpha) &&:= (\gamma^\w : \Gamma^\w\,\gamma) \times A^\w\,\gamma^\w\,\alpha
\end{alignat*}
This says that the logical predicate holds for a closing substitution if it holds for each term in
the substitution. Note the pattern matching notation in $(\gamma,\,\alpha)$: this is justified,
since all values of $\Sub\,(\Gamma\ext A)$ are uniquely given as a pairing (similarly to pattern
matching notation for plain $\Sigma$-types). The other CwF operations are as follows.
\begin{alignat*}{4}
  &\id^\w\,\gamma^\w                   &&:= \gamma^\w                  &&(\sigma,\,t)^\w\,\gamma^\w          &&:= (\sigma^\w\,\gamma^\w,\,t^\w\,\gamma^\w)\\
  &(\sigma \circ \delta)^\w\,\gamma^\w &&:= \sigma^\w\,(\delta^\w\,\gamma^\w) && \p^\w\,(\gamma^\w,\,\alpha^\w)      &&:= \gamma^\w\\
  &(A[\sigma]) ^\w\,\gamma^\w\,\alpha  &&:= A^\w\,(\sigma^\w\,\gamma^\w)\,\alpha\hspace{3em} && \q^\w\,(\gamma^\w,\,\alpha^\w)      &&:= \alpha^\w\\
  &(t[\sigma]) ^\w\,\gamma^\w          &&:= t^\w\,(\sigma^\w\,\gamma^\w) && \epsilon^\w\,\gamma^\w              &&:= \ttt
\end{alignat*}
The interpretation of \textbf{universes} is the following.
\begin{alignat*}{4}
  &(\U_i)^\w\,\gamma^\w\,\alpha := \Tm\,\alpha \to \Set_i
\end{alignat*}
This definition also supports the Russell universe rules. For illustration, assuming $t :
\Tm\,\Gamma\,\U_i$, we have $t^\w : \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to
\Tm\,t[\gamma] \to \Set_i$. If we first cast $t$ to a type using the syntactic Russell
universe equation, then $t^\w$ has exactly the same type.

Note that we do not get a canonicity statement about types themselves, i.e.\ we do not get that
every closed type is definitionally equal to one of the canonical type formers. This could be handled
as well, but we skip it because it is orthogonal to the focus of this paper.

We interpret \textbf{functions} as follows.
\begin{alignat*}{4}
  &(\Pi\,A\,B)^\w\,\{\gamma\}\,\gamma^\w\,f &&:= \{\alpha : \Tm\,A[\gamma]\}(\alpha^\w : A^\w\,\gamma^\w\,\alpha) \to B^\w\,(\gamma^\w,\,\alpha^\w)\,(f\,\alpha)\\
  &(\lam\,t)^\w\,\gamma^\w &&:= \lambda\,\{\alpha\}\,\alpha^\w.\,t^\w\,(\gamma^\w,\,\alpha^\w)\\
  &(\app\,t)^\w\,(\gamma^\w,\,\alpha^\w) &&:= t^\w\,\gamma^\w\,\alpha^\w
\end{alignat*}
In the $\Pi\,A\,B$ case, note that $f : \Tm\,(\Pi\,A\,B)[\gamma]$, which means that we can apply it
to $\alpha$ to get $f\,\alpha : \Tm\,B[\gamma,\,\alpha]$. We can also derive the interpretation of
binary applications: $(t\,u)^\w\,\gamma^\w$ is computed to $t^\w\,\gamma^\w\,(u^\w\,\gamma^\w)$.

For \textbf{$\Sigma$-types}, we have
\begin{alignat*}{4}
  &\Sigma^\w\,\gamma^\w\,A^\w\,B^\w\,(t,\,u)   &&:= (t^\w : A^\w\,t) \times B^\w\,t^\w\,u\hspace{2em}  && \fst^\w\,\gamma^\w\,(t^\w,\,u^\w) &&:= t^\w \\
  &(\blank,\blank)^\w\,\gamma^\w\,t^\w\,u^\w   &&:= (t^\w,\,u^\w)                                     && \snd^\w\,\gamma^\w\,(t^\w,\,u^\w) &&:= u^\w
\end{alignat*}
For the \textbf{unit type}, we have $\top^\w\,\gamma^\w\,t := \top$ and $\ttt^\w\,\gamma^\w := \ttt$.

\subsubsection{Interpretation of IR signatures}

Signatures are given as an ordinary inductive family, so in principle there should be nothing
``new'' in their logical predicate interpretation. We do detail it here because several later
constructions depend on it. Recall that $\Sig_i : \Tm\,\Gamma\,((O : \U_j) \to \U_{\max(i+1,\,j)})$,
so we have
\begin{alignat*}{3}
  &(\Sig_i)^\w\,\gamma^\w : ((O : \U_j) \to \U_{\max(i+1,\,j)})^\w\,\gamma^\w\,\Sig_i\\
  &(\Sig_i)^\w\,\gamma^\w : \{O : \Tm\,\U_j\}(O^\w : (\U_j)^\w\,\gamma^\w\,O) \to (\U_{\max(i+1,\,j)})^\w\,\gamma^\w\,(\Sig_i\,O)\\
  &(\Sig_i)^\w\,\gamma^\w : \{O : \Tm\,\U_i\}(O^\w : \Tm\,O \to \Set_i) \to \Tm\,(\Sig_i\,O) \to \Set_{\max(i+1,\,j)}.
\end{alignat*}
Hence, we define an inductive type in the metatheory that is parameterized by $O : \Tm\,U_i$ and
$O^\w : \Tm\,O \to \Set_i$ and indexed over $\Tm\,(\Sig_i\,O)$. We name this inductive type
$\Sig^\w$; the naming risks some confusion, but we shall take the risk and we will shortly
explain the rationale.
\begin{alignat*}{4}
  &\rlap{$\data\,\Sig^\w\,\{O : \Tm\,U_j\}\,(O^\w : \Tm\,O \to \Set_i)  : \Tm\,(\Sig_i\,O) \to \Set_{\max(i+1,\,j)}$}\\
  &\quad \iota^\w  &&:\,&&\{o &&: \Tm\,O\}(o^\w : O^\w\,o) \to \Sig^\w\,O^\w\,(\iota\,o)\\
  &\quad \sigma^\w &&:\,&&\{A &&: \Tm\,\U_i\}(A^\w : \Tm\,A \to \Set_i)\\
  &               && &&\{S &&: \Tm\,(A \to \Sig_i\,O)\}\\
  &               && && (S^\w &&: \{a : \Tm\,A\} \to A^\w\,a \to \Sig^\w\,O^\w\,(S\,a))\\
  &               && && \to &&\,\Sig^\w\,O^\w\,(\sigma\,A\,S)\\
  &\quad \delta^\w &&:\,&&\{A &&: \Tm\,\U_i\}(A^\w : \Tm\,A \to \Set_i)\\
  &               &&   && \{S &&: \Tm\,((A \to O) \to \Sig_i\,O)\}\\
  &               &&   && (S^\w &&: \{f : \Tm\,(A \to O)\} \to (\{a : \Tm\,A\} \to A^\w\,a \to O^\w\,(f\,a)) \to \Sig^\w\,O^\w\,(S\,f))\\
  &\quad          &&   && \to &&\,\Sig^\w\,O^\w\,(\delta\,S\,f)
\end{alignat*}
A witness of $\Sig^\w\,O^\w\,t$ tells us that $t$ is a canonical constructor and it only contains
canonical data, inductively. Now, we define $(\Sig_i)^\w\,\gamma^\w\,O^\w\,t$ to be
$\Sig^\w\,O^\w\,t$, and each syntactic $\Sig$ constructor is interpreted using the corresponding
semantic constructor. For instance:
\begin{alignat*}{4}
  &\iota^\w : \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma)\{O : \Tm\,\U_j\}\{O^\w : \Tm\,O \to \Set_j\}\{o : \Tm\,O\} \to O^\w\,o \to \Sig^\w\,O^\w\,(\iota\,o)\\
  &\iota^\w\,\gamma^\w\,o^\w := \iota^\w\,o^\w
\end{alignat*}
We skip the interpretation of the other constructors and the eliminator here. Above on the left side
we use $\iota^\w$ for specifying the action of $\blank^\w$ on the syntactic $\iota$, while on the
right side we use the metatheoretic $\Sig^\w$ constructor $\iota^\w$. In general, the recipe is:
\begin{enumerate}
\item We first give semantic definitions that only refer to closed terms.
\item Then, we ``contextualize'' the definitions to get interpretations of object-theoretic rules.
\end{enumerate}
In this section, the bulk of the work is phase (1) and phase (2) is fairly trivial. In phase (1), we
use $\blank^\w$ to mark semantic definitions and we do not need to refer to $\blank^\w$ as a family
of interpretation functions on the object syntax. In phase (2) we do overload $\blank^\w$ but
hope that it does not generate too much confusion.

\subsubsection{Interpretation of IR types}

The basic idea is that for each IR type, the corresponding canonicity predicate should be defined as
a metatheoretic IIR type. This gets rather technical, so first let us look at an informal example
for a concrete IR type.

\begin{example}\label{ex:code-canonicity}
Consider the Agda code example in Section \ref{sec:introduction}. We present the logical predicate interpretation for the
IR type in an informal Agda-like syntax, focusing on readability. We assume the same IR type in the object
theory, in Agda's style, disregarding elimination for now:
\begin{alignat*}{4}
  &\Code &&: \Tm\,\U_0 && \El : \Tm\,(\Code \to \U_0) \\
  &\Nat' &&: \Tm\,\Code && \El\,\Nat'\hspace{1.5em} = \Nat \\
  &\Pi'  &&: \Tm\,((A : \Code) \to (\El\,A \to \Code) \to \Code)\hspace{1em} && \El\,(\Pi'\,A\,B) = (a : \El\,A) \to \El\,(B\,a)
\end{alignat*}
We assume $\Nat^\w : \Tm\,\Nat \to \Set_0$. The canonicity interpretation is given by the following IIR type.
\begin{alignat*}{4}
  &\Code^\w &&: \,\,&& \Tm\,\Code \to \Set_0\quad\\
  &\El^\w   &&: \,\,&& \{t : \Tm\,\Code\} \to \Code^\w\,t \to (\Tm\,(\El\,t) \to \Set_0)\\
  &\Nat'^\w &&: \,\,&& \Code^\w\,\Nat'\\
  &\Pi'^\w  &&: \,\,&&\{A : \Tm\,\Code\}(A^\w : \Code^\w\,A)\\
  &         &&  && \{B : \Tm\,(\El\,A \to \Code)\}(B^\w : \{a : \Tm\,(\El\,a)\} \to \El^\w\,A^\w\,a \to \Code^\w\,(B\,a))\\
  &         &&  && \to \Code^\w\,(\Pi'\,A\,B)\\
  &\rlap{}\\
  &\rlap{$\El^\w\,\Nat'^\w\,t \hspace{2.55em}= \Nat^\w\,t$}  \\
  &\rlap{$\El^\w\,(\Pi'^\w\,A^\w\,B^\w)\,f = \{a : \Tm\,A\} \to \El^\w\,A^\w\,a \to \El^\w\,B^\w\,(f\,a)$}
\end{alignat*}
We could also extend this with elimination for $\Code$ and then use $\Code^\w$-elimination to show
that it preserves logical predicates. In other words, the above definition is sufficient to prove canonicity
for $\Code$ as a concrete IR type. The task in this section is to do the same construction generically
for all IR types.
\end{example}

We proceed to the semantic definitions. We assume the following parameters: $O : \Tm\,U_j$, $O^\w :
\Tm\,O \to \Set_j$, $S^* : \Tm\,(\Sig_i\,O)$ and $S^{*\w} :
\Sig^\w\,O^\w\,S^*$. \emph{Abbreviation:} we write $\Sig^\w\,S$ in the following, omitting the fixed
$O^\w$ parameter from the type.  We view $S^*$ as a ``fixed'' top-level signature, in contrast to
``varying'' signatures that we will encounter in constructions. More concretely, we will do most
constructions by induction on \emph{canonical sub-signatures} of $S^*$.

\begin{definition}[Canonical sub-signatures of $S^*$]
We define an inductive family indexed
over $S$ and $S^\w : \Sig^\w\,O^\w\,S$, which represents paths into $S^*$ that lead to $S$, viewing
$S$ as a subtree. Also, the subtree $S$ and all data in the path must be canonical (i.e.\ have $\blank^\w$
witnesses). The path is represented as a left-associated \emph{snoc-list} of data that can be
plugged into $\sigma$ and $\delta$ constructors. Moreover, we restrict the $\delta$ case, only
allowing $f : \Tm\,(A \to \IR\,S^*)$ functions instead of functions of type $\Tm\,(A \to O)$.
\begin{alignat*}{4}
  &\rlap{$\data\,\Path : \{S : \Tm\,(\Sig_i\,O)\} \to \Sig^\w\,S \to \Set_{\max(i+1,\,j+1)}$}\\
  &\quad \here    &&: \Path\,\Ssw\\
  &\quad \insigma &&: \Path\,(\sigma^\w\,A^\w\,S^\w) \to \{a : \Tm\,A\}(a^\w : A^\w\,a) \to \Path\,(S^\w\,a^\w) \\
  &\quad \indelta &&: \Path\,(\delta^\w\,A^\w\,S^\w) \to \{f : \Tm\,(A \to \IR\,S^*)\}(f^\w : \{a : \Tm\,A\} \to A^\w\,a \to O^\w\,(\El\,(f\,a)))\\
  &               && \hspace{0.6em} \to \Path\,(S^\w\,f^\w)
\end{alignat*}

If we have a path to $S^\w : \Sig^\w\,S$, we can push the terms contained in the path onto a
term of $S_0\,(\IR\,S^*)\,\El$:
\begin{alignat*}{4}
  & \hspace{-6em}\rlap{$\push_0 : \Path\,S^\w \to \Tm\,(S_0\,(\IR\,S^*)\,\El) \to \Tm\,((S^*)_0\,(\IR\,S^*)\,\El)$}\\
  & \hspace{-6em}\push_0\,\here\,                     &&t := t\\
  & \hspace{-6em}\push_0\,(\insigma\,p\,\{a\}\,a^\w)\,&&t := \push_0\,p\,(a,\,t)\\
  & \hspace{-6em}\push_0\,(\indelta\,p\,\{f\}\,f^\w)\,&&t := \push_0\,p\,(f,\,t)
\end{alignat*}
We also show that this operation preserves $\blank_1$, so we have $S_1\,t = (S^*)_1\,(\push_0\,p\,t)$.
\end{definition}

\begin{definition}[Encoding for signatures]
Next, we define the encoding function for signatures.
Note that this computation is only possible by induction on $\Sig^\w\,S$ \--- we have no appropriate
induction principle for $\Tm\,(\Sig_i\,O)$.  As we recurse into a signature, we store the
data that we have seen in a $\Path$, and when we hit the base case $\iota^\w$, we use the $\Path$ to
build up the correct term for the constructor index.
\begin{alignat*}{5}
  &\rlap{$\floord{\blank} : (S^\w : \Sig^\w\,S) \to \Path\,S^\w \to \Sig_\IIR\,(\Tm\,(\IR\,S^*))\,(O^\w\circ \El)$}\\
  &\floord{\iota^\w\,o^\w}\,&&p               &&:=\,&&\iota\,(\intro\,(\push_0\,p\,\ttt))\,o^\w\\
  &\floord{\sigma^\w\,\{A\}\,A^\w\,S^\w}\,&&p &&:=\,&&\sigma\,(\Tm\,A)\,\$\,\lambda\,a.\,\sigma\,(A^\w\,a)\,\$\,\lambda\,a^\w.\,\floord{S^\w\,a^\w}\,(\insigma\,p\,a^\w)\\
  &\floord{\delta^\w\,\{A\}\,A^\w\,S^\w}\,&&p &&:=\,&&\sigma\,(\Tm\,(A \to \IR\,S^*))\,\$\,\lambda\,f.\,\delta\,((a : \Tm\,A) \times A^\w\,a) (\lambda\,(a,\,\_).\,f\,a)\,\$\,\lambda\,f^\w.\\
  &                       &&              &&   &&\hspace{0.8em}\floord{S^\w\,(\lambda\,\{a\}\,a^\w.\,f^\w\,(a,\,a^\w))}\,(\indelta\,p\,(\lambda\,\{a\}\,a^\w.\,f^\w\,(a,\,a^\w)))
\end{alignat*}
Some remarks:
\begin{itemize}
  \item The metatheoretic IIR type is indexed over $\Tm\,(\IR\,S^*)$, and the recursive output type
    is given by $O^\w\circ \El : \Tm\,(\IR\,S^*) \to \Set_j$. Here, we implicitly cast the syntactic
    $\El : \Tm\,(\IR\,S^* \to O)$ to the funtion type $\Tm\,(\IR\,S^*) \to \Tm\,O$.
  \item In the $\iota^\w$ case, we have $o^\w : O^\w\,o$ and
    \[ \iota : (t : \Tm\,(\IR\,S^*)) \to O^\w\,(\El\,t) \to \Sig_\IIR\,(\Tm\,(\IR\,S^*))\,(O^\w\circ \El). \]
    We have $\intro\,(\push_0\,p\,\ttt) : \Tm\,(\IR\,S^*)$. If we apply $\El$ to this term, it computes
    to $(S^*)_1\,(\push_0\,p\,\ttt)$, which is the same as $(\iota\,o)_1\,\ttt$, which is the same
    as $o$, which makes $o^\w : O^\w\,o$ well-typed for the second argument.
  \item In the $\sigma^\w$ case, we use two $\sigma$-s to abstract over a term and a canonicity witness for it.
  \item In the $\delta^\w$ case, we abstract over $f : \Tm\,(A \to \IR\,S^*)$, then we use $\delta$ to specify inductive
        witnesses for all ``subtrees'' that are obtained by applying $f$ to canonical terms.
\end{itemize}
\end{definition}


\begin{example}\label{ex:code-canonicity-signature} Let $S^*$ be the signature from Example \ref{ex:code-signature}. It depends on the $\Tag$ and $\Nat$ types,
so we assume evident $\blank^\w$ interpretations for them. Now, $S^* : \Tm\,(\Sig_0\,\U_0)$ is a closed term
that does not refer to any IR type or term former, so we can already fully compute the $\blank^\w$
operation on it, obtaining $\Ssw : \Sig^\w\,(\lambda\,A.\,\Tm\,A \to \Set_0)\,S^*$. Then, we compute the following.
\begin{alignat*}{4}
  & \floord{\Ssw}\,\here : \Sig_\IIR\,(\Tm\,(\IR\,S^*))\,(\lambda\,t.\,\Tm\,(\El\,t) \to \Set_0)\\
  & \floord{\Ssw}\,\here = \sigma\,(\Tm\,\Tag)\,\$\,\lambda\,t.\,\sigma\,(\Tag^\w\,t)\,\$\,\lambda\,t^\w.\,\case\,t^\w\,\of\\
  & \quad \Nat'^\w \to \iota\,(\intro\,(\Nat',\,\ttt))\,\Nat^\w\\
  & \quad \Pi'^\w\hspace{0.8em} \to \sigma\,(\Tm\,(\top \to \IR\,S^*))\hspace{1.75em}\$\,\lambda\,A.\,
                      \delta\,((a : \Tm\,\top) \times \top)\hspace{4.4em}(\fst \circ A)\,\$\,\lambda\,\{{ElA}\}\,{ElA}^\w.\\
  & \hspace{4.8em} \sigma\,(\Tm\,({ElA}\,\ttt \to \IR\,S^*))\,\$\,\lambda\,B.\,
                      \delta\,((a : \Tm\,({ElA}\,\ttt)) \times {ElA}^\w\,a)\,(\fst \circ B)\,\$\,\lambda\,\{{ElB}\}\,{ElB}^\w.\\
  & \hspace{4.8em} \iota\,\,(\intro\,(\Pi',\,A,\,B,\,\ttt))\,(\lambda\,f.\,\{a : \Tm\,({ElA}\,\ttt)\} \to {ElA}^\w\,a \to {ElB}^\w\,(f\,a))
\end{alignat*}
This specifies essentially the same IIR type that we had in Example \ref{ex:code-canonicity}, with
some extra noise in the first argument of $\Pi'$, which is represented as a function with $\top$
domain.
\end{example}

\begin{definition}[Interpretation of $\IR$ and $\El$]
This time around, encoded signatures get us precisely what we want:
\begin{alignat*}{4}
  &\IR^\w : \Tm\,(\IR\,S^*) \to \Set_i \quad\quad && \El^\w : \{t : \Tm\,(\IR\,S^*)\} \to \IR^\w\,t \to O^\w\,(\El\,t)\\
  &\IR^\w := \IIR\,\PSbe                          && \El^\w := \El_\IIR
\end{alignat*}
\end{definition}

\begin{definition}[Interpretation of $\intro$]
For this, we need to show an equivalence between two representations of $\IR^\w$'s data, somewhat
similarly to as in Section \ref{sec:iir-construction-type-term}. For $\intro$, we only need one
component map of the equivalence, but later we will need all of it.

First, we define the predicate interpretations of $\blank_0$ and $\blank_1$. The general form states
that $\blank_0$ and $\blank_1$ preserve predicates, but we will only need the special case when the
$\ir$ and $\el$ arguments are $\IR\,S$ and $\El$ respectively.
\begin{alignat*}{3}
  & \blank_{0^\w} : \Sig^\w\,S \to \Tm\,(S_0\,(\IR\,S^*)\,\El) \to \Set_i\\
  & \blank_{1^\w} : (S^\w : \Sig^\w\,S)\{t : \Tm\,(S_0\,(\IR\,S^*)\,\El)\} \to (S^\w)_{0^\w}\,t \to O^\w\,(S_1\,t)
\end{alignat*}
Second, we define
\begin{alignat*}{3}
  &\blank_{\floord{0}} : (S^\w : \Sig^\w\,S) \to \Path\,S^\w \to \Tm\,(\IR\,S^*) \to \Set_i\\
  &(S^\w)_{\floord{0}}\,p\,t := (t' : \Tm\,(S_0\,(\IR\,S^*)\,\El)) \times ((\intro\,(\push_0\,p\,t') = t) \times (S^\w)_{0^\w}\,t').
\end{alignat*}
Next, we show the following equivalence by induction on $S^\w$:
\[  (S^\w : \Sig^\w\,S)(p : \Path\,S^\w)\{t : \Tm\,(\IR\,S^*)\} \to (S^\w)_{\floord{0}}\,p\,t \simeq (\floord{S^\w}\,p)_0\,t \]
We write $\ora{(S^\w)_0}\,p$ for the map with type $(S^\w)_{\floord{0}}\,p\,t \to (\floord{S^\w}\,p)_0\,t$ and
$\ola{(S^\w)_0}\,p$ for its inverse. This lets us interpret $\intro$.
\begin{alignat*}{4}
  & \intro^\w : \{t : \Tm\,((S^*)_{0^\w}\,(\IR\,S^*)\,\El)\} \to (\Ssw)_{0^\w}\,t \to \IR^\w\,(\intro\,t)\\
  & \intro^\w\,\{t\}\,t^\w := \intro_\IIR\,(\ora{(\Ssw)_0}\,\,\here\,(t,\,\refl,\,t^\w))
\end{alignat*}
\end{definition}

\begin{definition}[Interpretation of $\Elintro$]\label{sec:canonicity-elintro}
Similarly as in Section \ref{sec:iir-construction-type-term}, we need to show that $\blank_1$ commutes with signature
encoding. For this, we need to annotate $\Path$ with additional information. Recall that the
current definition of $\Path$ is not quite the most general notion of paths in signatures,
because the $\indelta$ constructor restricts the stored syntactic functions to the form $\El \circ f
: \Tm\,(A \to O)$, only storing $f : \Tm\,(A \to \IR\,S^*)$. This restriction is required for the
definition of $\push_0$, where we need to produce $\Tm\,((S^*)_0\,(\IR\,S^*)\,\El)$ as output.

Now we also need to restrict the $f^\w$ witnesses in $\indelta$ to the form $f^\w \circ \El^\w$,
where $f^\w : \{a : \Tm\,A\} \to A^\w\,a \to \IR^\w\,(f\,a)$. We define a predicate over $\Path$
that expresses this:
\[ \msf{restrict} : \Path\,S^\w \to \Set_{\max(i+1,\,j+1)} \]
This is required for the predicate interpretation of $\push_0$, which is defined by induction on $\Path$:
\[ \push_{0^\w} : (p : \Path\,S^\w) \to \msf{restrict}\,p \to (S^\w)_{0^\w}\,t \to (\Ssw)_{0^\w}\,(\push_0\,p\,t) \]
This operation preserves $\blank_{1^\w}$:
\[ (S^\w)_{1^\w}\,t^\w = (\Ssw)_{1^\w}\,(\push_{0^\w}\,p\,q\,t^\w)  \]
We use $\push_{0^\w}$ in the statement of $\blank_{\floord{1}}$, which we prove by induction on
$S^\w$:
\[ \blank_{\floord{1}} : \forall\,S^\w\,p\,q\,t^\w.\,(\floord{S^\w}\,p)_1\,(\ora{(S^\w)_0}\,p\,t^\w) = (\Ssw)_{1^\w}\,(\push_{0^\w}\,p\,q\,t^\w) \]
Finally, we define $\Elintro^\w$:
\begin{alignat*}{3}
    &\Elintro^\w : \{t : \Tm\,((S^*)_0\,(\IR\,S^*)\,\El)\}(t^\w : (\Ssw)_{0^\w}\,t) \to \El^\w\,(\intro^\w\,t^\w) = (\Ssw)_{1^\w}\,t^\w\\
    &\Elintro^\w\,t^\w := (\Ssw)_{\floord{1}}\,\here\,\ttt\,t^\w
\end{alignat*}
Above, $\ttt$ witnesses the restriction of $\here$, which is trivial (since $\here$ does not contain $\indelta$).
\end{definition}

\begin{definition}[Interpretation of $\elim$]
We assume the following parameters to elimination:
\begin{alignat*}{4}
  &k    &&:\,\,&&\Nat\\
  &P    &&:&& \Tm\,(\IR\,S^* \to \U_k)\\
  &P^\w &&:&& \{t\} \to \IR^\w\,t \to \Tm\,(P\,t) \to \Set_k
\end{alignat*}
We define the predicate interpretations for $\blank_\IH$ and $\blank_\map$ first,
specializing the $\ir$ and $\el$ arguments to $\IR\,S^*$ and $\El$ and the target level to $k$.
\begin{alignat*}{3}
  &\blank_{\IH^\w}  &&:\,\,&& \{S\}(S^\w : \Sig^\w\,S)\{t\} \to (S^\w)_{0^\w}\,t \to \Tm\,(S_\IH\,t) \to \Set_{\max(i,\,k)}\\
  &\blank_{\map^\w} &&:\,\,&& \{S\}(S^\w : \Sig^\w\,S)\{f\}(f^\w : \{t\}(t^\w : \IR^\w\,t) \to P^\w\,t^\w\,(f\,t))\{t\}(t^\w : (S^\w)_{0^\w}\,t)\\
  &               &&      &&\to (S^\w)_{\IH^\w}\,S^\w\,t^\w\,(S_\map\,f\,t)
\end{alignat*}
We also assume the induction method and its canonicity witness as parameters:
\begin{alignat*}{3}
  &f    &&:\,\,&& (t : \Tm\,((S^*)_0\,(\IR\,S^*)\,\El) \to (S^*)_\IH\,t \to P\,(\intro\,t))\\
  &f^\w &&:\,\,&& \{t\}(t^\w : (\Ssw)_{0^\w}\,t)\{\ih\} \to (\Ssw)_{\IH^\w}\,t^\w\,\ih \to P^\w\,(\intro^\w\,t^\w)\,(f\,t\,\ih)
\end{alignat*}
The goal is the following:
\[ \elim^\w : \{t\}(t^\w : \IR^\w\,t) \to P^\w\,t^\w\,(\elim\,S^*\,P\,f\,t)  \]
We shall use IIR elimination on $t^\w$ to give the definition. Again like in Section \ref{sec:iir-construction-elimination}, we
have to massage $P^\w$ and $f^\w$ to be able to pass them to $\elim_\IIR$. For the former, we have
\begin{alignat*}{4}
  &\floord{P^\w} : \{t\} \to \IR^\w\,t \to \Set_k\\
  &\floord{P^\w}\,\{t\}\,t^\w := P^\w\,x^\w\,(\elim\,S^*\,P\,f\,t).
\end{alignat*}
For the latter, we first define decoding for induction hypotheses, by induction
on $S^\w$:
\begin{alignat*}{4}
  &\ola{(S^\w)_\IH} &&\,\,:&&(\floord{S^\w}\,p)_\IH\,\floord{P^\w}\,t^\w\\
  & &&\to\,\,&&(S^\w)_{\IH^\w}\,\big(\snd\,(\snd\,(\ola{(S^\w)_0}\,p\,t^\w))\big)\,\big(S_\map\,(\elim\,S^*\,P\,f)\,(\fst\,(\ola{(S^\w)_0}\,p\,t^\w))\big)
\end{alignat*}
And define
\begin{alignat*}{4}
  &\floord{f^\w} : \{t\}(t^\w : \PSbe_0\,\IR^\w\,\El^\w\,t) \to \PSbe_\IH\,\floord{P^\w}\,t^\w \to \floord{P^\w}\,(\intro\,t^\w)\\
  &\floord{f^\w}\,t^\w\,\ih^\w := f^\w\,\big(\snd\,(\snd\,(\ola{(S^\w)_0}\,\here\,t^\w))\big)\,\big(\ola{(S^{*\w})_{\IH}}\,\,\here\,\ih^\w\big).
\end{alignat*}
Hence, elimination is interpreted as follows:
\[ \elim^\w\,t^\w := \elim_\IIR\,\PSbe\,\floord{P^\w}\,\floord{f^\w}\,t^\w \]
\end{definition}

\begin{definition}[Interpretation of $\elimbeta$]
The goal is the following:
\[ \elimbeta^\w : \{t\}(t^\w : (\Ssw)_{0^\w}\,t) \to \elim^\w\,(\intro^\w\,t^\w) = f^\w\,t^\w\,((\Ssw)_{\map^\w}\,\elim^\w\,t^\w) \]
%% \begin{alignat*}{4}
%%   & \floord{f^\w}\,&&\Big(\ora{(\Ssw)_0}\,\,\here\,(t,\,\refl,\,t^\w)\Big)\,\Big(\PSbe_\map\,\floord{P^\w}\,\elim^\w\,(\ora{(\Ssw)_0}\,\,\here\,(t,\,\refl,\,t^\w)\Big)
%% \end{alignat*}
The left hand side computes to the following:
\begin{alignat*}{4}
  &f^\w\,&&\Big(\snd\,\big(\snd\,\big(\ola{(S^{*\w})_0}\,\here\,(\ora{(\Ssw)_0}\,\,\here\,(t,\,\refl,\,t^\w))\big)\big)\Big)\\
  &      &&\Big(\ola{(S^{*\w})_{\IH}}\,\,\here\,\Big(\PSbe_\map\,\floord{P^\w}\,\elim^\w\,(\ora{(\Ssw)_0}\,\,\here\,(t,\,\refl,\,t^\w))\Big)\Big)
\end{alignat*}
The first argument to $\floord{f^\w}$ simplifies to $t^\w$ by canceling the $\ola{(S^{*\w})_0}$
isomorphism. For the second argument of $\floord{f^\w}$, like in Section \ref{sec:iir-construction-elimination}, we show that
$\PSbe_\map$ appropriately commutes with the $\ola{(S^{*\w})_0)}$ isomorphism, by induction on $S^\w$.

\emph{Remark.} In the Agda formalization of $\beta$-rules, we use uniqueness of identity proofs
(UIP) instead of trying to shuffle transports by homotopical reasoning. We do this mainly because it
is easier. However, we conjecture that it is possible to get rid of UIP. In that case, the above
definitions could be reformulated as part of a \emph{syntactic parametricity translation} that maps
from the object theory to itself. Also, we might imagine a binary parametricity variant of our
interpretation \cite{bernardy2010parametricity}. In other words, we conjecture that our IR interpretation can serve as a
blueprint for other kinds of parametric interpretations of IR types.
\end{definition}

\begin{definition}[Interpretation of object-theoretic IR rules]
At this point we have semantics for IR rules that only mention closed syntactic terms. The final
step is to generalize them to arbitrary contexts, thereby interpreting object-theoretic IR rules.

In the object theory we have $\IIR : \Tm\,\Gamma\,(\{O : \U_j\} \to \Sig_i\,O \to \U_i)$, hence by the specification
of $\blank^\w$ in Section \ref{sec:canonicity-model}, we need
\begin{alignat*}{4}
  & \IIR^\w &&:\,\,&& \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma)\{O : \Tm\,\U_j\}(O^\w : \Tm\,O \to \Set_j)\\
  &         &&     && \{S : \Tm\,(\Sig_i\,O)\}(S^\w : \Sig^\w\,S) \to \Tm\,(\IIR\,S) \to \Set_i
\end{alignat*}
In this section we defined a different $\IR^\w$ with the following type (including all parameters):
\begin{alignat*}{4}
  & \IIR^\w : \{O : \Tm\,\U_j\}(O^\w : \Tm\,O \to \Set_j)\{S : \Tm\,(\Sig_i\,O)\}(S^\w : \Sig^\w\,S) \to \Tm\,(\IIR\,S) \to \Set_i
\end{alignat*}
Hence, the contextual definition is just a constant function, i.e.\ $\IIR^\w\,\{\gamma\}\,\gamma^\w
:= \IIR^\w$.

We also need to interpret stability under substitution. In the object theory we have
$(\IIR\,\{\Gamma\})[\sigma] = \IIR\,\{\Delta\}$ when $\sigma : \Sub\,\Delta\,\Gamma$. Hence, we need
to show $((\IIR\,\{\Gamma\})[\sigma])^\w = (\IIR\,\{\Delta\})^\w$ here. Computing this type further
and applying function extensionality, we have the goal $\IIR^\w\,(\sigma^\w\,\gamma^\w) =
\IIR^\w\,\gamma^\w$, which is by definition $\IIR^\w = \IIR^\w$ for the non-contextual $\IIR^\w$
definition, and thus holds trivially. Every other IR rule and substitution rule is interpreted
similarly, as constant functions and trivial equations. Also, $\Elintro$, and $\elimbeta$ are
dispatched by direct appeal to the equations that we have already proved.

For an example, we look at $\Elintro$. In the object theory, we have $\Elintro : \El\,(\intro\,x) =
S_1\,x$, so we need to show $(\El\,(\intro\,x))^\w\,\gamma^\w = (S_1\,x)^\w\,\gamma^\w$. Using the
definition of $\blank^\w$ of functions and the definitions of $\El^\w\,\gamma^\w$,
$\intro^\w\,\gamma^\w$ and $(S_1)^\w\,\gamma^\w$, this is computed to
\[ (\El^\w\,(\intro^\w\,(x^\w\,\gamma^\w))) = (S^\w\,\gamma^\w)_{1^\w}\,(x^\w\,\gamma^\w) \]
which is an instance of Definition \ref{sec:canonicity-elintro}. We omit describing the contextualization of
the other rules. This concludes the canonicity interpretation of the object theory.

\end{definition}

\begin{example}
Now that we have fully defined the $\blank^\w$ functions acting on contexts, types, subtitutions and
terms, we can look at an example for a canonicity statement. Recall $S$ from Example \ref{ex:code-signature} and
also the corresponding IIR predicate from Example \ref{ex:code-canonicity-signature}. Assuming $t :
\Tm\,\emptycon\,(\IR\,S)$, we have
\begin{alignat*}{3}
  &t^\w\,\{\id\}\,\ttt &&: (\IR\,S)^\w\,\ttt\,\,t[\id]\\
  &t^\w\,\{\id\}\,\ttt &&: \IR^\w\,(S^\w\,\ttt)\,t\\
  &t^\w\,\{\id\}\,\ttt &&: \IIR\,(\floord{S^\w\,\ttt}\,\here)\,t.
\end{alignat*}
Now, $\IIR\,(\floord{S^\w\,\ttt}\,\here)\,t$ witnesses that $t$ is either definitionally equal to $\intro\,(\Nat',\,\ttt)$
or to $\intro\,(\Pi',\,A,\,B,\,\ttt)$ for some $A$ and $B$.
\end{example}

\subsection{Mechanization}

\section{Related Work}

\section{Conclusion and Future Work}


\section{TODO}

foo


\begin{itemize}
  \item references
  \item Agda sync: rename wrap to intro, unit type in every univ, naming/notation, postulate a Tm universe for IRCanonicity.
  \item Check paper defs while syncing.
  \item metatheory: Loic, Anton say it looks OK
\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
