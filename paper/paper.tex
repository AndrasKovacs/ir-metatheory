
%% build: latexmk -pdf -pvc paper.tex

\documentclass[acmsmall,screen,review]{acmart}
%% \documentclass[nonacm,acmsmall]{acmart}
%% \documentclass[acmsmall]{acmart}
%% \raggedbottom

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.newcomm  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%% --------------------------------------------------------------------------------

%% \usepackage{xcolor}
%% \usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
%% \usepackage{bm}
%% \usepackage{mathtools}
%% \usepackage{stmaryrd}
%% \usepackage[title]{appendix}

\newcommand{\mit}[1]{{\mathit{#1}}}
\newcommand{\msf}[1]{{\mathsf{#1}}}
\newcommand{\mbf}[1]{{\mathbf{#1}}}
\newcommand{\mbb}[1]{\mathbb{#1}}

\newcommand{\push}{\mathsf{push}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\data}{\mbf{data}}
\newcommand{\U}{\msf{U}}
\newcommand{\Set}{\msf{Set}}
\newcommand{\where}{\mbf{where}}
\newcommand{\Nat}{\msf{Nat}}
\newcommand{\zero}{\msf{zero}}
\newcommand{\suc}{\msf{suc}}
\newcommand{\Nil}{\msf{Nil}}
\newcommand{\Cons}{\msf{Cons}}
\newcommand{\List}{\msf{List}}
\newcommand{\El}{\msf{El}}
\newcommand{\Lift}{\msf{Lift}}
\newcommand{\lup}{\uparrow}
\newcommand{\ldown}{\downarrow}
\newcommand{\Sig}{\msf{Sig}}
\newcommand{\Code}{\msf{Code}}
\newcommand{\Tag}{\msf{Tag}}
\newcommand{\case}{\mbf{case}}
\newcommand{\of}{\mbf{of}}
\newcommand{\ttt}{\msf{tt}}
\newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}
\newcommand{\ir}{{ir}}
\newcommand{\el}{{el}}
\newcommand{\ix}{{ix}}
\newcommand{\ixs}{{ixs}}
\newcommand{\IR}{\msf{IR}}
\newcommand{\ih}{{ih}}
\newcommand{\intro}{\msf{intro}}
\newcommand{\IH}{\msf{IH}}
\newcommand{\map}{\msf{map}}
\newcommand{\elim}{\msf{elim}}
\newcommand{\inj}{\msf{inj}}
\newcommand{\tr}{\msf{tr}}
\newcommand{\fst}{\msf{fst}}
\newcommand{\snd}{\msf{snd}}
\newcommand{\IIR}{\msf{IIR}}
\newcommand{\Sigr}[1]{\lfloor #1 \rfloor}
\newcommand{\floord}[1]{\lfloor #1 \rfloor}
\newcommand{\ora}[1]{\overrightarrow{#1}}
\newcommand{\ola}[1]{\overleftarrow{#1}}
\newcommand{\ap}{\msf{ap}}
\newcommand{\Bool}{\msf{Bool}}
\newcommand{\Level}{\msf{Level}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\id}{\msf{id}}
\newcommand{\Vect}{\msf{Vec}}

\newcommand{\Con}{\msf{Con}}
\newcommand{\Sub}{\msf{Sub}}
\newcommand{\Ty}{\msf{Ty}}
\newcommand{\Tm}{\msf{Tm}}
\newcommand{\ext}{\triangleright}
\newcommand{\w}{\circ}
\newcommand{\lam}{\msf{lam}}
\newcommand{\app}{\msf{app}}
\newcommand{\bapp}{\$}
\newcommand{\proj}{\msf{proj}}
\newcommand{\exfalso}{\msf{exfalso}}
\newcommand{\true}{\msf{true}}
\newcommand{\false}{\msf{false}}
\newcommand{\BoolElim}{\msf{BoolElim}}
\newcommand{\fun}{\Rightarrow}
\newcommand{\SigElim}{\msf{SigElim}}
\newcommand{\Id}{\msf{Id}}
\newcommand{\refl}{\msf{refl}}
\newcommand{\J}{\msf{J}}
\newcommand{\G}{\mbb{G}}
\newcommand{\Path}{\msf{Path}}
\newcommand{\here}{\msf{here}}
\newcommand{\Ssw}{S^{*\w}}
\newcommand{\nil}{\msf{nil}}
\newcommand{\cons}{\msf{cons}}

\newcommand{\insigma}{\msf{in}\!\!-\!\!\sigma}
\newcommand{\indelta}{\msf{in}\!\!-\!\!\delta}

\newcommand{\Sb}{S^{*\circ}}
\newcommand{\Sbe}{{\floord{S^{*\circ}}\,\here}}
\newcommand{\PSbe}{{(\floord{S^{*\circ}}\,\here)}}
\newcommand{\Elintro}{\msf{El\!\!-\!\!intro}}
\newcommand{\elimbeta}{\elim\!-\!\!\beta}

\newcommand{\E}{\mbb{E}}
\newcommand{\F}{\mbb{F}}

%% --------------------------------------------------------------------------------

%%
%% end of the preamble, start of the body of the document source.
%% \hypersetup{draft}
\begin{document}


\title{Canonicity for Indexed Inductive-Recursive Types}

\author{András Kovács}
\orcid{0000-0002-6375-9781}
\affiliation{%
  \institution{University of Gothenburg \& Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}
\email{andrask@chalmers.se}


\begin{abstract}
We prove canonicity for a Martin-Löf type theory with a countable universe hierarchy where each
universe supports indexed inductive-recursive (IIR) types. We proceed in two steps. First, we
construct IIR types from inductive-recursive (IR) types and other basic type formers, in order to
simplify the subsequent canonicity proof. The constructed IIR types support the same definitional
computation rules that are available in Agda's native IIR implementation. Second, we give a
canonicity proof for IR types, building on the established method of gluing along the global
sections functor. The main idea is to encode the canonicity predicate for each IR type using a
metatheoretic IIR type.
\end{abstract}

%% \begin{CCSXML}
%% \end{CCSXML}
%% \ccsdesc[500]{Theory of computation~Type theory}
%% \ccsdesc[500]{Software and its engineering~Source code generation}
%% \keywords{}

\maketitle

\section{Introduction}\label{sec:introduction}

Induction-recursion (IR) allows us to mutually define an inductive type and a function that acts on
elements of the type. A common application of IR is to define custom universes or universe
hierarchies inside a type theory. For an example, in the proof assistant Agda, we can use IR to
define a universe that is closed under our choice of type formers:
\begin{alignat*}{3}
  & \mbf{mutual} \\
  & \quad\data\,\Code : \Set_0\,\where \\
  & \quad\quad \Nat' : \Code\\
  & \quad\quad \Pi' \hspace{0.8em} : (A : \Code) \to (\El\,A \to \Code) \to \Code
  & \\
  & \\
  & \quad\El : \Code \to \Set_0 \\
  & \quad\El\,\Nat'\hspace{1.5em}  = \Nat \\
  & \quad\El\,(\Pi'\,A\,B) = (a : \El\,A) \to \El\,(B\,a)
\end{alignat*}
Here, $\Code$ is a type of codes of types which behaves as a custom Tarski-style universe. This
universe, unlike the ambient universe $\Set_0$, supports an induction principle and can be used to
define type-generic functions. Indexed induction-recursion (IIR) additionally allows indexing the
inductive type over some type, which lets us define inductive-recursive predicates
\cite{DBLP:journals/jlp/DybjerS06}.

Indexed induction-recursion was first used in an implicit and informal way in Martin-Löf's proof of
normalization for his intuitionistic type theory \cite{martin1975intuitionistic}. Later, his
specification of a Tarski-style universe was a more clear-cut example of induction-recursion
\cite{martinlof84sambin}. The general specification of IR was formalized by
\citet{DBLP:journals/jsyml/Dybjer00} and
\citet{dybjer99finite,DBLP:journals/jlp/DybjerS06,DBLP:journals/apal/DybjerS03}, who also developed
set-theoretic, realizability and categorical semantics.

An important application of (I)IR has been to develop semantics for object theories that support
universe hierarchies. It has been used in normalization proofs
\cite{DBLP:journals/pacmpl/0001OV18,DBLP:journals/pacmpl/PujetT23,DBLP:journals/pacmpl/AbelDE23}, in
modeling first-class universe levels \cite{first-class-univ} and proving canonicity for them
\cite{DBLP:journals/corr/abs-2502-20485}. Other applications are in characterizing domains of
partial functions \cite{DBLP:conf/tphol/BoveC01} and in generic programming over type descriptions
\cite{DBLP:journals/njc/BenkeDJ03,diehl2017fully}.

IIR has been supported in Agda 2 since the early days of the system \cite{DBLP:conf/tphol/BoveDN09},
and it is also available in Idris 1 \cite{DBLP:journals/jfp/Brady13} and Idris 2
\cite{DBLP:conf/ecoop/Brady21}. In these systems, IIR has been implemented in the ``obvious'' way,
supporting closed program execution in compiler backends and normalization during type checking, but
without any formalization in the literature.

Our \textbf{main contribution} is to \emph{show canonicity for a Martin-Löf type theory that
supports a countable universe hierarchy, where each universe supports indexed inductive-recursive
types}. Canonicity means that every closed term is definitionally equal to a canonical term. The
meaning of canonicity for a term depends on its type. For inductive types, a canonical term is given
by a constructor whose fields are also canonical (inductively). Canonical functions map canonical
inputs to canonical outputs, and canonical terms of $\Sigma$-types have canonical projections. On a
high level, canonicity for a type theory justifies evaluation of closed terms. The outline of our
development is the following.

\begin{itemize}
\item In Section \ref{sec:specification} we specify what it means to support IR and IIR, using
  Dybjer and Setzer's rules with minor modifications \cite{DBLP:journals/jlp/DybjerS06,DBLP:journals/apal/DybjerS03}. We use
  first-class signatures, meaning that descriptions of (I)IR types are given as ordinary inductive
  types internally.
\item In Section \ref{sec:iir-construction} we construct IIR types from IR types and other basic
  type formers. This allows us to only consider IR types in the subsequent canonicity proof, which
  is a significant simplification. In the construction of IIR types, we lose some definitional
  equalities when signatures are neutral, but we still get the same computation rules that are
  available for Agda and Idris' IIR types. We formalize the construction in Agda.
\item In Section \ref{sec:canonicity}, we give a proof-relevant logical predicate interpretation of
  the type theory, from which canonicity follows. Our method is based on a type-theoretic flavor of
  gluing along the global sections functor \cite{gluing,coquand2018canonicity}. The main challenge
  here is to give a logical predicate interpretation of IR types. We do this by using IIR in the
  metatheory: from each object-theoretic signature we compute a metatheoretic IIR signature which
  encodes the canonicity predicate for the corresponding IR type.  We formalize the predicate
  interpretation of IR types in Agda, using a shallow embedding of the syntax of the object
  theory. Hence, there is a gap between the Agda version and the fully formal construction, but we
  argue that it is a modest gap.
\end{itemize}

The Agda formalization is available in \cite{TODO}.

\section{Specification for (I)IR Types}\label{sec:specification}

In this section we describe the object type theory, focusing on the specification of IR and IIR
types. We shall mostly work with internal definitions in an Agda-like syntax. In Section
\ref{sec:object-theory} we will give a more rigorous specification.

\subsection{Basic Type Formers}\label{sec:basic-type-formers}
We have a countable hierarchy of Russell-style universes, written as $\U_i$, where $i$ is an
external natural number. We have $\U_i : \U_{i + 1}$.

We have $\Pi$-types as $(x : A) \to B\,x$, which has type $\U_{\max(i,\,j)}$ when $A : \U_i$ and $B
: A \to \U_j$. We use Agda-style implicit function types for convenience, as $\{x : A\} \to B\,x$,
to mark that a function argument should be inferred from context. We sometimes omit the type of an
implicit argument and write $\{x\} \to B\,x$.  Also, we may omit the implicit quantification
entirely: if there are variables in a type which are not quantified anywhere, they are understood
to be implicitly quantified with a $\Pi$-type.

$\Sigma$-types: for $A : \U_i$ and $B : A \to \U_j$, we have $((x : A) \times B\,x) :
\U_{\max(i,\,j)}$.  We write $\blank,\blank$ for pairing and $\fst$ and $\snd$ for projections. We
have the unit type $\top : \U_i$ with the definitionally unique inhabitant $\ttt$. We have $\Bool : \U_0$ for
Booleans. We have intensional identity types, as $t = u : \U_i$ for $t : A : \U_i$ and $u : A : \U_i$. We define (by
identity elimination) a transport operation $\tr : \{A : \U_i\}(P : A \to \U_j)\{x\,y : A\} \to x =
y \to P\,x \to P\,y$. We derive some other type formers below.
\begin{itemize}
  \item We define a universe lifting operation $\Lift : \U_i \to \U_{\max(i,\,j)}$ such that
    $\Lift\,A$ is definitionally isomorphic to $A$, by defining $\Lift\,A$ to be $A \times \top_j$. We
    write the wrapping operation as $\lup\,:\,A \to \Lift\,A$ with inverse $\ldown$.
  \item We define the empty type $\bot : \U_0$ as $\true = \false$.
  \item We can define finite sum types from $\bot$, $\Sigma$ and $\Bool$. These are useful
    as ``constructor tags'' in inductive types.
\end{itemize}
We write $\blank\!\!\equiv\!\!\blank$ for definitional equality and write definitions with $:\equiv$.

\subsection{IR Types}\label{sec:ir-specification}
The object theory additionally supports inductive-recursive types. On a high level, the
specification consists of the following.
\begin{enumerate}
\item A type of signatures. Each signature describes an IR type. Also, we internally define some
  functions on signatures which are required in the specification of other rules.
\item Rules for type formation, term formation and the recursive function, with a computation rule
  for the recursive function.
\item The induction principle with a $\beta$-rule.
\end{enumerate}

Our specification is identical to what is termed $\mbf{\IR_{\msf{elim}}}$ in
\cite{DBLP:journals/apal/DybjerS03}, except for changes of notation and a difference in the universe
setup. We have countable universe levels, while Dybjer and Setzer use a logical framework
presentation with three universes.\footnote{In that setup, ``$\msf{set}$'' contains the
inductively specified type, ``$\msf{stype}$'' contains the non-inductive constructor arguments and
``$\msf{type}$'' contains the recursive output type and the type of signatures.}

\subsubsection{IR signatures}\label{sec:ir-signatures}
Signatures are parameterized by the following data:
\begin{itemize}
\item The level $i$ is the size of the IR type that is being specified.
\item The level $j$ is the size of the recursive output type.
\item $O : \U_j$ is the output type.
\end{itemize}
IR signatures are specified by the following inductive type. We only mark $i$ and $O$ as parameters to $\Sig$,
since $j$ is inferable from $O$.
\begin{alignat*}{4}
  &\data\, \Sig_i\,O : \U_{\max(i+1,\,j)}\,\where\\
  &\quad \iota\hspace{0.25em}  : O \to \Sig_i\,O \\
  &\quad \sigma               : (A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O \\
  &\quad \delta\hspace{0.1em} : (A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O
\end{alignat*}
Formally, we can view $\Sig$ in two ways: it is either a primitive inductive family \cite{inductivefamilies} or
it is defined as a $\msf{W}$-type \cite{whynotw}. The choice is not crucial, but in this paper
we treat $\Sig$ as a native inductive type, in order to avoid encoding overheads.

\begin{example}\label{ex:code-signature}
We reproduce the Agda example from Section \ref{sec:introduction}. First, we need an enumeration
type to represent the constructor labels of $\Code$. We assume this as $\Tag : \U_0$ with
constructors $\Nat'$ and $\Pi'$. We also assume $\Nat : \U_0$ for natural numbers and a
right-associative $\blank\!\$\!\blank$ operator for function application.
\begin{alignat*}{4}
  & S : \Sig_0\,\U_0\\
  & S :\equiv \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nat' \to \iota\,\Nat \\
  & \quad \Pi'\hspace{0.85em} \to \delta\,\top\,\$\,\lambda\,{ElA}.\, \delta\,({ElA}\,\ttt)\,\$\,\lambda\,{ElB}.\,
      \iota\, ((a : {ElA}\,\ttt) \to {ElB}\,a)
\end{alignat*}
First, we introduce a choice between two constructors by $\sigma\,\Tag$. In the $\Nat'$ branch, we
specify that the recursive function maps the constructor to $\Nat$. In the $\Pi'$ branch, we first
introduce a single inductive constructor field by $\delta\,\top$, where $\top$ sets the number of
introduced fields. The naming of the freshly bound variable ${ElA}$ is meant to suggest that it
represents the recursive function's output for the inductive field. It has type $\top \to \U_0$.
Next, we introduce $({ElA}\,\ttt)$-many inductive fields, and bind ${ElB} : {ElA}\,\ttt \to \U_0$ to
represent the corresponding recursive output. Finally, $\iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)$
specifies the output of the recursive function for the $\Pi'$ constructor.
\end{example}

\subsubsection{Type and term formation}\label{sec:ir-type-and-term-formation}

First, assuming $O : \U_j$, a signature $S : \Sig_i\,O$ can be interpreted as a function from $(A : \U_i) \times (A \to O)$ to
$(A : \U_i) \times (A \to O)$. This can be extended to an endofunctor on the slice category
$\U_i/O$, but in the following we only need the action on objects. For the sake of readability, we
split this action to two functions. $\E$ yields the ``total type'' part of the interpretation of a
signature, and $\F$ yields the morphism part, i.e.\ a function into $O$.
\begin{alignat*}{3}
  &\rlap{$\E : \{i\,j : \mbb{N}\}\{O : \U_j\} \to \Sig_i\,O \to (\ir : \U_i) \to (\ir \to O) \to \U_i$} \\
  &\E\,(\iota\,o)    \,&&\ir\,\el && \hspace{-0.7em}:\equiv \top\\
  &\E\,(\sigma\,A\,S)\,&&\ir\,\el && \hspace{-0.7em}:\equiv (a : A) \times \E\,(S\,a)\,\ir\,\el\\
  &\E\,(\delta\,A\,S)\,&&\ir\,\el && \hspace{-0.7em}:\equiv (f : A \to \ir) \times \E\,(S\,(\el \circ f))\,\ir\,\el\\
  & && &&\\
  &\rlap{$\F : \{i\,j : \mbb{N}\}\{O : \U_j\}\{S : \Sig_i\,O\}\{\ir\}\{\el\} \to \E\,S\,\ir\,\el \to O$} \\
  &\F\,\{\iota\,o\}    \,&&x       && :\equiv o\\
  &\F\,\{\sigma\,A\,S\}\,&&(a,\,x) && :\equiv \F\,\{S\,a\}\,x\\
  &\F\,\{\delta\,A\,S\}\,&&(f,\,x) && :\equiv \F\,\{S\,(\el \circ f)\}\,x
\end{alignat*}
Above we use an Agda-like notation for specifying the implicit $S$ argument to $\F$. Here, we marked
the quantification of all implicit arguments to $\E$ and $\F$, but we shall omit more of them from
now on. As to the arguments $i$ and $j$, the object theory does not support universe
polymorphism, so this quantification formally happens in the metatheory. The introduction
rules are the following.
\begin{alignat*}{3}
  &\IR                && : \Sig_i\,O \to \U_i\\
  &\El                && : \IR\,S \to O\\
  &\intro             && : \E\,S\,(\IR\,S)\,\El \to \IR\,S\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv \F\,x
\end{alignat*}
Note that the rule $\msf{El\!\!-\!\!intro}$ specifies a definitional equality. Also, these rules are
not internal definitions but part of the specification of the object theory. Hence, they are also
assumed to be stable under object-theoretic substitution. On a high level, the introduction rules
express the existence of an $S$-algebra where we view $S$ as an endofunctor on $\U_i/O$.

\begin{example}\label{ex:code-constructors} We look at how $\Code$, $\Nat'$, $\Pi'$ and $\El$ from the Agda
example in Section \ref{sec:introduction} are obtained from the general rules for IR.
\begin{itemize}
\item We take the signature $S$ from Example \ref{ex:code-signature}.
\item $\Code$ is defined as $\IR\,S$, and we immediately have $\El : \Code \to \U_0$.
\item We have $\intro : \E\,S\,\Code\,\El \to \Code$. If we try to compute $\E\,S\,\Code\,\El$, we
  get $(t : \Tag) \times \E\,(S'\,t)\,\Code\,\El$, where $S'$ is the function
  $\lambda\,t.\,\case\,t\,\of\,...$ inside $S$. Hence, the computation of $\E$ gets stuck on the
  neutral $t$. However, as soon as we specify the tag, we can fully compute the types of the $\Code$
  constructors. We define them as $\msf{mk}\Nat'$ and $\msf{mk}\Pi'$, in order to disambiguate them
  from their tags.
  \begin{alignat*}{3}
    & \msf{mk}\Nat' : \Code                         && \msf{mk}\Pi' : (A : \Code) \to (\El\,A \to \Code) \to \Code\\
    & \msf{mk}\Nat' :\equiv \intro\,(\Nat',\,\ttt)\quad  && \msf{mk}\Pi'\,A\,B :\equiv \intro\,(\Pi',(\lambda\,\_.\,A),\,B,\,\ttt)
  \end{alignat*}
  The constant function $(\lambda\,\_.\,A)$ is required because we always specify inductive
  branching with a function.
\item Let us look at $\El$. We have the expected definitional equalities:
  \begin{alignat*}{3}
    & \El\,\msf{mk}\Nat' \equiv \Nat \hspace{2em} \El\,(\msf{mk}\Pi'\,A\,B) \equiv ((a : \El\,A) \to \El\,(B\,a))
  \end{alignat*}
  These are obtained from $\msf{El\!\!-\!\!intro}$ and the definition of $\F$. Unfolding the $\msf{mk}\Nat'$ case, we have
  \[ \El\,\msf{mk}\Nat' \equiv \El\,(\intro\,(\Nat',\,\ttt)) \equiv \F\,\{S\}\,(\Nat',\,\ttt) \equiv \F\,\{\iota\,\Nat\}\,\ttt \equiv \Nat. \]
  For $\msf{mk}\Pi'$, we have the following:
  \begin{alignat*}{3}
    &            &&\El\,(\msf{mk}\Pi'\,A\,B)\\
    & \equiv\,\, &&\El\,(\intro\,(\Pi',(\lambda\,\_.\,A),\,B,\,\ttt))\\
    & \equiv\,\, &&\F\,\{S\}\,(\Pi',(\lambda\,\_.\,A),\,B,\,\ttt)\\
    & \equiv\,\, &&\F\,\{\delta\,\top\,\$\,\lambda\,{ElA}.\, \delta\,({ElA}\,\ttt)\,\$\,\lambda\,{ElB}.\,\iota\, ((a : {ElA}\,\ttt) \to {ElB}\,a)\}\,((\lambda\,\_.\,A),\,B,\,\ttt)\\
    & \equiv\,\, &&\F\,\{\delta\,(\El\,A)\,\$\,\lambda\,{ElB}.\,\iota\, ((a : \El\,A) \to {ElB}\,a)\}\,(B,\,\ttt)\\
    & \equiv\,\, &&\F\,\{\iota\,((a : \El\,A) \to \El\,(B\,a))\}\,\ttt\\
    & \equiv\,\, && (a : \El\,A) \to \El\,(B\,a)
  \end{alignat*}
\end{itemize}
\end{example}

\subsubsection{Elimination}\label{sec:ir-elimination}

We assume a universe level $k$ for the size of the type into which we eliminate. We define two
additional functions on signatures:
\begin{alignat*}{3}
  &\rlap{$\IH : \{S : \Sig_i\,O\}(P : \ir \to \U_k) \to \E\,S\,\ir\,\el \to \U_{\max(i,\,k)}$} \\
  &\IH\,\{\iota\,o\}    \,&&P\,x       &&:\equiv \top \\
  &\IH\,\{\sigma\,A\,S\}\,&&P\,(a,\,x) &&:\equiv \IH\,\{S\,a\}\,P\,x\\
  &\IH\,\{\delta\,A\,S\}\,&&P\,(f,\,x) &&:\equiv ((a : A) \to P\,(f\,a)) \times \IH\,\{S\,(\el \circ f)\}\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-4.8em}\rlap{$\map : \{S : \Sig_i\,O\} \to ((x : \ir) \to P\,x) \to (x : \E\,S\,\ir\,\el) \to \IH\,P\,x$} \\
  &\hspace{-4.8em}\map\,\{\iota\,o\}    \,&&g\,x       &&:\equiv\,\ttt \\
  &\hspace{-4.8em}\map\,\{\sigma\,A\,S\}\,&&g\,(a,\,x) &&:\equiv \map\,\{S\,a\}\,g\,x\\
  &\hspace{-4.8em}\map\,\{\delta\,A\,S\}\,&&g\,(f,\,x) &&:\equiv (g \circ f,\,\map\,\{S\,(\el \circ f)\}\,g\,x)
\end{alignat*}
$\IH$ stands for ``induction hypothesis'': it specifies having a witness of a predicate $P$ for
each inductive field in a value of $\E\,S\,\ir\,\el$. $\map$ maps over $\E\,S\,\ir\,\el$, applying the
section $g : (x : \ir) \to P\,x$ to each inductive field. Elimination is specified as follows.
\begin{alignat*}{3}
  &\elim           &&: (P : \IR\,S \to \U_k) \to ((x : \E\,S\,(\IR\,S)\,\El) \to \IH\,P\,x \to P\,(\intro\,x)) \to (x : \IR\,S) \to P\,x \\
  &\elim\!\!-\!\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(\map\,(\elim\,P\,f)\,x)
\end{alignat*}
If we have function extensionality, this specification of elimination can be shown to be equivalent
to the initiality of $(\IR\,S,\,\El)$ as an $S$-algebra \cite[Section~4.4]{DBLP:journals/apal/DybjerS03}.

\subsection{IIR Types}\label{sec:iir}

For IIR types we follow the ``general IIR''\footnote{As opposed to the ``restricted'' specification,
where the index of every constructor is determined by the first field.} specification by
\citet{DBLP:journals/jlp/DybjerS06}, again differing only in our use of countable universe levels.

\subsubsection{Signatures}\label{sec:iir-signatures} We assume levels $i$, $j$, $k$, an indexing type $I : \U_k$ and a type family
for the recursive output as $O : I \to \U_j$. Signatures are as follows.
\begin{alignat*}{4}
  &\data\, \Sig_i\,I\,O : \U_{\max(i+1,\,j,\,k)}\,\where\\
  &\quad \iota\hspace{0.25em}  : (\ix : I) \to O\,\ix \to \Sig_i\,I\,O \\
  &\quad \sigma                : (A : \U_i) \to (A \to \Sig_i\,I\,O) \to \Sig_i\,I\,O \\
  &\quad \delta\hspace{0.1em}  : (A : \U_i)(\ixs : A \to I) \to (((a : A) \to O\,(\ixs\,a)) \to \Sig_i\,I\,O) \to \Sig_i\,I\,O
\end{alignat*}
The most important addition is the field $\ixs : A \to I$ in $\delta$: it stands for ``indexes'' and
it specifies the index of each inductive subtree.

\begin{example}\label{ex:vector} We reproduce length-indexed vectors as an IIR type. We assume $A : \U_0$ for a type of elements in the vector,
and a type $\Tag : \U_0$ with inhabitants $\nil'$ and $\cons'$.
\begin{alignat*}{4}
  & S : \Sig_0\,\Nat\,(\lambda\,\_.\,\top)\\
  & S :\equiv \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \nil'\hspace{0.85em} \to \iota\,\zero\,\ttt \\
  & \quad \cons'\to \sigma\,\Nat\,\$\,\lambda\,n.\,\sigma\,A\,\$\,\lambda\,\_.\,\delta\,\top\,(\lambda\,\_.\,n)\,\$\,\lambda\,\_.\,\iota\,(\suc\,n)\,\ttt
\end{alignat*}
We set $O$ to be constantly $\top$ because vectors do not have an associated recursive function. In
the $\Nil'$ case, we simply set the constructor index to $\zero$. In the $\Cons'$ case, we introduce
a non-inductive argument, binding $n$ for the length of the tail of the vector. Then, when we
introduce the inductive argument using $\delta$, we use $(\lambda\,\_.\,n)$ to specify that index of
the argument is indeed $n$. Finally, the length of the $\Cons'$ constructor is $\suc\,n$.

%% For
%% illustration, the same specification could be written as the following inductive family in Agda:
%% \begin{alignat*}{3}
%%   &\data\,\Vect\,(A : \Set_0) : \Nat \to \Set_0\,\where \\
%%   &\quad \nil  \hspace{0.75em}: \Vect\,A\,\zero\\
%%   &\quad \cons : (n : \Nat) \to A \to (\top \to \Vect\,A\,n) \to \Vect\,A\,(\suc\,n)
%% \end{alignat*}

\end{example}

\subsubsection{Type and term formation}\label{sec:iir-type-and-term-formation}
$\E$ and $\F$ are similar to before:
\begin{alignat*}{4}
  &\hspace{-2em}\rlap{$\E : \Sig_i\,I\,O \to (\ir : I \to \U_{\max(i,\,k)}) \to (\{\ix : I\} \to \ir\,\ix \to O\,\ix) \to I \to \U_{\max(i,\,k)}$} \\
  &\hspace{-2em}\E\,(\iota\,\ix'\,o)     \,&&\hspace{-0.4em}\ir\,\el\,\ix &&\hspace{-0.2em} :\equiv \Lift\,(\ix' = \ix)\\
  &\hspace{-2em}\E\,(\sigma\,A\,S)     \,&&  \hspace{-0.4em}\ir\,\el\,\ix &&\hspace{-0.2em} :\equiv (a : A) \times \E\,(S\,a)\,\ir\,\el\,\ix\\
  &\hspace{-2em}\E\,(\delta\,A\,\ixs\,S)\,&&  \hspace{-0.4em}\ir\,\el\,\ix &&\hspace{-0.2em} :\equiv (f : (a : A) \to \ir\,(\ixs\,a)) \times \E\,(S\,(\el \circ f))\,\ir\,\el\,\ix\\
  &\hspace{-2em} && &&\\
  &\hspace{-2em}\rlap{$\F : \{S : \Sig_i\,I\,O\} \to \E\,S\,\ir\,\el\,\ix \to O\,\ix$} \\
  &\hspace{-2em}\F\,\{\iota\,\ix'\,o      \}\,&&\hspace{-0.1em}(\lup x) && \hspace{-0.2em}:\equiv \tr\,O\,x\,o\\
  &\hspace{-2em}\F\,\{\sigma\,A\,S      \}\,&&\hspace{-0.1em}(a,\,x)  && \hspace{-0.2em}:\equiv \F\,\{S\,a\}\,x\\
  &\hspace{-2em}\F\,\{\delta\,A\,\ixs\,S)\}\,&&\hspace{-0.1em}(f,\,x)  && \hspace{-0.2em}:\equiv \F\,\{S\,(\el \circ f)\}\,x
\end{alignat*}
Note the transport in $\tr\,O\,x\,o$: this is necessary, since $o$ has type $O\,\ix'$ while the
required type is $O\,\ix$. Also note the pattern matching notation in $(\lup\,x)$: this makes sense
since $\lup$ is a definitional isomorphism and we could unfold the pattern to $(x,\,\ttt)$.  The
type and term formation rules are the following.
\begin{alignat*}{4}
  &\IIR               && : \Sig_i\,I\,O \to I \to \U_{\max(i,\,k)}\\
  &\El                && : \IIR\,S\,\ix \to O\,\ix\\
  &\intro             && : \E\,S\,(\IIR\,S)\,\El\,\ix \to \IIR\,S\,\ix\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv \F\,x
\end{alignat*}

\begin{example}\label{ex:vector-constructors} Let us obtain Agda-style $\Vect$ constructors from the IIR rules. We take $S$ from Example \ref{ex:vector}. We define $\Vect\,A\,n : \U_0$ to be $\IIR\,S\,n$, where we appropriately instantiate $A$ in $S$. The derived constructors are the following.
  \begin{alignat*}{3}
    &\nil : \Vect\,A\,\zero                                && \cons : (n : \Nat) \to A \to \Vect\,A\,n \to \Vect\,A\,(\suc\,n)\\
    &\nil :\equiv \intro\,(\nil',\,(\lup\refl))\quad\quad  && \cons\,n\,a\,\mit{as} :\equiv \intro\,(\cons',\,n,\,a,\,(\lambda\,\_.\,\mit{as}),\,(\lup\refl))
  \end{alignat*}
  In $\nil$, the type of $(\lup\refl)$ is $\zero = \zero$, and in $\cons$ its type is $\suc\,n = \suc\,n$. $\El$ and $\Elintro$ are trivial in this case.
\end{example}

\emph{Remark:} this specification uses identity types to fix the correct index for each
constructor. This style has been popularized as ``Fordism'' or ``fording'' by Conor McBride, and it
has been used to represent inductive families, e.g.\ in observational type theories
\cite{towards-ott, DBLP:journals/toplas/PujetLT25} and in the Glasgow Haskell Compiler's
implementation of generalized algebraic datatypes (GADTs) \cite{vytiniotis2011outsidein}.

\subsubsection{Elimination}\label{sec:iir-elimination} $\IH$, $\map$ and elimination are
as follows. We assume a level $l$ for the target type of elimination.
\begin{alignat*}{3}
  &\rlap{$\IH : \{S : \Sig_i\,I\,O\}(P : \{\ix : I\}\to \ir\,\ix \to \U_l) \to \E\,S\,\ir\,\el\,\ix \to \U_{\max(i,\,l)}$} \\
  &\IH\,\{\iota\,\ix\,o      \}\,&&P\,x       &&:\equiv \top \\
  &\IH\,\{\sigma\,A\,S     \}\,&&P\,(a,\,x) &&:\equiv \IH\,\{S\,a\}\,P\,x \\
  &\IH\,\{\delta\,A\,\ixs\,S\}\,&&P\,(f,\,x) &&:\equiv ((a : A) \to P\,(f\,a)) \times \IH\,\{S\,(\el \circ f)\}\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-7em}\rlap{$\map : \{S : \Sig_i\,I\,O\} \to (\{\ix : I\}(x : \ir\,\ix) \to P\,x) \to (x : \E\,S\,\ir\,\el\,\ix) \to \IH\,P\,x$} \\
  &\hspace{-7em}\map\,\{\iota\,\ix\,o\}\,&&g\,x       &&:\equiv\,\ttt \\
  &\hspace{-7em}\map\,\{\sigma\,A\,S\}\,&&g\,(a,\,x) &&:\equiv \map\,\{S\,a\}\,g\,x \\
  &\hspace{-7em}\map\,\{\delta\,A\,\ixs\,S\}\,&&g\,(f,\,x) &&:\equiv (g \circ f,\,\map\,\{S\,(\el \circ f)\}\,g\,x)
\end{alignat*}
\begin{alignat*}{3}
  &\elim           &&: (P : \{\ix : I\}\to \IIR\,S\,\ix \to \U_l) \to (\{\ix : I\}(x : \E\,S\,(\IIR\,S)\,\El\,\ix) \to \IH\,P\,x \to P\,(\intro\,x))\\
  &                && \hspace{0.7em}\to (x : \IIR\,S\,\ix) \to P\,x \\
  &\elim\!\!-\!\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(\map\,(\elim\,P\,f)\,x)
\end{alignat*}
\emph{Notation.} We overload $\Sig$, $\E$, $\F$, $\El$, $\intro$, $\Elintro$, $\IH$, $\map$, $\elim$
and $\elim\!\!-\!\!\beta$ for IR and IIR types, but we will sometimes disambiguate them with a
subscript, e.g.\ as $\intro_\IR$ or $\intro_\IIR$.

\section{Construction of IIR Types}\label{sec:iir-construction}

We proceed to construct IIR types from IR types and other basic type formers. We assume $i$, $j$,
$k$, $I : \U_k$ and $O : I \to \U_j$, and also assume definitions for IIR signatures and the four
operations ($\E$, $\F$, $\IH$, $\map$). The task is to define $\IIR$,
$\El_{\IIR}$, $\elim_{\IIR}$ and $\elim\!-\!\!\beta_{\IIR}$. We use some abbreviations in the following:
\begin{itemize}
\item $\Sig_\IIR$ abbreviates the IIR signature type $\Sig_i\,I\,O$.
\item $\Sig_\IR$ abbreviates the IR signature type $\Sig_{\max(i,\,k)}\,((\ix : I) \times O\,\ix)$.
\end{itemize}
The main idea is to represent IIR signatures as IR signatures together with a
well-indexing predicate on algebras. First, we define an encoding function for signatures:
\begin{alignat*}{4}
  & \rlap{$\Sigr{\blank} : \Sig_\IIR \to \Sig_\IR$}\\
  & \Sigr{\iota\,\ix\,o}      &&:\equiv \hspace{0.5em} &&\iota\,(\ix,\,o)\\
  & \Sigr{\sigma\,A\,S}       &&:\equiv \hspace{0.5em} &&\sigma\,(\Lift\,A)\,(\lambda\,a.\,\Sigr{S\,\ldown\!a})\\
  & \Sigr{\delta\,A\,\ixs\,S} &&:\equiv \hspace{0.5em} &&\delta\,(\Lift\,A)\,\$\,\lambda\,f.\\
  &  &&                                &&\sigma\,((a : A) \to \fst\,(f\,(\lup\!a)) = \ixs\,a)\,\$\,\lambda\,p.\\
  &  &&                                &&\Sigr{S\,(\lambda\,a.\,\tr\,O\,(p\,a)\,(\snd\,(f\,(\lup\! a))))}
\end{alignat*}
There are two points of interest. First, the encoded IR signature has the recursive output type $(\ix
: I) \times O\,\ix$, which lets us interpret $\iota\,\ix\,o$ as $\iota\,(\ix,\,o)$. Second, in the
interpretation of $\delta$, we already need to enforce well-indexing for inductive fields, or else
we cannot recursively proceed with the translation. We solve this by adding an \emph{extra field} in
the output signature, which contains a well-indexing witness of type $((a : A) \to \fst\,(f\,(\lup\!a)) = \ixs\,a)$.
This lets us continue the translation for $S$, by fixing up the return type of $f$ by a transport.

\emph{Note on prior work.} Hancock et al.\ described the same translation from small IIR signatures
to small IR signatures \cite[Section~6]{DBLP:conf/tlca/HancockMGMA13}. However, they only presented
the translation of signatures, without the rest of the construction. Also, constructions and results
for small IR do not generally transfer to our case of ``large'' IR.

\begin{example} \label{ex:ir-vector} We compute the translation of the length-indexed vector signature from Example \ref{ex:vector}.
\begin{alignat*}{4}
  & \floord{S} : \Sig\,(\Nat \times \top)\\
  & \floord{S} \equiv \sigma\,(\Lift\,\Tag)\,\$\,\lambda\,t.\,\case \ldown\!t\,\of \\
  & \quad \Nil'\hspace{0.85em} \to \iota\,(\zero,\,\ttt) \\
  & \quad \Cons'\to \sigma\,(\Lift\,\Nat)\,\$\,\lambda\,n.\,\sigma\,(\Lift\,A)\,\$\,\lambda\,\_.\\
  & \quad \hspace{4em}  \delta\,(\Lift\,\top_0)\,\$\,\lambda\,f.\,\sigma\,((x : \top_0) \to \fst\,(f\,(\lup\!x)) = (\ldown\!n))\,\$\,\lambda\,p.\\
  & \quad \hspace{4em}  \iota\,(\suc\,(\ldown\!n),\,\ttt)
\end{alignat*}
The first $\Nat$ component of the recursive result serves as the index. In the $\Cons'$ case we have
a single inductive field whose length is enforced with the extra $\sigma\,((x : \top) \to
\fst\,(f\,(\lup\!x)) =\,\,\ldown\!n)$. For illustration, we also present the above signature as an
Agda-style IR definition below. We omit type lifting for the sake of brevity.
\begin{alignat*}{4}
  & \data\,\List : \U_0\,\where\\
  & \quad \nil \hspace{0.78em} : \List\\
  & \quad \cons : (n : \Nat) \to A \to (\mit{as} : \top \to \List) \to ((x : \top) \to \fst\,(\El\,(\mit{as}\,x)) = n) \to \List\\
  & \\
  & \El : \List \to \Nat \times \top\\
  & \El\,\nil \hspace{4.7em}:\equiv (\zero,\,\ttt)\\
  & \El\,(\cons\,n\,a\,\mit{as}\,p) :\equiv (\suc\,n,\,\ttt)
\end{alignat*}
This definition is not yet length-indexed, so we use the name ``$\List$'' for the inductive type. However, the length
of the recursive list in $\cons$ is already specified to be $n$.

\end{example}

\subsection{Type and Term Formers}\label{sec:iir-construction-type-term}
We assume $S^* : \Sig_\IIR$ as a parameter to the constructions in the following. This is a
``fixed'' signature that we aim to construct IIR rules for. We need to distinguish this signature
from other ``varying'' signatures that will appear in definitions and we will do induction on.

We give some intuition for the distinction of fixed and varying signatures. Consider the definition
of $\E_{\IIR}$ in Section \ref{sec:iir-type-and-term-formation}: it recurses on the signature
argument while keeping the $\mit{ir}$ and $\mit{el}$ arguments unchanged on every recursive call.
Also consider $\intro_{\IIR}$ which has type $\E\,S\,(\IIR\,S)\,\El\,\mit{ix} \to
\IIR\,S\,\mit{ix}$. If we want to do constructions on $\E\,S\,(\IIR\,S)\,\El\,\mit{ix}$ or
prove properties about its values, if we do induction on $S$, the $(\IIR\,S)$ and $\El$ values
remain unchanged in inductive steps. Hence, most constructions must be parameterized over two
signatures, a ``varying'' $S$ and a ``fixed'' $S^*$, and we can do induction on an $S$ that appears
in $\E\,S\,(\IIR\,S^*)\,\El\,\mit{ix}$. From a different angle: as we iterate through the fields
of a constructor, the signature that specifies the remaining fields changes, but the type of each
inductive field is specified by the same signature.

We proceed to the definition of $\IIR$ and $\El$. Since the encoding of signatures already ensures
the well-indexing of inductive fields in constructors, it only remains to ensure that the
``top-level'' index matches the externally supplied index. We define the $\IIR$ and $\El$ rules as
follows.
\begin{alignat*}{3}
  &\IIR : I \to \U_{\max(i,\,k)}                         && \El : \IIR\,\ix \to O\,\ix \\
  &\IIR\,\ix :\equiv (x : \IR\,\Sigr{S^*}) \times \fst\,(\El\,x) = \ix \hspace{3em}&& \El\,(x,\,p) :\equiv \tr\,O\,p\,(\snd\,(\El\,x))
\end{alignat*}
\begin{example} Continuing the $\Vect$ example and applying the above definitions, we obtain the properly length-indexed definition:
  \begin{alignat*}{3}
    &\Vect : \Nat \to \U_0                                        &&\El : \Vect\,n \to \top\\
    &\Vect\,n :\equiv (x : \List) \times \fst\,(\El\,x) = n\quad  &&\El\,(x,\,p) :\equiv \tr\,(\lambda\,\_.\,\top)\,p\,(\snd\,(\El\,x))
  \end{alignat*}
\end{example}

Let us continue towards the generic $\intro$ definition. First, the following definition describes the
data that we get when we peel off an $\intro$ from an $\IIR\,\ix$ value.
\begin{alignat*}{4}
  &\floord{\E} : \Sig_\IIR \to I \to \U_{\max(i,\,k)}\\
  &\floord{\E}\,S\,\ix :\equiv (x : \E\,\floord{S}\,(\IR\,\floord{S^*})\,\El) \times \fst\,(\F\,x) = \ix
\end{alignat*}
Now, we can show that $\floord{\E}\,S\,\ix$ is equivalent to $\E\,S\,\IIR\,\El\,\ix$, by induction on
$S$. The induction is straightforward and we omit it here. We name the components of the equivalence
as follows:\footnote{In the Agda formalization, we compute $\tau$ by induction on $S$, although it
could be generically recovered from the other four components as well \cite[Section~4.2]{hottbook}.}
\begin{alignat*}{4}
  &\rlap{$\hspace{2em}\ora{\E} : \E\,S\,\IIR\,\El\,\ix \to \floord{\E}\,S\,\ix$} \\
  &\rlap{$\hspace{2em}\ola{\E} : \floord{\E}\,S\,\ix \to \E\,S\,\IIR\,\El\,\ix$} \\
  &\eta      &&: (x : \E\,S\,\IIR\,\El\,\ix) &&\to \ola{\E}\,(\ora{\E}\,x) = x \\
  &\epsilon  &&: (x : \floord{\E}\,S\,\ix)   &&\to \ora{\E}\,(\ola{\E}\,x) = x \\
  &\tau      &&: (x : \E\,S\,\IIR\,\El\,\ix) &&\to \ap\,\ora{\E}\,(\eta\,x) = \epsilon\,(\ola{\E}\,x)
\end{alignat*}
This is a half adjoint equivalence \cite[Section~4.2]{hottbook}. The coherence witness $\tau$ will
be shortly required for rearranging some transports. Next, we show that the two $\F$ operations are
the same, modulo the previous equivalence, again by induction on $S$.
\[\floord{\F} : \{S : \Sig_\IIR\}\{x : S_0\,\IIR\,\El\,\ix\} \to \tr\,O\,(\snd\,(\ora{\E}\,x))\,(\snd\,(\F\,(\fst\,(\ora{\E}\,x)))) = \F\,x\]
This lets us define the other introduction rules as well.
\begin{alignat*}{3}
  &\intro    : \E\,S^*\,\IIR\,\El\,\ix \to \IIR\,\ix && \msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) = \F\,x \\
  &\intro\,x :\equiv \big(\intro_\IR\,(\fst\,(\ora{\E}\,x)),\,\snd\,(\ora{\E}\,x)\big) \quad\quad&& \msf{El\!\!-\!\!intro} && :\equiv \floord{\F}
\end{alignat*}


\subsection{Elimination}\label{sec:iir-construction-elimination}

We assume a level $l$ for the elimination target. We aim to define the following:
\begin{alignat*}{3}
  &\elim :\,           &&(P : \{\ix : I\}\to \IIR\,\ix \to \U_l)\\
  &                \quad\to && (f : \{\ix : I\}(x : \E\,S^*\,\IIR\,\El\,\ix) \to \IH\,P\,x \to P\,(\intro\,x))\\
  &                \quad\to && (x : \IIR\,\ix) \to P\,x
\end{alignat*}
Recall that $x : \IIR\,i$ is given as a pair of some $x : \IR\,\floord{S^*}$ and $p :
\fst\,(\El\,x) = i$.  The idea is to use IR elimination on $x : \IR\,\floord{S^*}$ while adjusting
both $P$ and $f$ to operate on the appropriate data. For $P$, we generalize the induction goal
over a well-indexing witness:
\begin{alignat*}{3}
  &\floord{P} : \IR\,\floord{S^*} \to \U_{\max(k,\,l)} \\
  &\floord{P}\,x :\equiv \{\ix : I\}(p : \fst\,(\El\,x) = \ix) \to P\,(x,\,p)
\end{alignat*}
Now, we have
\begin{alignat*}{3}
  & \elim_\IR\,\floord{P} : ((x : \E\,\floord{S^*}\,(\IR\,\floord{S^*})\,\El) \to \IH\,\floord{P}\,x \to \floord{P}\,(\intro\,x))
       \to (x : \IR\,\floord{S^*}) \to \floord{P}\,x.
\end{alignat*}
We adjust $f$ to obtain the next argument to $\elim_\IR$. $f$ takes $\IH\,P\,x$ as input,
so we need a ``backwards'' conversion:
\begin{alignat*}{3}
  & \ola{\IH} : \{x : \floord{\E}\,S\,\ix\} \to \IH\,\floord{P}\,(\fst\,x) \to \IH\,P\,(\ola{\E}\,x)
\end{alignat*}
This is again defined by easy induction on $S$. The induction method $\floord{f}$ is as follows.
\begin{alignat*}{3}
  &\floord{f} : (x : \E\,\floord{S^*}\,(\IR\,\floord{S^*})\,\El) \to \IH\,\floord{P}\,x \to \floord{P}\,(\intro\,x)\\
  &\floord{f}\,x\,\ih\,p :\equiv \tr\,\bigl(\lambda\,(x,\,p).\,P\,(\intro\,x,\,p)\bigr)\,\bigl(\epsilon\,(x,\,p)\bigr)\,
                                      \bigl(f\,(\ola{\E}\,(x,\,p))\,(\ola{\IH}\,\ih)\bigr)
\end{alignat*}
Thus, the definition of elimination is:
\[ \elim\,P\,f\,(x,\,p) :\equiv \elim_\IR\,\floord{P}\,\floord{f}\,x\,p \]
Only the $\beta$-rule remains to be constructed:
\[ \elim\!-\!\!\beta : \elim\,P\,f\,(\intro\,x) = f\,x\,(\map\,(\elim\,P\,f)\,x) \]
Computing definitions on the \textbf{left hand side}, we get:
\begin{alignat*}{3}
  & \tr\, &&(\lambda\,(x,\,p).\,P\,(\intro\,x,\,p))\\
  &       &&(\epsilon\,(\ora{\E}\,x))\\
  &       &&(f\,(\ola{\E}\,(\ora{\E}\,x))\,(\ola{\IH}\,(\map\,(\lambda\,x\,p.\,\elim\,P\,f\,(x,\,p))\,(\fst\,(\ora{\E}\,x)))))
\end{alignat*}
Next, we prove by induction on $S$ that $\map$ commutes with $\ora{\E}$:
\[ \floord{\map} : \{f\}\{x\} \to \tr\,(\IH\,P)\,(\eta\,x)\,\bigl(\ola{\IH}\,(\map\,f\,(\fst\,(\ora{\E}\,x)))\bigr) = \map\,(\lambda\,(x,\,p).\,f\,x\,p)\,x \]
Using this equation to rewrite the \textbf{right hand side}, we get:
\begin{alignat*}{3}
  f\,x\,\Bigl(\tr\,(\IH\,P)\,(\eta\,x)\,\bigl(\ola{\IH}\,(\map\,(\lambda\,x\,p.\,\elim\,P\,f\,(x,\,p))\,(\fst\,(\ora{\E}\,x)))\bigr)\Bigr)
\end{alignat*}
This is promising: on the left hand side we transport the result of $f$, while on the right hand
side we transport the argument of $f$. Now, the identification on the left is
$\epsilon\,(\ora{\E}\,x)$, while we have $\eta\,x$ on the right. However, we have $\tau\,x :
\ap\,\ora{\E}\,(\eta\,x) = \epsilon\,(\ora{\E}\,x)$, which can be used in conjunction with
standard transport lemmas to match up the two sides. This concludes the construction of IIR types.

\subsection{Strictness}
We briefly analyze the strictness of computation for constructed IIR types. Clearly, since the
construction is defined by induction on IIR signatures, we only have propositional
$\msf{El\!\!-\!\!intro}$ and $\elim\!-\!\!\beta$ in the general case where an IIR signature can be
neutral.

However, we still support the same definitional IIR computation rules as Agda and Idris. That is
because Agda and Idris only have second-class IIR signatures. There, signatures consist of
constructors with fixed configurations of fields, where constructors are disambiguated by canonical
name tags. $\El$ applied to a constructor computes definitionally, and so does the elimination
principle when applied to a constructor. Using our IIR types, we encode Agda IIR types as follows:
\begin{itemize}
\item We have $\sigma\,\Tag\,S$ on the top to represent constructor tags.
\item In $S$, we immediately pattern match on the tag.
\item All other $\Sig$ subterms are canonical in the rest of the signature.
\end{itemize}
Thus, if we apply $\El$ or $\elim$ to a value with a canonical tag, we compute past the branching on
the tag and then compute all the way on the rest of the signature. In the Agda supplement, we provide
length-indexed vectors and the $\Code$ universe as examples for constructed IIR types with strict
computation rules.

\subsection{Mechanization}

We formalized Section \ref{sec:iir-construction} in roughly 250 lines of Agda, using the same
definitions as in this section, and the same notation, as far as Agda's syntax allows. For the
assumption of IR, we verbatim reproduced the specification in Section \ref{sec:ir-specification},
turning $\IR$ into an inductive type and $\El$ and $\elim$ into recursive functions. The functions
are not recognized as terminating by Agda, so we disable termination checking for
them. Alternatively, we could use rewrite rules \cite{DBLP:journals/pacmpl/CockxTW21}; the two
versions are the same except that rewrite rules have a performance cost in type checking and
evaluation that we prefer to avoid.

One small difference is that our object theory does not have internal universe levels, so we
understand level quantification to happen in a metatheory, while in Agda we use native universe
polymorphism.

\section{Canonicity}\label{sec:canonicity}

In this section we prove canonicity for the object theory extended with IR types. First, we specify
the metatheory and the object theory in more detail. Second, we give a logical predicate
interpretation which yields canonicity.

\subsection{Metatheory}\label{sec:metatheory}

\subsubsection{Specification} The metatheory supports the following:
\begin{itemize}
  \item A countable universe hierarchy and basic type formers as described in Section \ref{sec:basic-type-formers}.
    We write universes as $\Set_i$ instead of $\U_i$, to avoid confusion with object-theoretic
    universes.
  \item Equality reflection. Hence, in the following we will only use $\blank\!=\!\blank$ to denote
    metatheoretic equality, and we also write definitions with $:=$.
  \item Universe levels $\omega$ and $\omega+1$, where $\Set_\omega : \Set_{\omega + 1}$ and $\Set_{\omega + 1}$
        is a ``proper type'' that is not contained in any universe. $\Set_\omega$ and $\Set_{\omega + 1}$ are
        also closed under basic type formers.
  \item IR types (thus IIR types as well) in $\Set_i$ when $i$ is finite.
  \item An internal type of finite universe levels. This is similar to Agda's internal type of
    finite levels, called $\Level$ \cite{agdadocs}. The reason for this feature is the following. The
    object theory has countable levels represented as natural numbers, and we have to interpret
    those numbers as metatheoretic levels in the canonicity model, to correctly specify the sizes of
    logical predicates.
  \item The syntax of the object theory as a quotient inductive-inductive type \cite{ttintt,DBLP:journals/corr/abs-2302-08837}, to be
    described in Section \ref{sec:object-theory}.
\end{itemize}
\emph{Notation:} $\Lift$ is derivable the same way as we have seen, but we will make all
lifting implicit in the metatheory. In the object theory, explicit lifting is sensible, because
we talk about strict computation and canonicity, so we want to be precise about definitional
content. In the metatheory we can be more liberal.

\subsubsection{Consistency of the metatheory} As it often happens in type theory, our specific mixture
of features is not covered by any particular reference. However, it is reasonable to expect that
previous works can be combined and generalized to obtain consistency for our metatheory.
\begin{itemize}
\item \citet{DBLP:journals/jlp/DybjerS06} gave a set-theoretic model for IIR. Here, there is a
  universe of small types which supports IIR types, which is modeled using a Mahlo cardinal
  $\msf{M}$, and a universe of large types that contains the type of signatures, which is modeled
  using an inaccessible cardinal above $\msf{M}$. The construction is not committed to this specific
  setup, and it can be adapted to having a countable number of Mahlo cardinals and two inaccessible
  cardinals above the Mahlo cardinals, in order to model our universe hierarchy. Also, having an
  internal type for finite universe levels is naturally supported in the set-theoretic model.
\item Regarding the object syntax as a quotient inductive-inductive type (QIIT), it is a small and
  finitary QIIT, which is constructible from fairly weak metatheoretic
  assumptions,\footnote{Concretely, two universes, UIP, function extensionality, proposition
  extensionality, quotients and natural numbers.} and the general construction was described with
  minor formal gaps by \citet{DBLP:journals/corr/abs-2302-08837}. A construction of a QIIT for a
  specific type theory was fully formalized in Agda by \citet{initiality-agda}. Alternatively, we
  could view the object syntax as essentially algebraic \cite{partialhorn} or generalized algebraic
  \cite{cartmellthesis}. We chose the QIIT because the QIIT literature explicitly describes the
  type-theoretic induction principle that we use.
\end{itemize}

\subsection{The Object Theory}\label{sec:object-theory}

Informally, the object theory is a Martin-Löf type theory that supports basic type formers as
described in Section \ref{sec:basic-type-formers} and IR types as described in Section
\ref{sec:ir-specification}. More formally, the object theory is given as a quotient
inductive-inductive type. The sets, operations and equations that we give in the following
constitute the inductive signature.

\subsubsection{Core substitution calculus} The basic judgmental structure is given
as a category with families (CwF) \cite{Dybjer96internaltype,cwfs} where types are additionally
annotated with levels. This consists of the following.
\begin{itemize}
\item A category of contexts and substitutions. We have $\Con : \Set_0$ for contexts and $\Sub : \Con \to \Con \to \Set_0$
  for substitutions. The empty context $\emptycon$ is the terminal object with the unique substitution $\epsilon : \Sub\,\Gamma\,\emptycon$.
  We write $\id$ for identity substitutions and $\blank\!\circ\!\blank$ for substitution composition.
\item Types indexed by external natural numbers as levels, as $\Ty : \Con \to \Nat \to \Set_0$,
  together with the functorial substitution operation $\blank[\blank] : \Ty\,\Delta\,i \to
  \Sub\,\Gamma\,\Delta \to \Ty\,\Gamma\,i$.
\item Terms as $\Tm : (\Gamma : \Con) \to \Ty\,\Gamma\,i \to \Set_0$, with functorial substitution operation
  $\blank[\blank] : \Tm\,\Delta\,A \to (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,A[\sigma]$.
  \emph{Notation:} both type and term substitution bind stronger than function application, so
  for example $\Tm\,\Gamma\,A[\sigma]$ means $\Tm\,\Gamma\,(A[\sigma])$.
\item Context comprehension, consisting of a context extension operation $\blank\!\ext\!\blank : (\Gamma : \Con) \to \Ty\,\Gamma\,i \to \Con$,
  weakening morphism $\p : \Sub\,(\Gamma\ext A)\,\Gamma$, zero variable $\q : \Tm\,(\Gamma\ext A)\,A[\p]$ and substitution extension $\blank,\!\blank : (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,A[\sigma] \to \Sub\,\Gamma\,(\Delta\ext A)$, such that the following equations hold:
  \begin{alignat*}{5}
    &\p \circ (\sigma,\,t)     &&= \sigma                             &&\q[\sigma,\,t] &&= t\\
    &(\sigma,\,t) \circ \theta &&= (\sigma \circ \theta,\,t[\theta])\hspace{2em} && (\p,\,\q) &&= \id
  \end{alignat*}
  A De Bruijn index $N$ is represented as $\q[\p^N]$, where $\p^N$ is $N$-fold composition
  of weakening.
\end{itemize}

\subsubsection{Universes}
We have Russell-style universes, i.e.\ we have $\U : (i : \Nat) \to \Ty\,\Gamma\,(i + 1)$ such that
$\U_i[\sigma] = \U_i$ and $\Tm\,\Gamma\,\U_i = \Ty\,\Gamma\,i$.  This lets us implicitly convert
between types and terms with universe types. Additionally, we specify that this casting operation
commutes with substitution, so substituting $t : \Tm\,\Gamma\,\U_i$ as a term and then casting to a
type is the same as first casting and then substituting as a type. Since we omit casts and overload
$\blank[\blank]$, this rule looks trivial in our notation, but it still has to be assumed.

\subsubsection{Functions} We have $\Pi : (A : \Ty\,\Gamma\,i) \to \Ty\,(\Gamma \ext A)\,j \to \Ty\,\Gamma\,\max(i,\,j)$
such that $(\Pi\,A\,B)[\sigma] = \Pi\,A[\sigma]\,B[\sigma\circ\p,\,\q]$.  Terms are specified by
$\app : \Tm\,\Gamma\,(\Pi\,A\,B) \to \Tm\,(\Gamma\ext A)\,B$ and its definitional inverse $\lam :
\Tm\,(\Gamma\ext A)\,B \to \Tm\,\Gamma\,(\Pi\,A\,B)$. This isomorphism is natural in $\Gamma$,
i.e.\ we have a substitution rule $(\lam\,t)[\sigma\circ\p,\,\q] = \lam\,t[\sigma]$.

\paragraph{Notation \& conventions} So far we have used standard definitions, but
CwF combinators and De Bruijn indices get very hard to read when we get to more complicated
rules like those in the specification of IR types. So we develop notations and conventions that are
more tailored to our situation.

\begin{itemize}
\item Assuming $t : \Tm\,\Gamma\,(\Pi\,A\,B)$ and $u : \Tm\,\Gamma\,A$, traditional binary function
  application can be derived as $(\app\,t)[\id,\,u] : \Tm\,\Gamma\,B[\id,\,u]$. We overload the
  metatheoretic whitespace operator for this kind of application.
\item We may give a name to a binder (a binder can be a context extension or a $\Pi$, $\Sigma$ or
  $\lam$ binder), and in the scope of the binder all occurrences of the name are desugared to a De
  Bruijn index. We write $\Pi$-types with the same notation as in the metatheory. For example, $(A
  : \U_i) \to A \to A$ is desugared to $\Pi\,\U_i\,(\Pi\,\q\,\q[\p])$. We also reuse the notation
  and behavior of implicit functions. We write object-level lambda abstraction as $\lam\,x.\,t$.
\item
  In the following we specify all type and term formers as \emph{term constants with an iterated
  $\Pi$-type}. For example, we will specify $\Id : \Tm\,\Gamma\,((A : \U_i) \to A \to A \to \U_i)$,
  instead of abstracting over $A : \Ty\,\Gamma\,i$ and $t,\,u : \Tm\,\Gamma\,A$. In general, the two
  flavors are inter-derivable, but sticking to object-level functions lets us consistently use the
  sugar for named binders. Also, specifying stability under substitution becomes very simple: a
  substituted term constant is computed to the same constant (but living in a possibly different
  context). For example, if $\sigma : \Sub\,\Gamma\,\Delta$, then $\Id[\sigma] = \Id$ specifies
  stability under substitution for the identity type former. Hence, we shall omit substitution rules
  in the following.
\end{itemize}

\subsubsection{Sigma types} We have
\begin{alignat*}{3}
  &\Sigma        &&: \Tm\,\Gamma\,((A : \U_i) \to (A \to \U_j) \to \U_{\max(i,\,j)}) \\
  &\blank,\blank &&: \Tm\,\Gamma\,(\{A : \U_i\}\{B : A \to \U_j\}(t : A) \to B\,t \to \Sigma\,A\,B)\\
  &\fst          &&: \Tm\,\Gamma\,(\{A : \U_i\}\{B : A \to \U_j\} \to \Sigma\,A\,B \to A)\\
  &\snd          &&: \Tm\,\Gamma\,(\{A : \U_i\}\{B : A \to \U_j\}(t : \Sigma\,A\,B) \to B\,(\fst\,t))
\end{alignat*}
such that $\fst\,(t,\,u) = t$, $\snd\,(t,\,u) = u$ and $(\fst\,t,\,\snd\,t) = t$.

\subsubsection{Unit} We have $\top_i : \Tm\,\Gamma\,\U_i$ with the definitionally unique inhabitant $\ttt$.

\subsubsection{Booleans} Type formation is $\Bool : \Tm\,\Gamma\,\U_0$ with constructors $\true$ and $\false$. Elimination is as follows.
\begin{alignat*}{3}
  &\BoolElim : \Tm\,\Gamma\,((P : \Bool \to \U_i) \to P\,\true \to P\,\false \to (b : \Bool) \to P\,b)\\
  & \BoolElim\,P\,t\,f\,\true\hspace{0.2em} = t\\
  & \BoolElim\,P\,t\,f\,\false = f
\end{alignat*}

\subsubsection{Identity type}
\begin{alignat*}{3}
  &\Id   &&: \Tm\,\Gamma\,((A : \U_i) \to A \to A \to \U_i)\\
  &\refl &&: \Tm\,\Gamma\,(\{A : \U_i\}(t : A) \to \Id\,A\,t\,t)
\end{alignat*}
\begin{alignat*}{3}
  &\J : \Tm\,\Gamma\,(\{A : \U_i\}\{x : A\}(P : (y : A) \to \Id\,A\,x\,y \to \U_j)\\
  & \hspace{3.5em}\to P\,(\refl\,x) \to \{y : A\}(p : \Id\,A\,x\,y) \to P\,y\,p)&&
  &\\
  &\J\,P\,r\,(\refl\,x) = r
\end{alignat*}

\subsubsection{IR types} First, we specify the type of signatures as an inductive type. We assume levels $i$
and $j$.
\begin{alignat*}{3}
  &\Sig_i  &&: \Tm\,\Gamma\,((O : \U_j) \to \U_{\max(i+1,\,j)})\\
  &\iota   &&: \Tm\,\Gamma\,(\{O : \U_j\} \to O \to \Sig_i\,O)\\
  &\sigma  &&: \Tm\,\Gamma\,(\{O : \U_j\}(A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O)\\
  &\delta  &&: \Tm\,\Gamma\,(\{O : \U_j\}(A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O)
\end{alignat*}
\begin{alignat*}{3}
  &\SigElim : \Tm\,\Gamma\,(\{O : \U_j\}(P : \Sig_i\,O \to \U_k)\\
  &           \hspace{2.2em}\to ((o : O) \to P\,(\iota\,o))\\
  &           \hspace{2.2em}\to ((A : \U_i)(S : A \to \Sig_i\,O) \to ((a : A) \to P\,(S\,a)) \to P\,(\sigma\,A\,S))\\
  &           \hspace{2.2em}\to ((A : \U_i)(S : (A \to O) \to \Sig_i\,O) \to ((f : A \to O) \to P\,(S\,f)) \to P\,(\delta\,A\,S))\\
  &           \hspace{2.2em}\to (S : \Sig_i\,O) \to P\,S)\\
  &\\
  &\SigElim\,P\,i\,s\,d\,(\iota\,o) \hspace{1.1em} = i\\
  &\SigElim\,P\,i\,s\,d\,(\sigma\,A\,S) = s\,A\,S\hspace{0.3em}(\lam\,a.\hspace{0.3em}\SigElim\,P[\p]\,i[\p]\,s[\p]\,d[\p]\,(S[\p]\,a))\\
  &\SigElim\,P\,i\,s\,d\,(\delta\,A\,S) \hspace{0.1em}= d\,A\,S\,(\lam\,f.\,\SigElim\,P[\p]\,i[\p]\,s[\p]\,d[\p]\,(S[\p]\,f))
\end{alignat*}
Note the $[\p]$ weakenings in the computation rules: $P$, $i$, $s$, $d$, and $S$ are all terms
quantified in some implicit context $\Gamma$, so when we mention them under an extra binder, we have
to weaken them. Hence, we cannot fully avoid explicit substitution operations by using named
binders. As to the rest of the specification, we already saw it in Section
\ref{sec:ir-specification} so we only give a short summary.
\begin{itemize}
\item $\E$, $\F$, $\IH$ and $\map$ are defined by $\SigElim$ and they satisfy the same definitional
  equations as in Section \ref{sec:ir-specification}.
\item $\IR$, $\El$, $\intro$ and $\elim$ are all specified as term constants that are only parameterized over contexts and some universe levels.
\end{itemize}

\subsection{The Interpretation of the Object Theory}\label{sec:canonicity-model}

On a high level, canonicity is proved by induction over the syntax of the object theory. Since the
syntax is a quotient inductive-inductive type, it supports an induction principle, which we do not
write out fully here and only use a particular instance of it. Formally, the induction principle
takes a \emph{displayed model} as an argument, which corresponds to a bundle of induction motives,
induction methods and proofs that quotient equations are respected
\cite[Chapter~4]{DBLP:journals/corr/abs-2302-08837}. We could present the current construction as a
displayed model. However, we find it a bit more readable to use an Agda-like notation, where we
specify the resulting \emph{section} of the displayed model, which consists of some mutual
functions, mapping out from the syntax, which have action on constructors and respect all quotient
equations.

\emph{Notation:} in the following we write $\Tm\,A$ to mean $\Tm\,\emptycon\,A$, and
$\Sub\,\Gamma$ to mean $\Sub\,\emptycon\,\Gamma$. This will reduce clutter since we will mostly work
with closed terms and substitutions.

We aim to define the following functions by induction on object syntax.
\begin{alignat*}{3}
  &\blank^\w : (\Gamma : \Con)      && \to \Sub\,\Gamma \to \Set_\omega\\
  &\blank^\w : (A : \Ty\,\Gamma\,i) && \to \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to \Tm\,A[\gamma] \to \Set_i\\
  &\blank^\w : (\sigma : \Sub\,\Gamma\,\Delta) && \to \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to \Delta^\w\,(\sigma \circ \gamma)\\
  &\blank^\w : (t : \Tm\,\Gamma\,A) && \to \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to A^\w\,\gamma^\w\,t[\gamma]
\end{alignat*}

It is a proof-relevant logical predicate interpretation, an instance of a construction called
\emph{Artin gluing} \cite[Exposé~4,~Section~9.5]{SGA4} or \emph{categorical gluing}. The concrete
formulation that we use is the type-theoretic gluing by \citet{gluing}. This is parameterized by a
weak morphism between models of the object type theory. In our case, we take this morphism to be the
global sections functor between the syntax and the standard $\Set$ model. This means that we build
predicates over closed substitutions and closed terms. Coquand's canonicity proof also uses the same
definitions as ours \cite{coquand2018canonicity}. The type-theoretic gluing is a variation of gluing
which uses dependent type families instead of the fibered families of the categorical flavor. The
type-theoretic style becomes valuable when we get to the interpretation of more complicated type
formers. In such cases we find it easier to use than diagrammatic reasoning.

In the interpretation of contexts, note that we return in $\Sub\,\Gamma \to \Set_\omega$. This is so
that arbitrary semantic types (at finite levels) can fit inside semantic contexts. Additionally,
using the formal induction principle for the QIIT, the type of the target of elimination would be
$\Set_{\omega+1}$; hence the need for both $\Set_\omega$ and $\Set_{\omega+1}$.

\todo{Possibly extra discussion on sizing predicates}

In the interpretation of types, note that $i$ appears in $\Ty\,\Gamma\,i$ as a natural number,
but it gets implicitly converted to a universe level in $\Set_i$. This conversion requires that
finite levels are given by an internal type in the metatheory.

\subsubsection{Interpretation of the CwF and the basic type formers}

This was described in previously mentioned works \cite{gluing,coquand2018canonicity}. Additionally,
the code supplement \cite{formalisation} to \cite{DBLP:conf/mpc/KaposiKK19} has an Agda
formalization of the canonicity model with the exact same universe setup and basic type formers that
we use. Therefore we only present the parts which are relevant to the interpretation of IR
types. The interpretation of empty and extended contexts is as follows.
\begin{alignat*}{3}
  &\emptycon^\w\,&&\gamma                 &&:= \top \\
  &(\Gamma\ext A)^\w\,&&(\gamma,\,\alpha) &&:= (\gamma^\w : \Gamma^\w\,\gamma) \times A^\w\,\gamma^\w\,\alpha
\end{alignat*}
This says that the logical predicate holds for a closing substitution if it holds for each term in
the substitution. Note the pattern matching notation in $(\gamma,\,\alpha)$: this is justified,
since all inhabitants of $\Sub\,(\Gamma\ext A)$ are uniquely given as a pairing. The other CwF operations
are as follows.
\begin{alignat*}{4}
  &\id^\w\,\gamma^\w                   &&:= \gamma^\w                  &&(\sigma,\,t)^\w\,\gamma^\w          &&:= (\sigma^\w\,\gamma^\w,\,t^\w\,\gamma^\w)\\
  &(\sigma \circ \theta)^\w\,\gamma^\w &&:= \sigma^\w\,(\theta^\w\,\gamma^\w) && \p^\w\,(\gamma^\w,\,\alpha^\w)      &&:= \gamma^\w\\
  &(A[\sigma]) ^\w\,\gamma^\w\,\alpha  &&:= A^\w\,(\sigma^\w\,\gamma^\w)\,\alpha\hspace{3em} && \q^\w\,(\gamma^\w,\,\alpha^\w)      &&:= \alpha^\w\\
  &(t[\sigma]) ^\w\,\gamma^\w          &&:= t^\w\,(\sigma^\w\,\gamma^\w) && \epsilon^\w\,\gamma^\w              &&:= \ttt
\end{alignat*}
The interpretation of \textbf{universes} is the following.
\begin{alignat*}{4}
  &(\U_i)^\w\,\gamma^\w\,\alpha := \Tm\,\alpha \to \Set_i
\end{alignat*}
This definition also supports the Russell universe rules. For illustration, assuming $t :
\Tm\,\Gamma\,\U_i$, we have $t^\w : \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma) \to
\Tm\,t[\gamma] \to \Set_i$. If use first use the syntactic Russell equation to cast $t$ to the type
$\Ty\,\Gamma\,i$, then $t^\w$ still has the same type.

Note that we do not get a canonicity statement about types themselves, i.e.\ we do not get that
every closed type is definitionally equal to one of the canonical type formers. This could be handled
as well, but we skip it because it is orthogonal to the focus of this paper.

We interpret \textbf{functions} as follows.
\begin{alignat*}{4}
  &(\Pi\,A\,B)^\w\,\{\gamma\}\,\gamma^\w\,f &&:= \{\alpha : \Tm\,A[\gamma]\}(\alpha^\w : A^\w\,\gamma^\w\,\alpha) \to B^\w\,(\gamma^\w,\,\alpha^\w)\,(f\,\alpha)\\
  &(\lam\,t)^\w\,\gamma^\w &&:= \lambda\,\{\alpha\}\,\alpha^\w.\,t^\w\,(\gamma^\w,\,\alpha^\w)\\
  &(\app\,t)^\w\,(\gamma^\w,\,\alpha^\w) &&:= t^\w\,\gamma^\w\,\alpha^\w
\end{alignat*}
In the $\Pi\,A\,B$ case, note that $f : \Tm\,(\Pi\,A\,B)[\gamma]$, which means that we can apply it
to $\alpha$ to get $f\,\alpha : \Tm\,B[\gamma,\,\alpha]$. We can also derive the interpretation of
binary applications: $(t\,u)^\w\,\gamma^\w$ is computed to $t^\w\,\gamma^\w\,(u^\w\,\gamma^\w)$.

For \textbf{$\Sigma$-types}, we have
\begin{alignat*}{4}
  &\Sigma^\w\,\gamma^\w\,A^\w\,B^\w\,(t,\,u)   &&:= (t^\w : A^\w\,t) \times B^\w\,t^\w\,u\hspace{2em}  && \fst^\w\,\gamma^\w\,(t^\w,\,u^\w) &&:= t^\w \\
  &(\blank,\blank)^\w\,\gamma^\w\,t^\w\,u^\w   &&:= (t^\w,\,u^\w)                                     && \snd^\w\,\gamma^\w\,(t^\w,\,u^\w) &&:= u^\w
\end{alignat*}
For the \textbf{unit type}, we have $(\top_i)^\w\,\gamma^\w\,t := \top_i$ and $\ttt^\w\,\gamma^\w := \ttt$.

\subsubsection{Interpretation of IR signatures}\label{sec:ir-signatures-canonicity}

Signatures are given as an ordinary inductive family, so in principle there should be nothing
``new'' in their logical predicate interpretation. We do detail it here because several later
constructions depend on it. Recall that $\Sig_i : \Tm\,\Gamma\,((O : \U_j) \to \U_{\max(i+1,\,j)})$,
so we have
\begin{alignat*}{3}
  &(\Sig_i)^\w\,\gamma^\w : ((O : \U_j) \to \U_{\max(i+1,\,j)})^\w\,\gamma^\w\,\Sig_i\\
  &(\Sig_i)^\w\,\gamma^\w : \{O : \Tm\,\U_j\}(O^\w : (\U_j)^\w\,\gamma^\w\,O) \to (\U_{\max(i+1,\,j)})^\w\,\gamma^\w\,(\Sig_i\,O)\\
  &(\Sig_i)^\w\,\gamma^\w : \{O : \Tm\,\U_j\}(O^\w : \Tm\,O \to \Set_j) \to \Tm\,(\Sig_i\,O) \to \Set_{\max(i+1,\,j)}.
\end{alignat*}
Hence, we define an inductive type in the metatheory that is parameterized by $O : \Tm\,\U_j$ and
$O^\w : \Tm\,O \to \Set_j$ and indexed over $\Tm\,(\Sig_i\,O)$. We name this inductive type
$\Sig^\w$; the naming risks some confusion, but we shall take the risk and we will shortly
explain the rationale.
\begin{alignat*}{4}
  &\rlap{$\data\,\Sig^\w\,\{O : \Tm\,\U_j\}\,(O^\w : \Tm\,O \to \Set_j)  : \Tm\,(\Sig_i\,O) \to \Set_{\max(i+1,\,j)}$}\\
  &\quad \iota^\w  &&:\,&&\{o &&: \Tm\,O\}(o^\w : O^\w\,o) \to \Sig^\w\,O^\w\,(\iota\,o)\\
  &\quad \sigma^\w &&:\,&&\{A &&: \Tm\,\U_i\}(A^\w : \Tm\,A \to \Set_i)\\
  &               && &&\{S &&: \Tm\,(A \to \Sig_i\,O)\}\\
  &               && && (S^\w &&: \{a : \Tm\,A\} \to A^\w\,a \to \Sig^\w\,O^\w\,(S\,a))\\
  &               && && \to &&\,\Sig^\w\,O^\w\,(\sigma\,A\,S)\\
  &\quad \delta^\w &&:\,&&\{A &&: \Tm\,\U_i\}(A^\w : \Tm\,A \to \Set_i)\\
  &               &&   && \{S &&: \Tm\,((A \to O) \to \Sig_i\,O)\}\\
  &               &&   && (S^\w &&: \{f : \Tm\,(A \to O)\} \to (\{a : \Tm\,A\} \to A^\w\,a \to O^\w\,(f\,a)) \to \Sig^\w\,O^\w\,(S\,f))\\
  &\quad          &&   && \to &&\,\Sig^\w\,O^\w\,(\delta\,f\,S)
\end{alignat*}
A witness of $\Sig^\w\,O^\w\,t$ tells us that $t$ is a canonical constructor and it only contains
canonical data, inductively. Now, we define $(\Sig_i)^\w\,\gamma^\w\,O^\w\,t$ to be
$\Sig^\w\,O^\w\,t$, and each syntactic $\Sig$ constructor is interpreted using the corresponding
semantic constructor. For instance:
\begin{alignat*}{4}
  &\iota^\w : \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma)\{O : \Tm\,\U_j\}\{O^\w : \Tm\,O \to \Set_j\}\{o : \Tm\,O\} \to O^\w\,o \to \Sig^\w\,O^\w\,(\iota\,o)\\
  &\iota^\w\,\gamma^\w\,o^\w := \iota^\w\,o^\w
\end{alignat*}
We skip the interpretation of the other constructors and the eliminator here. Above on the left side
we use $\iota^\w$ for specifying the action of $\blank^\w$ on the syntactic $\iota$, while on the
right side we use the metatheoretic $\Sig^\w$ constructor $\iota^\w$. In general, the recipe is:
\begin{enumerate}
\item We first give semantic definitions that only refer to closed terms.
\item Then, we ``contextualize'' the definitions to get interpretations of object-theoretic rules.
\end{enumerate}
In this section, the bulk of the work is step (1) and step (2) is fairly trivial. In step (1), we
use $\blank^\w$ to mark semantic definitions and we do not need to refer to $\blank^\w$ as a family
of interpretation functions on the object syntax. In step (2) we do overload $\blank^\w$ but hope
that this does not generate too much confusion.

\subsubsection{Interpretation of IR types}\label{sec:ir-canonicity}

The basic idea is that for each IR type, the corresponding canonicity predicate should be defined as
a metatheoretic IIR type. This gets rather technical, so first let us look at an informal example
for a concrete IR type.

\begin{example}\label{ex:code-canonicity}
Consider the Agda code example in Section \ref{sec:introduction}. We assume that it is a concrete
``native'' IR type in the object theory, and present the canonicity predicate for it as a
metatheoretic IIR type. First, the specification of the object-theoretic IR type, disregarding the
eliminator:
\begin{alignat*}{4}
  &\Code &&: \Tm\,\Gamma\,\U_0 && \El : \Tm\,\Gamma\,(\Code \to \U_0) \\
  &\Nat' &&: \Tm\,\Gamma\,\Code && \El\,\Nat'\hspace{1.5em} = \Nat \\
  &\Pi'  &&: \Tm\,\Gamma\,((A : \Code) \to (\El\,A \to \Code) \to \Code)\hspace{1em} && \El\,(\Pi'\,A\,B) = (a : \El\,A) \to \El\,(B\,a)
\end{alignat*}
We assume $\Nat^\w : \Tm\,\Nat \to \Set_0$. The canonicity predicate is the following IIR type.
\begin{alignat*}{4}
  &\rlap{$\data\,\Code^\w : \Tm\,\Code \to \Set_0$}\\
  &\quad\Nat'^\w &&: \,\,&& \Code^\w\,\Nat'\\
  &\quad\Pi'^\w  &&: \,\,&&\{A : \Tm\,\Code\}(A^\w : \Code^\w\,A)\\
  &\quad         &&  && \{B : \Tm\,(\El\,A \to \Code)\}(B^\w : \{a : \Tm\,(\El\,a)\} \to \El^\w\,A^\w\,a \to \Code^\w\,(B\,a))\\
  &\quad         &&  && \to \Code^\w\,(\Pi'\,A\,B)\\
  &\rlap{}\\
  &\rlap{$\El^\w : \{t : \Tm\,\Code\} \to \Code^\w\,t \to (\Tm\,(\El\,t) \to \Set_0)$}\\
  &\rlap{$\El^\w\,\Nat'^\w  \hspace{2.4em}            = \Nat^\w$}  \\
  &\rlap{$\El^\w\,(\Pi'^\w\,A^\w\,B^\w) = \lambda\,f.\,\{a : \Tm\,A\} \to \El^\w\,A^\w\,a \to \El^\w\,B^\w\,(f\,a)$}
\end{alignat*}
The predicate has to be inductive-recursive, because we have to recursively compute predicates for
types of the form $\El\,t$. Using this definition of canonicity for $\Code$, we could proceed and
prove canonicity for an object theory that supports $\Code$. Our task in this section is to
generalize this: we do the same construction generically for all IR types.
\end{example}

We proceed to the semantic definitions. We assume the following parameters: $O : \Tm\,\U_j$, $O^\w :
\Tm\,O \to \Set_j$, $S^* : \Tm\,(\Sig_i\,O)$ and $S^{*\w} :
\Sig^\w\,O^\w\,S^*$. \emph{Abbreviation:} we write $\Sig^\w\,S$ in the following, omitting the fixed
$O^\w$ parameter from the type.  Like in Section \ref{sec:iir-construction}, we view $S^*$ as a
``fixed'' top-level signature, in contrast to ``varying'' signatures that we will encounter in
constructions. We will do induction on such varying signatures, but now the induction must happen
on \emph{sub-signatures} of $S^*$, instead of arbitrary signatures.


\begin{definition}[Paths to sub-signatures of $S^*$]
We define an inductive family indexed
over $S : \Tm\,(\Sig_i\,O)$ and $S^\w : \Sig^\w\,O^\w\,S$, which represents paths into $S^*$ that lead to $S$, viewing
$S$ as a subtree. Also, the subtree $S$ and all data in the path must be canonical (i.e.\ have $\blank^\w$
witnesses). The path is represented as a left-associated \emph{snoc-list} of data that can be
plugged into $\sigma$ and $\delta$ constructors.
\begin{alignat*}{4}
  &\rlap{$\data\,\Path : \{S : \Tm\,(\Sig_i\,O)\} \to \Sig^\w\,S \to \Set_{\max(i+1,\,j+1)}$}\\
  &\quad \here    &&: \Path\,\Ssw\\
  &\quad \insigma &&: \Path\,(\sigma^\w\,A^\w\,S^\w) \to \{a : \Tm\,A\}(a^\w : A^\w\,a) \to \Path\,(S^\w\,a^\w) \\
  &\quad \indelta &&: \Path\,(\delta^\w\,A^\w\,S^\w) \to \{f : \Tm\,(A \to \IR\,S^*)\}(f^\w : \{a : \Tm\,A\} \to A^\w\,a \to O^\w\,(\El\,(f\,a)))\\
  &               && \hspace{0.6em} \to \Path\,(S^\w\,f^\w)
\end{alignat*}
We give an informal explanation for why we need to talk about paths to sub-signatures. Consider
$\Code$ from Section \ref{sec:introduction} and its signature $S$ in Example
\ref{ex:code-signature}. We aim to produce the signature that corresponds to $\Code^\w$ in Example
\ref{ex:code-canonicity}, by induction on $S$.  Note the return type of $\Pi'^\w$, which is
$\Code^\w\,(\Pi'\,A\,B)$. This refers back to $A$ and $B$ which are bound \emph{previously} in the
constructor type. Hence, as we recurse through $S$, we need to remember the constructor fields that
we already passed, and we represent this data as a snoc-list, using $\Path$.

We can push the terms contained in a path onto a term with type $\E\,S\,(\IR\,S^*)\,\El$, getting a
term with type $\E\,S^*\,(\IR\,S^*)\,\El$:
\begin{alignat*}{4}
  & \hspace{-6em}\rlap{$\push : \Path\,S^\w \to \Tm\,(\E\,S\,(\IR\,S^*)\,\El) \to \Tm\,(\E\,S^*\,(\IR\,S^*)\,\El)$}\\
  & \hspace{-6em}\push\,\here\,                     &&t := t\\
  & \hspace{-6em}\push\,(\insigma\,p\,\{a\}\,a^\w)\,&&t := \push\,p\,(a,\,t)\\
  & \hspace{-6em}\push\,(\indelta\,p\,\{f\}\,f^\w)\,&&t := \push\,p\,(f,\,t)
\end{alignat*}
Note that we have $f : \Tm\,(A \to \IR\,S^*)$ in $\indelta$, although we could have used a more
general definition of sub-signatures with $f : \Tm\,(A \to O)$. The more specific version is
necessary to make the definition of $\push$ well-typed. We also show that $\push$ preserves $\F$, so
we have $\F\,(\push\,p\,t) = \F\,t$.

\end{definition}

\begin{definition}[Interpretation of signatures] We translate signatures by induction on $\Sig^\w\,S$;
this is the only viable way, since we have no appropriate induction principle for
$\Tm\,(\Sig_i\,O)$.  As we recurse into a signature, we store the data that we have seen in a
$\Path$, and when we hit the base case $\iota^\w$, we push the path onto $\ttt$ to build up the
correct term for the constructor index.
\begin{alignat*}{5}
  &\rlap{$\floord{\blank} : (S^\w : \Sig^\w\,S) \to \Path\,S^\w \to \Sig_\IIR\,(\Tm\,(\IR\,S^*))\,(O^\w\circ \El)$}\\
  &\floord{\iota^\w\,o^\w}\,&&p               &&:=\,&&\,\iota\,(\intro\,(\push\,p\,\ttt))\,o^\w\\
  &\floord{\sigma^\w\,\{A\}\,A^\w\,S^\w}\,&&p &&:=\,&&\sigma\,(\Tm\,A)\,\$\,\lambda\,a.\,\sigma\,(A^\w\,a)\,\$\,\lambda\,a^\w.\,\floord{S^\w\,a^\w}\,(\insigma\,p\,a^\w)\\
  &\floord{\delta^\w\,\{A\}\,A^\w\,S^\w}\,&&p &&:=\,&&\sigma\,(\Tm\,(A \to \IR\,S^*))\,\$\,\lambda\,f.\,\delta\,((a : \Tm\,A) \times A^\w\,a) (\lambda\,(a,\,\_).\,f\,a)\,\$\,\lambda\,f^\w.\\
  &                       &&              &&   &&\hspace{0.8em}\floord{S^\w\,(\lambda\,\{a\}\,a^\w.\,f^\w\,(a,\,a^\w))}\,(\indelta\,p\,(\lambda\,\{a\}\,a^\w.\,f^\w\,(a,\,a^\w)))
\end{alignat*}
Some remarks:
\begin{itemize}
  \item The metatheoretic IIR type is indexed over $\Tm\,(\IR\,S^*)$, and the recursive output type
    is given by $O^\w\circ \El : \Tm\,(\IR\,S^*) \to \Set_j$. Here, we implicitly cast the syntactic
    $\El : \Tm\,(\IR\,S^* \to O)$ to the funtion type $\Tm\,(\IR\,S^*) \to \Tm\,O$.
  \item In the $\iota^\w$ case, we have $o^\w : O^\w\,o$ and
    \[ \iota : (t : \Tm\,(\IR\,S^*)) \to O^\w\,(\El\,t) \to \Sig_\IIR\,(\Tm\,(\IR\,S^*))\,(O^\w\circ \El). \]
    We have $\intro\,(\push\,p\,\ttt) : \Tm\,(\IR\,S^*)$. If we apply $\El$ to this term, it computes
    to $\F\,(\push\,p\,\ttt)$, which is the same as $\F\,\{\iota\,o\}\,\ttt$, which is the same
    as $o$, which makes $o^\w : O^\w\,o$ well-typed for the second argument.
  \item In the $\sigma^\w$ case, we use two $\sigma$-s to abstract over a term and a canonicity witness for it.
  \item In the $\delta^\w$ case, we abstract over $f : \Tm\,(A \to \IR\,S^*)$, then we use $\delta$ to specify inductive
        witnesses for all ``subtrees'' that are obtained by applying $f$ to canonical terms.
\end{itemize}
\end{definition}


\begin{example}\label{ex:code-canonicity-signature} Let $S^*$ be the signature from Example \ref{ex:code-signature}. It depends on the $\Tag$ and $\Nat$ types,
so we assume evident $\blank^\w$ interpretations for them. Now, $S^* : \Tm\,(\Sig_0\,\U_0)$ is a closed term
that does not refer to any IR type or term former, so we can already fully compute the $\blank^\w$
operation on it, obtaining $\Ssw : \Sig^\w\,(\lambda\,A.\,\Tm\,A \to \Set_0)\,S^*$.

\todo{Present $\Ssw$}

Then, we compute the following.
\begin{alignat*}{4}
  & \floord{\Ssw}\,\here : \Sig_\IIR\,(\Tm\,(\IR\,S^*))\,(\lambda\,t.\,\Tm\,(\El\,t) \to \Set_0)\\
  & \floord{\Ssw}\,\here = \sigma\,(\Tm\,\Tag)\,\$\,\lambda\,t.\,\sigma\,(\Tag^\w\,t)\,\$\,\lambda\,t^\w.\,\case\,t^\w\,\of\\
  & \quad \Nat'^\w \to \iota\,(\intro\,(\Nat',\,\ttt))\,\Nat^\w\\
  & \quad \Pi'^\w\hspace{0.8em} \to \sigma\,(\Tm\,(\top \to \IR\,S^*))\hspace{1.75em}\$\,\lambda\,A.\,
                      \delta\,((a : \Tm\,\top) \times \top)\hspace{4.4em}(\fst \circ A)\,\$\,\lambda\,\{{ElA}\}\,{ElA}^\w.\\
  & \hspace{4.8em} \sigma\,(\Tm\,({ElA}\,\ttt \to \IR\,S^*))\,\$\,\lambda\,B.\,
                      \delta\,((a : \Tm\,({ElA}\,\ttt)) \times {ElA}^\w\,a)\,(\fst \circ B)\,\$\,\lambda\,\{{ElB}\}\,{ElB}^\w.\\
  & \hspace{4.8em} \iota\,\,(\intro\,(\Pi',\,A,\,B,\,\ttt))\,(\lambda\,f.\,\{a : \Tm\,({ElA}\,\ttt)\} \to {ElA}^\w\,a \to {ElB}^\w\,(f\,a))
\end{alignat*}
This specifies essentially the same IIR type that we have seen in Example \ref{ex:code-canonicity}, with
some extra noise in the first argument of $\Pi'$, which is now represented as a function with domain $\top$.
\end{example}

\begin{definition}[Interpretation of $\IR$ and $\El$]
This time around, translated signatures directly yield the interpretation of $\IR$ and $\El$, and we do not need to
fix it up with additional predicates.
\begin{alignat*}{4}
  &\IR^\w : \Tm\,(\IR\,S^*) \to \Set_i \quad\quad && \El^\w : \{t : \Tm\,(\IR\,S^*)\} \to \IR^\w\,t \to O^\w\,(\El\,t)\\
  &\IR^\w := \IIR\,\PSbe                          && \El^\w := \El_\IIR
\end{alignat*}
\end{definition}

\begin{definition}[Interpretation of $\E$, $\F$ and $\intro$]
To interpret $\intro$, we need to show an equivalence between two representations of $\IR^\w$'s data, somewhat
similarly to Section \ref{sec:iir-construction-type-term}. For $\intro$, we only need one
component map of the equivalence, but later we will need all of it.

First, we define the predicate interpretations of $\E$ and $\F$. The general form states that
$\E$ and $\F$ preserve predicates, but we will only need the special case when the $\ir$
and $\el$ arguments are $\IR\,S^*$ and $\El$ respectively.
\begin{alignat*}{3}
  & \E^\w : \Sig^\w\,S \to \Tm\,(\E\,S\,(\IR\,S^*)\,\El) \to \Set_i\\
  & \F^\w : \{S^\w : \Sig^\w\,S\}\{t : \Tm\,(\E\,S\,(\IR\,S^*)\,\El)\} \to \E^\w\,S^\w\,t \to O^\w\,(\F\,t)
\end{alignat*}
Second, we define
\begin{alignat*}{3}
  &\floord{\E} : \{S^\w : \Sig^\w\,S\} \to \Path\,S^\w \to \Tm\,(\IR\,S^*) \to \Set_i\\
  &\floord{\E}\,p\,t := (t' : \Tm\,(\E\,S\,(\IR\,S^*)\,\El)) \times ((\intro\,(\push\,p\,t') = t) \times \E^\w\,S^\w\,t').
\end{alignat*}
Next, we show the following equivalence by induction on $S^\w$:
\[  \floord{\E}\,\{S^\w\}\,p\,t \simeq \E\,(\floord{S^\w}\,p)\,\IR^\w\,\El^\w\,t \]
We write $\ora{\E}\,p$ for the map with type $\floord{\E}\,\{S^\w\}\,p\,t \to
\E\,(\floord{S^\w}\,p)\,\IR^\w\,\El^\w\,t$ and $\ola{\E}\,p$ for its inverse. This lets us interpret
$\intro$.
\begin{alignat*}{4}
  & \intro^\w : \{t : \Tm\,(\E\,S^*\,(\IR\,S^*)\,\El)\} \to \E^\w\,S^{*\w}\,t \to \IR^\w\,(\intro\,t)\\
  & \intro^\w\,\{t\}\,t^\w := \intro_\IIR\,(\ora{\E}\,\here\,(t,\,\refl,\,t^\w))
\end{alignat*}
\end{definition}

\begin{definition}[Interpretation of $\Elintro$]\label{sec:canonicity-elintro}
Similarly as in Section \ref{sec:iir-construction-type-term}, we need to show that $\F$ is preserved
by signature translation. For this, we need to annotate $\Path$ with additional information. Recall
that the current definition of $\Path$ is not quite the most general notion of paths in signatures,
because the $\indelta$ constructor restricts the stored syntactic functions to the form $\El \circ f
: \Tm\,(A \to O)$, only storing $f : \Tm\,(A \to \IR\,S^*)$. This restriction is required for the
definition of $\push$, where we need to produce $\Tm\,(\E\,S^*\,(\IR\,S^*)\,\El)$ as output.

Now we also need to restrict the $f^\w$ witnesses in $\indelta$ to the form $f^\w \circ \El^\w$,
where $f^\w : \{a : \Tm\,A\} \to A^\w\,a \to \IR^\w\,(f\,a)$. We define a predicate over $\Path$
that expresses this:
\[ \msf{restrict} : \Path\,S^\w \to \Set_{\max(i+1,\,j+1)} \]
This is required for the predicate interpretation of $\push$, which is defined by induction on $\Path$:
\[ \push^\w : (p : \Path\,S^\w) \to \msf{restrict}\,p \to \E^\w\,S^\w\,t \to E^\w\,S^{*\w}\,(\push\,p\,t) \]
This operation is preserved by $\F^\w$:
\[ \F^\w\,(\push^\w\,p\,q\,t^\w) = \F^\w\,t^\w \]
We use $\push^\w$ in the statement of $\floord{\F}$, which we prove by induction on
$S^\w$:
\[ \floord{\F} : \F\,(\ora{\E}\,p\,t^\w) = \F^\w\,\{S^\w\}\,(\push^\w\,p\,q\,t^\w) \]
Finally, we define $\Elintro^\w$:
\begin{alignat*}{3}
    &\Elintro^\w : \{t\}(t^\w : \E^\w\,S^{*\w}\,t) \to \El^\w\,(\intro^\w\,t^\w) = \F^\w\,t^\w\\
    &\Elintro^\w\ := \floord{\F}\,\here\,\ttt
\end{alignat*}
Above, $\ttt$ witnesses the restriction of ``$\here$'', which is trivial (since ``$\here$'' does not contain $\indelta$).
\end{definition}
\begin{definition}[Interpretation of $\elim$] \label{def:ir-canonicity-elim}
We assume the following parameters to elimination:
\begin{alignat*}{4}
  &k    &&:\,\,&&\Nat\\
  &P    &&:&& \Tm\,(\IR\,S^* \to \U_k)\\
  &P^\w &&:&& \{t\} \to \IR^\w\,t \to \Tm\,(P\,t) \to \Set_k
\end{alignat*}
We define the predicate interpretations for $\IH$ and $\map$ first, specializing the $\ir$ and $\el$
arguments to $\IR\,S^*$ and $\El$ and the target level to $k$.
\begin{alignat*}{3}
  &\IH^\w  &&:\,\,&& \E^\w\,S^\w\,t \to \Tm\,(\IH\,P\,t) \to \Set_{\max(i,\,k)}\\
  &\map^\w &&:\,\,&& \{f : \Tm\,((x : \IR\,S^*) \to P\,x)\}(f^\w : \{t\}(t^\w : \IR^\w\,t) \to P^\w\,t^\w\,(f\,t))\{t\}(t^\w : \E^\w\,S^\w\,t)\\
  &        &&    &&  \to \IH^\w\,t^\w\,(\map\,f\,t)
\end{alignat*}
We also assume the induction method and its canonicity witness as parameters:
\begin{alignat*}{3}
  &f    &&:\,\,&& \Tm\,((x : \E\,S^*\,(\IR\,S^*)\,\El) \to \IH\,P\,x \to P\,(\intro\,x))\\
  &f^\w &&:\,\,&& \{t\}(t^\w : \E^\w\,S^{*\w}\,t)\{\ih\} \to \IH^\w\,t^\w\,\ih \to P^\w\,(\intro^\w\,t^\w)\,(f\,t\,\ih)
\end{alignat*}
The goal is the following:
\[ \elim^\w : \{t : \Tm\,(\IR\,S^*)\}(t^\w : \IR^\w\,t) \to P^\w\,t^\w\,(\elim\,P\,f\,t)  \]
We shall use IIR elimination on $t^\w$ to give the definition. Again like in Section \ref{sec:iir-construction-elimination}, we
have to massage $P^\w$ and $f^\w$ to be able to pass them to $\elim_\IIR$. For the former, we have
\begin{alignat*}{4}
  &\floord{P^\w} : \{t\} \to \IR^\w\,t \to \Set_k\\
  &\floord{P^\w}\,\{t\}\,t^\w := P^\w\,t^\w\,(\elim\,P\,f\,t).
\end{alignat*}
For the latter, we first define decoding for induction hypotheses, by induction
on $S^\w$:
\[ \ola{\IH} : \IH\,\floord{P^\w}\,t^\w \to
      \IH^\w\,\big(\snd\,(\snd\,(\ola{\E}\,p\,t^\w))\big)\,\big(\map\,(\elim\,P\,f)\,(\fst\,(\ola{\E}\,p\,t^\w))\big) \]
And define
\begin{alignat*}{4}
  &\floord{f^\w} : \{t\}(t^\w : \E\,(\floord{S^*}\,\here)\,\IR^\w\,\El^\w\,t) \to \IH\,\floord{P^\w}\,t^\w \to \floord{P^\w}\,(\intro\,t^\w)\\
  &\floord{f^\w}\,t^\w\,\ih^\w := f^\w\,\big(\snd\,(\snd\,(\ola{\E}\,\here\,t^\w))\big)\,\big(\ola{\IH}\,\,\here\,\ih^\w\big).
\end{alignat*}
Hence, elimination is interpreted as follows:
\[ \elim^\w := \elim_\IIR\,\floord{P^\w}\,\floord{f^\w} \]
\end{definition}

\begin{definition}[Interpretation of $\elimbeta$]
The goal is the following:
\[ \elimbeta^\w : \{t\}(t^\w : \E^\w\,S^{*\w}\,t) \to \elim^\w\,(\intro^\w\,t^\w) = f^\w\,t^\w\,(\map^\w\,\elim^\w\,t^\w) \]
The left hand side computes to the following:
\begin{alignat*}{4}
  &f^\w\,\Big(\snd\,\big(\snd\,\big(\ola{\E}\,\here\,(\ora{\E}\,\,\here\,(t,\,\refl,\,t^\w))\big)\big)\Big)\,\Big(\ola{\IH}\,\,\here\,\big(\map\,\elim^\w\,(\ora{\E}\,\,\here\,(t,\,\refl,\,t^\w))\big)\Big)
\end{alignat*}
The first argument to $f^\w$ simplifies to $t^\w$ by canceling $\ola{\E}$ and $\ora{\E}$.  For the
second argument, like in Section \ref{sec:iir-construction-elimination}, we show that $\map$
appropriately commutes with $\ora{\E}$.

\emph{Remark.} In the Agda formalization of $\elimbeta$, we use uniqueness of identity proofs (UIP)
instead of trying to shuffle transports by homotopical reasoning. UIP is available in the metatheory
in this paper since we assume equality reflection. We use UIP mainly because it makes the
formalization easier. However, we conjecture that it is possible skip UIP, and that might be useful in
future applications and variations of our construction. See Section
\ref{sec:generalizing-the-logical-predicate} for more discussion. We note that we only use UIP in
$\elimbeta$, and we make this fact explicit in the formalization by parameterizing $\elimbeta$ over
UIP and otherwise using the $\texttt{--without-K}$ option everywhere \cite{agdadocs-withoutk}.

\end{definition}

\begin{definition}[Interpretation of object-theoretic IR rules]
At this point we have semantic definitions that only mention closed terms. The final step is to
generalize them to arbitrary contexts, thereby interpreting object-theoretic IR rules.

In the object theory we have $\IR : \Tm\,\Gamma\,(\{O : \U_j\} \to \Sig_i\,O \to \U_i)$, hence by the specification
of $\blank^\w$ in Section \ref{sec:canonicity-model}, we need
\begin{alignat*}{4}
  & \IR^\w &&:\,\,&& \{\gamma : \Sub\,\Gamma\}(\gamma^\w : \Gamma^\w\,\gamma)\{O : \Tm\,\U_j\}(O^\w : \Tm\,O \to \Set_j)\\
  &         &&     && \{S : \Tm\,(\Sig_i\,O)\}(S^\w : \Sig^\w\,O^\w\,S) \to \Tm\,(\IR\,S) \to \Set_i.
\end{alignat*}
We have previously defined the semantic $\IR^\w$ with the following type (including all parameters):
\begin{alignat*}{4}
  & \IR^\w : \{O : \Tm\,\U_j\}(O^\w : \Tm\,O \to \Set_j)\{S : \Tm\,(\Sig_i\,O)\}(S^\w : \Sig^\w\,O^\w\,S) \to \Tm\,(\IR\,S) \to \Set_i
\end{alignat*}
Hence, the contextual definition is just a constant function, i.e.\ $\IR^\w\,\{\gamma\}\,\gamma^\w
:= \IR^\w$.

We also need to interpret stability under substitution. In the object theory we have
$(\IR\,\{\Gamma\})[\sigma] = \IR\,\{\Delta\}$ when $\sigma : \Sub\,\Delta\,\Gamma$. Hence, we need
to show $((\IR\,\{\Gamma\})[\sigma])^\w = (\IR\,\{\Delta\})^\w$ here. Computing this type further
and applying function extensionality, we have the goal $\IR^\w\,(\sigma^\w\,\gamma^\w) =
\IR^\w\,\gamma^\w$, which is by definition $\IR^\w = \IR^\w$ for the non-contextual $\IR^\w$
definition, and thus holds trivially. Every other IR rule and substitution rule is interpreted
similarly, as constant functions and trivial equations. $\Elintro$ and $\elimbeta$ are dispatched by
the equations that we have already proved.

In a nutshell, contextualization is easy because every IR type former and term former is interpreted
as a closed term in the semantics, which is then weakened to arbitrary contexts, and the action of
substitution on closed terms is trivial. However, we note that this setup is made possible by having
enough universes, i.e.\ every type is contained in some universe, which allows us to use term constants
with $\Pi$-types in the specification.

For an example, we look at $\Elintro$. In the object theory, we have $\Elintro : \El\,(\intro\,x) =
\F\,x$, so we need to show $(\El\,(\intro\,x))^\w\,\gamma^\w = (\F\,x)^\w\,\gamma^\w$. Using the
definition of $\blank^\w$ for functions and the definitions of $\El^\w\,\gamma^\w$,
$\intro^\w\,\gamma^\w$ and $\F^\w\,\gamma^\w$, this is computed to
\[ \El^\w\,(\intro^\w\,(x^\w\,\gamma^\w)) = \F^\w\,(x^\w\,\gamma^\w) \]
which is an instance of Definition \ref{sec:canonicity-elintro}. We omit describing the other
rules. This concludes the canonicity interpretation of the object theory.
\end{definition}

\subsection{The Canonicity Result}

Now that we have fully defined the $\blank^\w$ interpretation that acts on contexts, types,
subtitutions and terms, we can take any closed term $t : \Tm\,\emptycon\,A$ and get
$t^\w\,\{\id\}\,\ttt : A^\w\,\{\id\}\,\ttt\,t$ as a witness of canonicity for $t$. The most
interesting case is when $A$ is of the form $\IR\,S$.
\begin{example}
Recall $S$ from Example \ref{ex:code-signature}. Assuming $t : \Tm\,\emptycon\,(\IR\,S)$, we have
\begin{alignat*}{3}
  &t^\w\,\{\id\}\,\ttt &&: (\IR\,S)^\w\,\{\id\}\,\ttt\,\,t[\id]\\
  &t^\w\,\{\id\}\,\ttt &&: \IR^\w\,(S^\w\,\ttt)\,t\\
  &t^\w\,\{\id\}\,\ttt &&: \IIR\,(\floord{S^\w\,\ttt}\,\here)\,t.
\end{alignat*}
Note that $(\floord{S^\w\,\ttt}\,\here)$ was previously shown in Example
\ref{ex:code-canonicity-signature}. Now, we can use the metatheoretic $\elim_{\IIR}$ on
$t^\w\,\{\id\}\,\ttt$ to prove that $t$ is either definitionally equal to $\intro\,(\Nat',\,\ttt)$
or to $\intro\,(\Pi',\,A,\,B,\,\ttt)$ for some $A$ and $B$.
\end{example}

\subsection{Algorithm Extraction}

Is our proof constructive and can we extract an evaluation algorithm from it?  We believe that it
would not be difficult to write a program that follows the computation in our construction.  Also,
similar evaluators have been used in Agda and Idris for a while. However, we do not make this
formally precise in this paper, and leave it to potential future work. In short, we see two ways to
establish constructivity.
\begin{itemize}
\item We could exhibit a constructive model of the metatheory. As far as we know, this has not been
  done, since Dybjer and Setzer only developed classical set-theoretical models of IR.
\item We could prove canonicity for the metatheory. To handle the IR types in the metatheory, we can
  reuse the canonicity proof in this paper. However, we would also need to handle the QIIT of the
  object theory, and currently there is no generic canonicity proof for QIITs, and there are also
  some formal gaps in the construction of finitary QIITs from more basic type formers
  \cite{DBLP:journals/corr/abs-2302-08837}.
\end{itemize}

\subsection{Mechanization}\label{sec:canonicity-mechanization}

We formalized the semantic constructions in Sections \ref{sec:ir-signatures-canonicity} and
\ref{sec:ir-canonicity} in Agda, but we did not formalize the object theory nor the contextual
interpretations for its rules. The formalization is roughly 280 lines. Overall, we have found the
Agda formalization to be extremely useful and it was crucial for coming up with the right
definitions in the first place.

We use a \emph{shallow embedding} for closed terms, where we work with the standard $\Set$ model of
the object theory instead of an exact specification of the object syntax.
\begin{itemize}
\item We represent $\Tm\,\U_i$ as $\Set_i$.
\item Given $A : \Tm\,\U_i$, which is represented simply as $A : \Set_i$, we represent $\Tm\,A$ as $A$.
\end{itemize}
In other words, instead of working with sets of closed terms, we work with arbitrary metatheoretical
sets. Hence, the formalization looks like an ``internal'' logical predicate interpretation of IR
types using IIR types, where both IR and IIR types are assumed inside Agda. For example, instead of
having $\Sig_i\,O : \Tm\,\U_{\max(i+1,\,j)}$ and $\Sig^\w\,O^\w : \Tm\,(\Sig_i\,O) \to
\Set_{\max(i+1,\,j)}$, we have $\Sig_i\,O : \Set_{\max(i+1,\,j)}$ and $\Sig^\w\,O^\w : \Sig_i\,O \to
\Set_{\max(i+1,\,j)}$. Clearly, this is not a precise embedding and it is possible to do ``illegal''
constructions.

However, checking the legality of constructions is not difficult, and we only have to check a meager
280 lines. We could have used a more principled representation of closed terms, for example,
following \citet{DBLP:conf/mpc/KaposiKK19} where Agda's module system is used to prevent illegal
constructions. We did not do so, again because of the small size of the project and because the
additional safety features make the ergonomics of Agda somewhat worse. Concretely, we need to check
the following in the formalization.
\begin{enumerate}
\item ``Stage separation'': we cannot eliminate from object types to meta-level types, e.g.\ cannot make a case distinction
      on an object-theoretic term with type $\Bool$ to compute something in the metatheory. Also, we cannot index
      object types by meta-types, or store meta-level data in object-level type or term formers.
\item We can convert from $\Tm\,((a : A) \to B\,a)$ to $(a : \Tm\,A) \to \Tm\,(B\,a)$ but not the other way around.
\end{enumerate}
Additionally, there is a difference in sizing: if $A : \Tm\,\U_i$ then $\Tm\,A : \Set_0$, while
using shallow embedding we have $A : \Set_i$. This does not actually impact the formalization,
because the sizes of $\blank^\w$ results are computed from syntactic levels in any case.

\section{Related Work \& Discussion}

\subsection{Algebraic \& Categorical Metatheory}

In this paper we used a reduction-free algebraic specification of syntax.  This style has become
more widespread in recent years, with normalization proofs for cubical \cite{ctt-normalization} and
multimodal type theories \cite{DBLP:conf/lics/Gratzer22} and a canonicity proof for a type theory
with internal parametricity \cite{altenkirch2024internal}. In all of these cases, an important
motivation is to cut down on boilerplate by working in a setting where syntactic definitional
equalities are respected by all metatheoretic constructions. This is achieved by identifying
object-level conversion with metatheoretic equality. This is convenient as long as we only talk
about properties that are stable under conversion, and canonicity and normalization are such
properties. On the other hand, a) we need a different or more complex setup if we are interested in
conversion-unstable semantics such as cost semantics b) in current proof assistants, it is very
difficult to do complete machine-checked formalizations in the algebraic style, mainly because of
the abundance of type dependencies and propositional equalities, and the resulting deluge of
transports (``transport hell'').

The latter issue is partially addressed by ``shallow embedding'', where we represent the syntax of
the object theory with a chosen \emph{strict model} of the theory, where all equations are
metatheoretic definitional equalities \cite{DBLP:conf/mpc/KaposiKK19}. We use this in Section
\ref{sec:canonicity-mechanization}, pretending that the $\Set$ model of the object theory is the
syntax. Additionally or alternatively, we can cut out more boilerplate by working in a logic where
everything is stable under object-theoretic substitutions or variable renamings. Two frameworks for
this are synthetic Tait computability \cite{sterlingthesis} and internal sconing
\cite{DBLP:conf/fscd/BocquetKS23}. Either would be applicable in our canonicity proof, but our case
is not very technically complicated so we do not think that it is worth to use the heavier machinery.

\subsection{Canonicity (and Parametricity) for Inductive Types}

In the reduction-free algebraic style, \citet{DBLP:journals/pacmpl/Kovacs24} proved conservativity
for a two-level type theory whose outer level supports countable predicative universes with
W-types. This involves a logical relation model which implies canonicity of the outer level as a
corollary. Taken together with Hugunin's construction of (non-indexed) inductive types from W-types
\cite{whynotw}, this yields canonicity for inductive types. In turn, the construction of
indexed inductive types from non-indexed ones seems plausible; it is just a special case of
Section \ref{sec:iir-construction} in the current paper, since IIR is a clear-cut generalization
of inductive families.

Using directed reductions, \citet{DBLP:phd/ethos/Goguen94} proved strong $\beta\eta$-normalization
for a type theory that supports inductive families, one impredicative universe of propositions and one
predicative universe. Canonicity evidently follows from strong normalization. Also,
\citet{DBLP:phd/hal/Werner94} proved strong $\beta\eta$-normalization for a calculus of inductive
constructions with one impredicative and one predicative universe.

Parametric models and translations of inductive types are closely related to our work, which can be
viewed as a specific parametric construction. \citet{bernardy12parametricity} described a
translation from a type theory to itself which interprets types as relations. This is ``binary''
parametricity in contrast to our ``unary'' logical predicates, but switching the arity is fairly
mechanical. They described the interpretation of inductive families as well, although without going
into formal details of signatures. \citet{pedrot2018failure} described a parametric translation for
inductive families as well, which was also implemented as a Rocq plugin. Univalent parametric
translations have also been described for inductive families and implemented in Rocq
\cite{tabareau2018equivalences,tabareau2021marriage,cohen2024trocq}.

\subsection{Induction-Recursion} Our two primary sources throughout the paper are
\cite{DBLP:journals/apal/DybjerS03} and \cite{DBLP:journals/jlp/DybjerS06} for IR and IIR. We include
a bit more general discussion of IR in the following.

First, it is natural to ask if IR types are constructible from a particular ``universal'' IR type,
similarly to how inductive families are constructible from W-types. We might hope that this would
simplify the metatheory of IR. Unfortunately no such type is known. However, \emph{Mahlo universes}
have been studied as relatively simple specifications from which many examples of IR types
are constructible \cite{setzer00mahlo}. An \emph{external Mahlo universe} is specified by the
existence of a particular IR type in the universe. Hence, external Mahlo-ness is implied by IR, but
it is not known if all IR types are constructible in an external Mahlo universe. While working on
this paper, we attempted such a construction but currently we can only conjecture that it is not
possible. \citet{mahlo-canonicity} proved canonicity for external Mahlo universes. This is
essentially a special case of our proof, instantiated to Mahlo sub-universes as an IR type former.

Second, it is worth to note that the investigation of \emph{predicative foundations of mathematics}
has been an important motivation for IR. Indeed, IR is close to the current strength limit of
constructive predicative mathematics. The notion of predicativity is somewhat
subjective, but in one sense a theory is considered predicative if it is amenable to ordinal
analysis. \citet{setzer00mahlo} calculated the strength of Martin-Löf type theory with one external
Mahlo universe. \citet{DBLP:journals/logcom/DybjerS24} investigated the predicativity of Mahlo
universes in the sense of Martin-Löf's ``extended predicativity''. For IR, the exact proof-theoretic
strength is unknown, but it still seems to be in the realm of ordinal analysis, unlike
impredicative foundational systems such as ZFC or Rocq with impredicative $\msf{Prop}$.

\section{Future Work}\label{sec:future-work}

\subsection{Generalizing the Logical Predicate Interpretation} \label{sec:generalizing-the-logical-predicate}

We describe two ways in which our logical predicate interpretation could be reformulated.

First, as a \emph{syntactic translation} from a type theory that supports IR types to another one
(possibly the same theory); see e.g.\ \citet{next700} and \citet{bernardy12parametricity}. Syntactic
translations require that definitional equations in the source language are mapped to definitional
equations in the target language. In our current construction, this does not hold, because neutral
signatures block $\Elintro$ and $\elimbeta$. We could fix this by switching to second-class
signatures. That is, we would specify a \emph{sort} of signatures instead of a type of signatures,
disallowing computation of signatures by elimination and thereby ruling out neutral signatures. The
resulting syntactic translation could be extended to a \emph{univalent parametricity} translation.
Univalent parametricity translations have numerous practical use cases, and are currently
implemented in a Rocq plugin called Trocq \cite{cohen2024trocq}, but without IR types, since Rocq
does not support IR.


Second, as a \emph{model construction} which extends type-theoretic gluing with IR types. This
generalizes the previously described syntactic translation. In this case, we need to further
restrict signatures. In the previous syntactic translation, signatures are part of the object
theory, and in the initial model (i.e.\ the syntax) we can do induction on them. But in an arbitrary
model we cannot do such induction. Therefore, we modify the theory, so that each IR signature has
an ``arity'' or ``shape'', as a piece of metatheoretical data which specifies the number of
constructors and their fields (but not the types of fields). This lets us do induction on shapes of
signatures in arbitrary models. This is a bit similar to \emph{contextuality} of models of type
theories, where we require that typing contexts are inductively generated by context extensions
\cite{gat,cwfs}.

\subsection{Normalization for IR Types}

Showing normalization for IR types is the natural upgrade to our canonicity result. This entails
computing \emph{open} terms to normal forms. Normalization is one way to get decidability of
conversion for the object theory, although we could aim directly for decidable conversion as well.
Decidable conversion is required for decidable type checking, so its metatheoretical value is quite
obvious.

For normalization, we expect that the easiest way is again to extend previous formalizations for
Martin-Löf type theory, still in the algebraic style
\cite{DBLP:journals/lmcs/AltenkirchK17,coquand2018canonicity,sterlingthesis,DBLP:conf/fscd/BocquetKS23}. This
is significantly more complicated than canonicity. The general strategy is to define logical
predicates internally to presheaves over syntactic variable renamings, to abstract away the details
of stability under renaming. Like in the current paper, we would need to compute an IIR predicate
for each IR signature, but we would need to handle neutral signatures and terms in addition. Note
that the IIR predicates would be \emph{internal to presheaves}. So first we would need to
construct presheaf models of IR types. This task already seems to be a bit more complicated than the
canonicity construction in the current paper. Nevertheless, it seems to be manageable and we believe
that it would be worth to pursue this line of research.

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
