
%% build: latexmk -pdf -pvc paper.tex

\documentclass[acmsmall,screen,review,anonymous]{acmart}
%% \documentclass[nonacm,acmsmall]{acmart}
%% \documentclass[acmsmall]{acmart}
%% \raggedbottom

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.newcomm  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%% --------------------------------------------------------------------------------

\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
\usepackage{bm}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage[title]{appendix}

\newcommand{\mit}[1]{{\mathsf{#1}}}
\newcommand{\msf}[1]{{\mathsf{#1}}}
\newcommand{\mbf}[1]{{\mathbf{#1}}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}
\newcommand{\data}{\mbf{data}}
\newcommand{\U}{\msf{U}}
\newcommand{\Set}{\msf{Set}}
\newcommand{\where}{\mbf{where}}
\newcommand{\Nat}{\msf{Nat}}
\newcommand{\zero}{\msf{zero}}
\newcommand{\suc}{\msf{suc}}
\newcommand{\Nil}{\msf{Nil}}
\newcommand{\Cons}{\msf{Cons}}
\newcommand{\El}{\msf{El}}
\newcommand{\Lift}{\msf{Lift}}
\newcommand{\lup}{\uparrow}
\newcommand{\ldown}{\downarrow}
\newcommand{\Sig}{\msf{Sig}}
\newcommand{\Code}{\msf{Code}}
\newcommand{\Tag}{\msf{Tag}}
\newcommand{\case}{\mbf{case}}
\newcommand{\of}{\mbf{of}}
\newcommand{\ttt}{\msf{tt}}
\newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}
\newcommand{\ir}{{ir}}
\newcommand{\el}{{el}}
\newcommand{\ix}{{ix}}
\newcommand{\IR}{\msf{IR}}
\newcommand{\ih}{{ih}}
\newcommand{\intro}{\msf{intro}}
\newcommand{\IH}{\msf{IH}}
\newcommand{\map}{\msf{map}}
\newcommand{\elim}{\msf{elim}}
\newcommand{\inj}{\msf{inj}}
\newcommand{\tr}{\msf{tr}}
\newcommand{\fst}{\msf{fst}}
\newcommand{\snd}{\msf{snd}}
\newcommand{\IIR}{\msf{IIR}}
\newcommand{\Sigr}[1]{\lfloor #1 \rfloor}
\newcommand{\floord}[1]{\lfloor #1 \rfloor}
\newcommand{\ora}[1]{\overrightarrow{#1}}
\newcommand{\ola}[1]{\overleftarrow{#1}}
\newcommand{\ap}{\msf{ap}}
\newcommand{\Bool}{\msf{Bool}}
\newcommand{\Level}{\msf{Level}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\id}{\msf{id}}

\newcommand{\Con}{\msf{Con}}
\newcommand{\Sub}{\msf{Sub}}
\newcommand{\Ty}{\msf{Ty}}
\newcommand{\Tm}{\msf{Tm}}
\newcommand{\ext}{\triangleright}
\newcommand{\w}{\bullet}
\newcommand{\lam}{\msf{lam}}
\newcommand{\app}{\msf{app}}
\newcommand{\bapp}{\$}
\newcommand{\proj}{\msf{proj}}
\newcommand{\exfalso}{\msf{exfalso}}
\newcommand{\true}{\msf{true}}
\newcommand{\false}{\msf{false}}
\newcommand{\BoolElim}{\msf{BoolElim}}
\newcommand{\fun}{\Rightarrow}
\newcommand{\SigElim}{\msf{SigElim}}
\newcommand{\Id}{\msf{Id}}
\newcommand{\refl}{\msf{refl}}
\newcommand{\J}{\msf{J}}


%% --------------------------------------------------------------------------------

%%
%% end of the preamble, start of the body of the document source.
%% \hypersetup{draft}
\begin{document}


\title{Canonicity for Indexed Inductive-Recursive Types}

\author{András Kovács}
\orcid{0000-0002-6375-9781}
\affiliation{%
  \institution{University of Gothenburg \& Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}
\email{andrask@chalmers.se}


\begin{abstract}
We prove canonicity for a Martin-Löf type theory that supports a countable universe hierarchy where
each universe supports indexed inductive-recursive (IIR) types. We proceed in two steps. First, we
construct IIR types from inductive-recursive (IR) types and other basic type formers, in order to
simplify the subsequent canonicity proof. The constructed IIR types support the same definitional
computation rules that are available in Agda's native IIR implementation. Second, we give a
canonicity proof for IR types, building on the well-known method of Artin gluing. The main idea is
to encode the reducibility predicate for each IR type using a metatheoretic IIR type.
\end{abstract}

%% \begin{CCSXML}
%% \end{CCSXML}
%% \ccsdesc[500]{Theory of computation~Type theory}
%% \ccsdesc[500]{Software and its engineering~Source code generation}
%% \keywords{}

\maketitle

\section{Introduction}\label{sec:introduction}

Induction-recursion (IR) was first used by Martin-Löf in an informal way \cite{TODO}, then made
formal by Dybjer and Setzer \cite{TODO}, who also developed set-theoretic and categorical semantics
\cite{TODO}. A common application of IR is to define custom universe hierarchies inside a type
theory. In the proof assistant Agda, we can use IR to define a universe that is closed under our
choice of type formers:
\begin{alignat*}{3}
  & \mbf{mutual} \\
  & \quad\data\,\Code : \Set_0\,\where \\
  & \quad\quad \Nat' : \U\\
  & \quad\quad \Pi' \hspace{0.8em} : (A : \Code) \to (\El\,A \to \Code) \to \Code
  & \\
  & \\
  & \quad\El : \Code \to \Set_0 \\
  & \quad\El\,\Nat'\hspace{1.5em}  = \Nat \\
  & \quad\El\,(\Pi'\,A\,B) = (a : \El\,A) \to \El\,(B\,a)
\end{alignat*}
Here, $\Code$ is a type of codes of types which behaves as a custom Tarski-style universe. This
universe, unlike the ambient $\Set_0$ universe, supports an induction principle and can be used to
define type-generic functions. \emph{Indexed induction-recursion} (IIR) additionally allows indexing
$\Code$ over some type, which lets us define inductive-recursive predicates \cite{TODO}.

One application of IR has been to develop semantics for object theories that support universe
hierarchies. IR has been used in normalization proofs \cite{TODO}, in modeling first-class universe
levels \cite{TODO} and proving canonicity for them \cite{TODO}, and in characterizing domains of
partial functions \cite{TODO}. Another application is to do generic programming over universes of
type descriptions \cite{TODO} or data layout descriptions \cite{TODO}.

IIR has been supported in Agda 2 since the early days of the system \cite{TODO}, and it is also
available in Idris 1 and Idris 2 \cite{TODO}. In these systems, IR has been implemented in the
``obvious'' way, supporting closed program execution in compiler backends and normalization during
type checking, but without any formal justification.

Our \textbf{main contribution} is to \textbf{show canonicity} for a Martin-Löf type theory that
supports a countable universe hierarchy, where each universe supports indexed inductive-recursive
types. Canonicity means that every closed term is definitionally equal to a canonical
term. Canonical terms are built only from constructors; for instance, a canonical natural number
term is a numeral. Hence, canonicity justifies evaluation for closed terms. The outline of our
development is as follows.

\begin{enumerate}
\item In Section \ref{TODO} we specify what it means to support IR and IIR, using Dybjer and
  Setzer's rules with minor modifications \cite{TODO}. We use first-class signatures,
  meaning that descriptions of (I)IR types are given as ordinary inductive types internally.
\item In Section \ref{TODO} we construct IIR types from IR types and other basic type formers. This
  allows us to only consider IR types in the subsequent canonicity proof, which is a significant
  simplification. In the construction of IIR types, we lose some definitional equalities when IIR
  signatures are neutral, but we still get the same computation rules that are available for Agda and
  Idris' IIR types. We formalize the construction in Agda.
\item In Section \ref{TODO}, we give a proof-relevant logical predicate interpretation of the type
  theory, from which canonicity follows. We build on the well-known method of Artin gluing
  \cite{TODO}. The main challenge here is to give a logical predicate interpretation of IR types. We
  do this by using IIR in the metatheory: from each object-theoretic signature we compute a
  metatheoretic IIR signature which encodes the canonicity predicate for the corresponding IR type.
  We formalize the predicate interpretation of IR types in Agda, using a shallow embedding of the
  syntax of the object theory. Hence, there is a gap between the Agda version and the fully formal
  construction, but we argue that it is a modest gap.
\end{enumerate}

\section{Specification for (I)IR Types}\label{sec:specification}

In this section we describe the object type theory, focusing on the specification of IR and IIR
types. We do not yet go into the formal details; instead, we shall mostly work with internal
definitions in an Agda-like syntax. In Section \ref{TODO} we will give a rigorous specification that
is based on categories-with-families.

\paragraph{Basic type formers}
We have a countable hierarchy of Russell-style universes, written as $\U_i$, where $i$ is an
external natural number. We have $\U_i : \U_{i + 1}$. We have $\Pi$-types as $(x : A) \to B\,x$,
which has type $\U_{\max(i,\,j)}$ when $A : \U_i$ and $B : A \to \U_j$. We use Agda-style implicit
function types for convenience, as $\{x : A\} \to B\,x$, to mark that a function argument should be
inferred from context. We have $\Sigma$-types, written as $(x : A) \times B\,x$, which also has type
$\U_{\max(i,\,j)}$. We have $\bot : \U_0$ for the empty type. We have $\top : \U_i$ for every $i$
level, with unique inhabitant $\ttt$. We have $\Bool : \U_0$ for Booleans. We have intensional
identity types, as $t = u : \U_i$ for $t : A : \U_i$, with a transport operation $\tr : \{A :
\U_i\}(P : A \to \U_j)\{x\,y : A\} \to x = y \to P\,x \to P\,y$. We will also sometimes use the
path application operation $\ap : (f : A \to B) \to x = y \to f\,x = f\,y$.

We note some derivable type formers. First, finite sum types are derivable from $\bot$, $\Sigma$,
$\Bool$ and large elimination on $\Bool$. They are useful as ``constructor tags'' in
inductive definitions. Second, we can define a universe lifting operation $\Lift : \U_i \to
\U_{\max(i,\,j)}$ such that $\Lift\,A$ is definitionally isomorphic to $A$, by setting $\Lift\,A$
to $A \times \top_j$. We write the wrapping operation as $\lup\,:\,A \to \Lift\,A$ with inverse $\ldown$.

We write $\blank\!\!\equiv\!\!\blank$ for definitional equality, and give definitions using $:\equiv$.

\subsection{IR Types}
The object theory additionally supports inductive-recursive types. On a high level, the specification consists
of the following.
\begin{enumerate}
\item A type of signatures. Each signature describes an IR type. Also, we internally define some
  functions on signatures which are required in the specification of other rules.
\item Rules for type formation, term formation and the recursive function, with a computation rule
  for the recursive function.
\item The induction principle with a $\beta$ rule.
\end{enumerate}

\subsubsection{IR signatures}\label{sec:ir-signatures}
Signatures are parameterized by the following data:
\begin{itemize}
\item The level $i$ is the size of the IR type that is being specified.
\item The level $j$ is the size of the recursive output type.
\item $O : \U_j$ is the output type.
\end{itemize}
IR signatures are specified by the following inductive type. We only mark $i$ and $O$ as parameters to $\Sig$,
since $j$ is inferable from $O$.
\begin{alignat*}{4}
  &\data\, \Sig_i\,O : \U_{\max(i+1,\,j)}\,\where\\
  &\quad \iota\hspace{0.25em}  : O \to \Sig_i\,O \\
  &\quad \sigma               : (A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O \\
  &\quad \delta\hspace{0.1em} : (A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O
\end{alignat*}
Formally, we can view $\Sig$ in two ways. We can either view it as just a particular family of $\msf{W}$-types,
or as an inductive type that is primitively part of the object theory. The choice is not important, since inductive
families are constructible from $\msf{W}$-types \cite{whynotw}.

\begin{example}
We can reproduce the Agda example from Figure \cite{TODO}. First, we need an enumeration type to
represent the constructor labels of $\Code$. We assume this as $\Tag : \U_0$ with constructors
$\Nat'$ and $\Pi'$, and we use an informal case splitting operation for it. We also assume $\Nat :
\U_0$ for natural numbers and a right-associative $\blank\!\$\!\blank$ operator for function application.
\begin{alignat*}{4}
  & S : \Sig_0\,\U_0\\
  & S :\equiv \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nat' \to \iota\,\Nat \\
  & \quad \Pi'\hspace{0.85em} \to \delta\,\top\,\$\,\lambda\,{ElA}.\, \delta\,({ElA}\,\ttt)\,\$\,\lambda\,{ElB}.\,
      \iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)
\end{alignat*}
First, we introduce a choice between two constructors by $\sigma\,\Tag$. In the $\Nat'$ branch, we
specify that the recursive function maps the constructor to $\Nat$. In the $\Pi'$ branch, we first
introduce a single inductive constructor field by $\delta\,\top$, where $\top$ represents the number
of introduced fields. The naming of the freshly bound variable ${ElA}$ is meant to suggest that it
represent the recursive function's output for the inductive field. It has type $\top \to \U_0$.
Next, we introduce $({ElA}\,\ttt)$-many inductive fields, and bind ${ElB} : {ElA}\,\ttt \to \U_0$ to
represent the corresponding recursive output. Finally, $\iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)$
specifies the output of the recursive function for a $\Pi'$ constructor.
\end{example}

Our signatures are identical to Dybjer and Setzer's \cite{TODO}, except for one difference.  We have
countable universe levels, while Dybjer and Setzer use a logical framework presentation with only
three universes, $\msf{set}$, $\msf{stype}$ and $\msf{type}$, where $\msf{set}$ contains the
inductively specified type, $\msf{stype}$ contains the non-inductive constructor arguments and
$\msf{type}$ contains the recursive output type and the type of signatures.

\subsubsection{Type and term formation}\label{sec:ir-type-and-term-formation}

In this section we also follow Dybjer and Setzer \cite{TODO}, with minor differences of notation, and
also accounting for the refinement of universe levels.

First, assuming $i$ and $O : \U_j$, a signature $S : \Sig_i\,O$ can be interpreted as a function
from $(A : \U_i) \times (A \to O)$ to $(A : \U_i) \times (A \to O)$. This can be extended to an
endofunctor on the slice category $\U_i/O$, but in the following we only need the action on
objects. We split this action to two functions, to aid readability:
\begin{alignat*}{3}
  &\rlap{$\blank_0 : \Sig_i\,O \to (\ir : \U_i) \to (\ir \to O) \to \U_i$} \\
  &S_0\,(\iota\,o)    \,&&\ir\,\el && \hspace{-0.7em}:\equiv \Lift\,\top\\
  &S_0\,(\sigma\,A\,S)\,&&\ir\,\el && \hspace{-0.7em}:\equiv (a : A) \times (S\,a)_0\,\ir\,\el\\
  &S_0\,(\delta\,A\,S)\,&&\ir\,\el && \hspace{-0.7em}:\equiv (f : A \to \ir) \times (S\,(\el \circ f))_0\,\ir\,\el\\
  & && &&\\
  &\rlap{$\blank_1 : (S : \Sig_i\,O) \to S_0\,\ir\,\el \to O$} \\
  &S_1\,(\iota\,o)    \,&&x       && :\equiv o\\
  &S_1\,(\sigma\,A\,S)\,&&(a,\,x) && :\equiv (S\,i)_1\,x\\
  &S_1\,(\delta\,A\,S)\,&&(f,\,x) && :\equiv (S\,(\el \circ f))_1\,x
\end{alignat*}
Although we use Agda-like pattern matching notation above, these functions are formally defined by
the elimination principle of $\Sig$. Also note the quantification of the $i$ and $j$ universe
levels. The object theory does not support universe polymorphism, so this quantification is
understood to happen in the metatheory. The introduction rules are the following.
\begin{alignat*}{3}
  &\IR                && : (S : \Sig_i\,O) \to \U_i\\
  &\El                && : \IR\,S \to O\\
  &\intro             && : S_0\,(\IR\,S)\,\El \to \IR\,S\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x
\end{alignat*}
Above, we leave some rule arguments implicit, like $S$ in $\El$, $\intro$ and
$\msf{El\!\!-\!\!intro}$. The rule $\msf{El\!\!-\!\!intro}$ specifies a definitional equality.  Note
that these rules are not internal definitions but part of the specification of the object
theory. Hence, they are also assumed to be stable under object-theoretic substitution, formally
speaking. On a high level, the introduction rules express the existence of an $S$-algebra where we
view $S$ as an endofunctor on $\U_i/O$.

\subsubsection{Elimination}\label{sec:ir-elimination}

Here we follow the specification in \cite{TODO}. We assume another universe level $k$ that specifies
the size of the type into which we eliminate. We define two additional functions on signatures:
\begin{alignat*}{3}
  &\rlap{$\blank_\IH : (S : \Sig_i\,O)(P : \ir \to \U_k) \to S_0\,\ir\,\el \to \U_{\max(i,\,k)}$} \\
  &(\iota\,o)_\IH    \,&&P\,x       &&:\equiv \Lift\,\top \\
  &(\sigma\,A\,S)_\IH\,&&P\,(a,\,x) &&:\equiv (S\,a)_\IH\,P\,x \\
  &(\delta\,A\,S)_\IH\,&&P\,(f,\,x) &&:\equiv ((a : A) \to P\,(f\,a)) \times (S\,(\el \circ f))_\IH\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-7em}\rlap{$\blank_\map : (S : \Sig_i\,O)(P : \ir \to \U_k) \to ((x : \ir) \to P\,x) \to (x : S_0\,\ir\,\el) \to S_\IH\,P\,x$} \\
  &\hspace{-7em}(\iota\,o)_\map    \,&&P\,h\,x       &&:\equiv\,\lup\!\ttt \\
  &\hspace{-7em}(\sigma\,A\,S)_\map\,&&P\,h\,(a,\,x) &&:\equiv (S\,a)_\map\,P\,h\,x \\
  &\hspace{-7em}(\delta\,A\,S)_\map\,&&P\,h\,(f,\,x) &&:\equiv (h \circ f,\,(S\,(\el \circ f))_\map\,P\,h\,x)
\end{alignat*}
$\blank_\IH$ stands for ``induction hypothesis'': it specifies having a witness of a predicate $P$ for
each inductive field in a value of $S_0\,\ir\,\el$. $S_\map$ maps over $S_0\,\ir\,\el$, applying the
section $h : (x : \ir) \to P\,x$ to each inductive field. Elimination is specified as follows.
\begin{alignat*}{3}
  &\elim           &&: (P : \IR\,S \to \U_k) \to ((x : S_0\,(\IR\,S)\,\El) \to S_\IH\,P\,x \to P\,(\intro\,x)) \to (x : \IR\,S) \to P\,x \\
  &\elim\!-\!\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x)
\end{alignat*}
If we have function extensionality, this specification of elimination can be shown to be equivalent
to the initiality of $(\IR\,S,\,\El)$ as an $S$-algebra \cite{TODO}.

\subsection{IIR Types}\label{sec:iir}

We extend Dybjer and Setzer's general IIR signatures \cite{TODO} with countable universe levels. Since
IIR is quite similar to IR, we present the rules without much commentary.

\subsubsection{Signatures}\label{sec:iir-signatures} We assume levels $i$, $j$, $k$, an indexing type $I : \U_k$ and a type family
for the recursive output as $O : I \to \U_j$. Signatures are as follows.
\begin{alignat*}{4}
  &\data\, \Sig_i\,I\,O : \U_{\max(i+1,\,j,\,k)}\,\where\\
  &\quad \iota\hspace{0.25em}  : (i : I) \to O\,i \to \Sig_i\,I\,O \\
  &\quad \sigma                : (A : \U_i) \to (A \to \Sig_i\,I\,O) \to \Sig_i\,I\,O \\
  &\quad \delta\hspace{0.1em}  : (A : \U_i)(\ix : A \to I) \to (((a : A) \to O\,(\ix\,a)) \to \Sig_i\,I\,O) \to \Sig_i\,I\,O
\end{alignat*}

\begin{example} We reproduce length-indexed vectors as an IIR type. We assume $A : \U_0$ for a type of elements in the vector,
and a type $\Tag : \U_0$ with inhabitants $\Nil'$ and $\Cons'$.
\begin{alignat*}{4}
  & S : \Sig_0\,\Nat\,(\lambda\,\_.\,\top)\\
  & S :\equiv \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nil'\hspace{0.85em} \to \iota\,\zero\,\ttt \\
  & \quad \Cons'\to \sigma\,\Nat\,\$\,\lambda\,n.\,\sigma\,A\,\$\,\lambda\,\_.\,\delta\,\top\,(\lambda\,\_.\,n)\,\$\,\lambda\,\_.\,\iota\,(\suc\,n)\,\ttt
\end{alignat*}
We set $O$ to be constant $\top$ because vectors do not have an associated recursive function. In
the $\Nil'$ case, we simply set the constructor index to $\zero$. In the $\Cons'$ case, we introduce
a non-inductive field, binding $n$ for the length of the tail of the vector. Then, when we introduce
the inductive field using $\delta$, we use $(\lambda\,\_.\,n)$ to specify that the length of the
(single) inductive field is indeed $n$. Finally, the length of the $\Cons'$ constructor is $\suc\,n$.
\end{example}

\subsubsection{Type and term formation}\label{sec:iir-type-and-term-formation}
The signature actions $\blank_0$ and $\blank_1$ are similar to before:
\begin{alignat*}{4}
  &\hspace{-6em}\rlap{$\blank_0 : \Sig_i\,I\,O \to (\ir : I \to \U_{\max(i,\,k)}) \to (\{i : I\} \to \ir\,i \to O\,i) \to I \to \U_{\max(i,\,k)}$} \\
  &\hspace{-6em}S_0\,(\iota\,i'\,o)     \,&&\ir\,\el\,i && :\equiv \Lift\,(i' = i)\\
  &\hspace{-6em}S_0\,(\sigma\,A\,S)     \,&&\ir\,\el\,i && :\equiv (a : A) \times (S\,a)_0\,\ir\,\el\,i\\
  &\hspace{-6em}S_0\,(\delta\,A\,\ix\,S)\,&&\ir\,\el\,i && :
                     \equiv (f : (a : A) \to \ir\,(\ix\,a)) \times (S\,(\el \circ f))_0\,\ir\,\el\,i\\
  &\hspace{-6em} && &&\\
  &\hspace{-6em}\rlap{$\blank_1 : (S : \Sig_i\,I\,O) \to S_0\,\ir\,\el\,i \to O\,i$} \\
  &\hspace{-6em}S_1\,(\iota\,i'\,o)\,&&\hspace{-0.8em}(\lup x) && \hspace{-0.6em}:\equiv \tr\,O\,x\,o\\
  &\hspace{-6em}S_1\,(\sigma\,A\,S)\,&&\hspace{-0.8em}(a,\,x)  && \hspace{-0.6em}:\equiv (S\,i)_1\,x\\
  &\hspace{-6em}S_1\,(\delta\,A\,S)\,&&\hspace{-0.8em}(f,\,x)  && \hspace{-0.6em}:\equiv (S\,(\el \circ f))_1\,x
\end{alignat*}
Note the transport in $\tr\,O\,x\,o$: this is necessary, since $o$ has type $O\,i'$ while the
required type is $O\,i$. The type and term formation rules are the following.
\begin{alignat*}{4}
  &\IIR               && : (S : \Sig_i\,I\,O) \to I \to \U_{\max(i,\,k)}\\
  &\El                && : \IIR\,S\,i \to O\,i\\
  &\intro             && : S_0\,(\IIR\,S)\,\El\,i \to \IIR\,S\,i\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x
\end{alignat*}
\subsubsection{Elimination}\label{sec:iir-elimination} $\blank_\IH$, $\blank_\map$ and elimination are
as follows. We assume a level $l$ for the target type of elimination.
\begin{alignat*}{3}
  &\rlap{$\blank_\IH : (S : \Sig_i\,I\,O)(P : \{i : I\}\to \ir\,i \to \U_l) \to S_0\,\ir\,\el\,i \to \U_{\max(i,\,l)}$} \\
  &(\iota\,i\,o)_\IH \,&&P\,x       &&:\equiv \Lift\,\top \\
  &(\sigma\,A\,S)_\IH\,&&P\,(a,\,x) &&:\equiv (S\,a)_\IH\,P\,x \\
  &(\delta\,A\,\ix\,S)_\IH\,&&P\,(f,\,x) &&:\equiv ((a : A) \to P\,(f\,a)) \times (S\,(\el \circ f))_\IH\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-3em}\rlap{$\blank_\map : (S : \Sig_i\,I\,O)(P : \{i : I\}\to \ir\,i \to \U_l)$}\\
  &\hspace{-3em}\rlap{$\hspace{3em}\to (\{i : I\}(x : \ir\,i) \to P\,x) \to (x : S_0\,\ir\,\el\,i) \to S_\IH\,P\,x$} \\
  &\hspace{-3em}(\iota\,o)_\map    \,&&P\,h\,x       &&:\equiv\,\lup\!\ttt \\
  &\hspace{-3em}(\sigma\,A\,S)_\map\,&&P\,h\,(a,\,x) &&:\equiv (S\,a)_\map\,P\,h\,x \\
  &\hspace{-3em}(\delta\,A\,S)_\map\,&&P\,h\,(f,\,x) &&:\equiv (h \circ f,\,(S\,(\el \circ f))_\map\,P\,h\,x)
\end{alignat*}
\begin{alignat*}{3}
  &\elim           &&: (P : \{i : I\}\to \IIR\,S\,i \to \U_l) \to (\{i : I\}(x : S_0\,(\IIR\,S)\,\El\,i) \to S_\IH\,P\,x \to P\,(\intro\,x))\\
  &                && \hspace{0.7em}\to (x : \IIR\,S\,i) \to P\,x \\
  &\elim\!-\!\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x)
\end{alignat*}

\section{Construction of IIR Types}

We proceed to construct IIR types from IR types and other basic type formers. We assume $i$, $j$,
$k$, $I : \U_k$ and $O : I \to \U_j$, and also assume definitions for IIR signatures and the four
operations ($\blank_0$, $\blank_1$, $\blank_\IH$, $\blank_\map$). The task is to define $\IR$,
$\El$, $\elim$ and $\elim\!-\!\!\beta$. We use some abbreviations in the following:
\begin{itemize}
\item $\Sig_\IIR$ abbreviates the IIR signature type $\Sig_i\,I\,O$.
\item $\Sig_\IR$ abbreviates the IR signature type $\Sig_{\max(i,\,k)}\,((i : I) \times O\,i)$.
\end{itemize}
In a nutshell, the main idea in this section is to represent IIR signatures as IR signatures
together with a well-indexing predicate on algebras. First, we define the encoding function for
signatures:
\begin{alignat*}{4}
  & \rlap{$\Sigr{\blank} : \Sig_\IIR \to \Sig_\IR$}\\
  & \Sigr{\iota\,i\,o}       &&:\equiv \hspace{0.5em} &&\iota\,(i,\,o)\\
  & \Sigr{\sigma\,A\,S}      &&:\equiv \hspace{0.5em} &&\sigma\,(\Lift\,A)\,(\lambda\,a.\,\Sigr{S\,\ldown\!a})\\
  & \Sigr{\delta\,A\,\ix\,S} &&:\equiv \hspace{0.5em} &&\delta\,(\Lift\,A)\,\$\,\lambda\,f.\\
  &  &&                                &&\sigma\,((a : A) \to \fst\,(f\,(\lup\!a)) = \ix\,a)\,\$\,\lambda\,p.\\
  &  &&                                &&\Sigr{S\,(\lambda\,a.\,\tr\,O\,(p\,a)\,(\snd\,(f\,(\lup\! a))))}
\end{alignat*}
There are two points of interest. First, the encoded IR signature has the recursive output type $(i
: I) \times O\,i$, which lets us interpret $\iota\,i\,o$ as $\iota\,(i,\,o)$. Second, in the
interpretation of $\delta$, we already need to enforce well-indexing for inductive fields, or else
we cannot recursively proceed with the translation. We solve this by adding an \emph{extra field} in
the output signature, which contains a well-indexing witness of type $((a : A) \to \fst\,(f\,(\lup\!a)) = \ix\,a)$.
This lets us continue the translation for $S$, by fixing up the return type of $f$ by a transport.

\emph{Note on prior work.} Hancock et al.\ described the same translation from small IIR
signatures to small IR signatures \cite{TODO}. However, they did not present anything more about the
reduction of IIR types to IR types.

\subsection{Type and Term Formers} We can already define the $\IIR$ and $\El$ rules for IIR types. Since the encoding of signatures
already ensures the well-indexing of inductive fields in constructors, it only remains to ensure
that the ``top-level'' index matches the externally supplied index.
\begin{alignat*}{3}
  &\IIR : \Sig_\IIR \to I \to \U_{\max(i,\,k)}                         && \El : \IIR\,S\,i \to O\,i \\
  &\IIR\,S\,i :\equiv (x : \IR\,\Sigr{S}) \times \fst\,(\El\,x) = i \hspace{3em}&& \El\,(x,\,p) :\equiv \tr\,O\,p\,(\snd\,(\El\,x))
\end{alignat*}
The following shorthand describes the data that we get when we peel off an $\intro$ from an $\IIR\,S\,i$ value:
\begin{alignat*}{4}
  &\blank_{\floord{0}} : (S : \Sig_\IR) \to I \to \U_{\max(i,\,k)}\\
  &S_{\floord{0}}\,i :\equiv (x : \floord{S}_0\,(\IR\,S)\,\El) \times \fst\,(S_1\,x) = i
\end{alignat*}
Now, we can show that $S_{\floord{0}}\,i$ is equivalent to $S_0\,(\IIR\,S)\,\El\,i$, by induction on
$S$. The induction is straightforward and we omit it here. We name the components of the equivalence
as follows:
\begin{alignat*}{4}
  &\ora{S_0} &&: S_0\,(\IIR\,S)\,\El\,i \to S_{\floord{0}}\,i \\
  &\ola{S_0} &&: S_{\floord{0}}\,i \to S_0\,(\IIR\,S)\,\El\,i \\
  &\eta      &&: \forall x.\,\,\ola{S_0}\,(\ora{S_0}\,x) = x \\
  &\epsilon  &&: \forall x.\,\,\ora{S_0}\,(\ola{S_0}\,x) = x \\
  &\tau      &&: \forall x.\,\,\ap\,\ora{S_0}\,(\eta\,x) = \epsilon\,(\ola{S_0}\,x)
\end{alignat*}
This is a half adjoint equivalence \cite{TODO}. The half adjoint coherence witness $\tau$ will be
necessary shortly for rearranging some transports.\footnote{In the Agda formalization, we
compute $\tau$ by induction on $S$, although it could also be generically recovered from the other
four components \cite{TODO}.} Next, we show that the two $\blank_1$ operations are the same, modulo
the previous equivalence, again by induction on IIR signatures.
\[\blank_{\floord{1}} : (S : \Sig_\IIR)(x : S_0\,(\IIR\,S)\,\El\,i) \to \tr\,O\,(\snd\,(\ora{S_0}\,x))\,(\snd\,(\floord{S}_1\,(\fst\,(\ora{S_0}\,x)))) = S_1\,x\]
This lets us define the other introduction rules as well.
\begin{alignat*}{3}
  &\intro    : S_0\,(\IIR\,S)\,\El\,i \to \IIR\,S\,i && \msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x \\
  &\intro\,x :\equiv (\intro_\IR\,(\fst\,(\ora{S_0}\,x)),\,\snd\,(\ora{S_0}\,x)) \quad\quad\quad&& \msf{El\!\!-\!\!intro} && :\equiv S_{\floord{1}}\,x
\end{alignat*}

\subsection{Elimination}

We assume a level $l$ for the elimination target. Recall the type of $\elim$:
\begin{alignat*}{3}
  &\elim :\,           &&(P : \{i : I\}\to \IIR\,S\,i \to \U_l)\\
  &                \quad\to && (f : \{i : I\}(x : S_0\,(\IIR\,S)\,\El\,i) \to S_\IH\,P\,x \to P\,(\intro\,x))\\
  &                \quad\to && (x : \IIR\,S\,i) \to P\,x
\end{alignat*}
Also recall that $x : \IIR\,S\,i$ is given as a pair of some $x : \IR\,\Sigr{S}$ and $p : \fst\,(\El\,x) = i$.
The idea here is to use IR elimination on $x : \IR\,\floord{S}$, while adjusting both $P$ and $f$ to operate
on the appropriate data. We will use the following induction motive. Note that we generalize the induction goal
over the $p$ witness.
\begin{alignat*}{3}
  &\floord{P} : \IR\,\floord{S} \to \U_{\max(k,\,l)} \\
  &\floord{P}\,x :\equiv \{i : I\}(p : \fst\,(\El\,x) = i) \to P\,(x,\,p)
\end{alignat*}
Now, we have
\begin{alignat*}{3}
  & \elim_\IR\,\floord{P} : ((x : \floord{S}_0\,(\IR\,\floord{S})\,\El) \to \floord{S}_\IH\,\floord{P}\,x \to \floord{P}\,(\intro\,x))
       \to (x : \IR\,\floord{S}) \to \floord{P}\,x.
\end{alignat*}
We adjust $f$ to obtain the next argument to $\elim_\IR\,\floord{P}$. $f$ takes $S_\IH\,P\,x$ as input,
so we need a ``backwards'' conversion:
\begin{alignat*}{3}
  & \ola{S_\IH} : \{x : S_{\floord{0}}\,i\} \to \floord{S}_\IH\,\floord{P}\,(\fst\,x) \to S_\IH\,P\,(\ola{S_0}\,x)
\end{alignat*}
This is again defined by easy induction on $S$. The induction method $\floord{f}$ is as follows.
\begin{alignat*}{3}
  &\floord{f} : (x : \floord{S}_0\,(\IR\,\floord{S})\,\El) \to \floord{S}_\IH\,\floord{P}\,x \to \floord{P}\,(\intro\,x)\\
  &\floord{f}\,x\,\ih\,p :\equiv \tr\,\bigl(\lambda\,(x,\,p).\,P\,(\intro\,x,\,p)\bigr)\,\bigl(\epsilon\,(x,\,p)\bigr)\,
                                      \bigl(f\,(\ola{S_0}\,(x,\,p))\,(\ola{S_\IH}\,\ih)\bigr)
\end{alignat*}
Thus, the definition of elimination is:
\[ \elim\,P\,f\,(x,\,p) :\equiv \elim_\IR\,\floord{P}\,\floord{f}\,x\,p \]
Only the $\beta$-rule remains:
\[ \elim\!-\!\!\beta : \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x) \]
Computing definitions on the \textbf{left hand side}, we get:
\begin{alignat*}{3}
  & \tr\, &&(\lambda\,(x,\,p).\,P\,(\intro\,x,\,p))\\
  &       &&(\epsilon\,(\ora{S_0}\,x))\\
  &       &&(f\,(\ola{S_0}\,(\ora{S_0}\,x))\,(\ola{S_\IH}\,(\floord{S}_\map\,\floord{P}\,(\lambda\,x\,p.\,\elim\,P\,f\,(x,\,p))\,(\fst\,(\ora{S_0}\,x)))))
\end{alignat*}
Next, we prove by induction on $S$ that $\blank_\map$ commutes with $\ora{S_0}$:
\[ S_{\floord{\map}} : \forall\,f\,x.\,\,S_\map\,P\,(\lambda\,(x,\,p).\,f\,x\,p)\,x = \tr\,\bigl(S_\IH\,P\bigr)\,\bigl(\eta\,x\bigr)\,\bigl(\ola{S_\IH}\,(\floord{S}_\map\,\floord{P}\,f\,(\fst\,(\ora{S_0}\,x)))\bigr)\]
Using this equation to rewrite the \textbf{right hand side}, we get:
\begin{alignat*}{3}
  f\,x\,\Bigl(\tr\,\bigl(S_\IH\,P\bigr)\,\bigl(\eta\,x\bigr)\,\bigl(\ola{S_\IH}\,(\floord{S}_\map\,\floord{P}\,(\lambda\,x\,p.\,\elim\,P\,f\,(x,\,p))\,(\fst\,(\ora{S_0}\,x)))\bigr)\Bigr)
\end{alignat*}
This is now promising; on the left hand side we transport the result of $f$, while on the right hand
side we transport the argument of $f$. Now, the identification on the left is
$\epsilon\,(\ora{S_0}\,x)$, while we have $\eta\,x$ on the right. However, we have $\tau\,x :
\ap\,(\ora{S_0})\,(\eta\,x) = \epsilon\,(\ora{S_0}\,x)$, which can be used in conjunction with
standard transport lemmas to match up the two sides.

\subsection{Strictness}
We briefly analyze the strictness of computation for constructed IIR types. Clearly, since the
construction is defined by induction on IIR signatures, we only have propositional
$\msf{El\!\!-\!\!intro}$ and $\elim\!-\!\!\beta$ in the general case, where an IIR signature can be
neutral.

However, we still support the same definitional IIR computation rules as Agda and Idris. That is
because Agda and Idris only have second-class IIR signatures. There, signatures consist of
constructors with fixed configurations of fields, where constructors are disambiguated by canonical
name tags. $\El$ applied to a constructor computes definitionally, and so does the elimination
principle when applied to a constructor. Using our IIR types, we encode Agda IIR types as follows:
\begin{itemize}
\item We have $\sigma\,\Tag\,S$ on the top to represent constructor tags.
\item In $S$, we immediately pattern match on the tag.
\item All other $\Sig$ subterms are canonical in the rest of the signature.
\end{itemize}
Thus, if we apply $\El$ or $\elim$ to a value with a canonical tag, we compute past the branching on
the tag and then compute all the way on the rest of the signature. In the Agda supplement, we provide
length-indexed vectors and the $\Code$ universe as examples for constructed IIR types with strict
computation rules.

\subsection{Mechanization}

We formalized Section \ref{TODO} in Agda, using the same definitions and proofs as above. For the
assumption of IR, we verbatim reproduced the specification in Section \cite{TODO}, turning $\IR$
into an inductive type and $\El$ and $\elim$ into recursive functions. The functions are not
recognized as terminating by Agda, so we disable terminating checking for them. Alternatively, we
could use rewrite rules \cite{TODO}; the two versions are the same except that rewrite rules have a
noticeable performance cost in evaluation.

Also, our object theory does not have internal universe levels, so we understand level
quantification to happen in a metatheory, while in Agda we do use native universe polymorphism.

\section{Canonicity}\label{sec:canonicity}

In this section we prove canonicity for the object theory extended with IR types. First, we specify
the metatheory and the object theory in more detail.

\subsection{Metatheory}\label{sec:metatheory}

\subsubsection{Specification} The metatheory supports the following:
\begin{itemize}
  \item A countable universe hierarchy and basic type formers as described in Section \ref{TODO}.
    We write universes as $\Set_i$ instead of $\U_i$, to avoid confusion with object-theoretic
    universes.
  \item Equality reflection. Hence, in the following we will only use $\blank\!=\!\blank$ to denote
    metatheoretic equality.
  \item Universe levels $\omega$ and $\omega+1$, where $\Set_\omega : \Set_{\omega + 1}$ and $\Set_{\omega + 1}$
        is a ``proper type'' that is not contained in any universe. $\Set_\omega$ and $\Set_{\omega + 1}$ are
        also closed under basic type formers.
  \item IR types in $\Set_i$ when $i$ is finite.
  \item A reflection principle which says that finite universe levels corresponds to elements of the
    internal type of natural numbers $\Nat : \Set_0$. This is similar to Agda's internal type of
    finite levels, called $\Level$ \cite{TODO}.  For a more formal specification of this
    internalization, see \cite{TODO}. The reason for this feature is the following. The object
    theory has countable levels represented as natural numbers, so we have to interpret those
    numbers as metatheoretic levels in the canonicity model, to correctly specify sizes of
    reducibility predicates.
  \item The syntax of the object theory as a quotient inductive-inductive type \cite{TODO}, to be
    described in the following section.
\end{itemize}

\subsubsection{Consistency of the metatheory}

\todo{TODO}

\subsection{The Object Theory}\label{sec:object-theory}

Informally, the object theory is a Martin-Löf type theory that supports basic type formers as
described in Section \ref{TODO} and IR types as described in Section \ref{TODO}. More formally, the
object theory is given as a quotient inductive-inductive type \cite{TODO}. The sets, operations and
equations that we give in the following together constitute the inductive signature.

\subsubsection{Core substitution calculus} The basic judgmental structure is given
as a category with families (CwF) \cite{TODO} where types are additionally annotated with levels.
Concretely, we have
\begin{itemize}
\item A category of contexts and substitutions. We have $\Con : \Set_0$ for contexts and $\Sub : \Con \to \Con \to \Set_0$
  for substitutions. The empty context $\emptycon$ is the terminal object with the unique substitution $\epsilon : \Sub\,\Gamma\,\emptycon$.
  We write $\id$ for identity substitutions and $\blank\!\circ\!\blank$ for substitution composition.
\item Level-indexed types, as $\Ty : \Con \to \Nat \to \Set_0$, together with the functorial substitution operation
      $\blank[\blank] : \Ty\,\Delta\,i \to \Sub\,\Gamma\,\Delta \to \Ty\,\Gamma\,i$.
\item Terms as $\Tm : (\Gamma : \Con) \to \Ty\,\Gamma\,i \to \Set_0$, with functorial substitution operation
  $\blank[\blank] : \Tm\,\Delta\,A \to (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,A[\sigma]$.
  \emph{Notation:} both type and term substitution binds stronger than function application, so
  for example $\Tm\,\Gamma\,A[\sigma]$ means $\Tm\,\Gamma\,(A[\sigma])$.
\item Context comprehension, consisting of a context extension operation $\blank\!\ext\!\blank : (\Gamma : \Con) \to \Ty\,\Gamma\,i \to \Con$,
  weakening morphism $\p : \Sub\,(\Gamma\ext A)\,\Gamma$, zero variable $\q : \Tm\,(\Gamma\ext A)\,A[\p]$ and substitution extension $\blank,\!\blank : (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,A[\sigma] \to \Sub\,\Gamma\,(\Delta\ext A)$, such that the following equations hold:
  \begin{alignat*}{3}
    &\p \circ (\sigma,\,t)     &&= \sigma \\
    &\q[\sigma,\,t]            &&= t \\
    &(\p,\,\q)                 &&= \id \\
    &(\sigma,\,t) \circ \delta &&= (\sigma \circ \delta,\,t[\delta])
  \end{alignat*}
  Note that a De Bruijn index $N$ is represented as $\q[\p^N]$, where $\p^N$ is $N$-fold composition
  of weakening.
\end{itemize}

\subsubsection{Universes} We have Russell-style universes, where sets of terms of universes are identified with sets of types.
Concretely, we have $\U : (i : \Nat) \to \Ty\,\Gamma\,(i + 1)$ such that $\U_i[\sigma] = \U_i$ and
$\Tm\,\Gamma\,\U_i = \Ty\,\Gamma\,i$.  This lets us implicit cast between types and terms of
universes. Additionally, we specify that this casting operation commutes with substitution, so
substituting $t : \Tm\,\Gamma\,\U_i$ as a term and then casting to a type is the same as first
casting and then substituting as a type. Since we omit casts and overload $\blank[\blank]$, this
rule looks trivial in our notation, but it still has to be assumed.

\subsubsection{Functions} We have $\Pi : (A : \Ty\,\Gamma\,i) \to \Ty\,(\Gamma \ext A)\,j \to \Ty\,\Gamma\,\max(i,\,j)$
such that $(\Pi\,A\,B)[\sigma] = \Pi\,A[\sigma]\,B[\sigma\circ\p,\,\q]$.  Terms are specified by
$\app : \Tm\,\Gamma\,(\Pi\,A\,B) \to \Tm\,(\Gamma\ext A)\,B$ and its definitional inverse $\lam :
\Tm\,(\Gamma\ext A)\,B \to \Tm\,\Gamma\,(\Pi\,A\,B)$. This isomorphism is natural in $\Gamma$, so we
have a substitution rule $(\lam\,t)[\sigma\circ\p,\,\q] = \lam\,t[\sigma]$.
%% We derive the traditional binary application operation as follows: $t\,\bapp\,u :=
%% (\app\,t)[\id,\,u]$. We use this as a left-associative operator.  We define non-dependent
%% functions: $A \fun B := \Pi\,A\,B[\p]$ where $A : \Ty\,\Gamma\,i$ and $B : \Ty\,\Gamma\,j$.
\\

\noindent\emph{Stability under substitution.} In the following we implicitly assume stability under
substitution for every type and term former.

\subsubsection{Sigma types} We have $\Sigma : (A : \Ty\,\Gamma\,i) \to \Ty\,(\Gamma \ext A)\,j \to \Ty\,\Gamma\,\max(i,\,j)$.
Pairing and projection are given as a natural isomorphism between $\Tm\,\Gamma\,(\Sigma\,A\,B)$ and $(t : \Tm\,\Gamma\,A)\times \Tm\,\Gamma\,B[\id,\,t]$. We write $\blank,\blank$ for pairing and $\proj_1$ and $\proj_2$ for projections.

\subsubsection{Empty type} We have $\bot : \Ty\,\Gamma\,0$ with elimination $\exfalso : (A : \Ty\,\Gamma\,i) \to \Tm\,\Gamma\,\bot \to \Tm\,\Gamma\,A$.

\subsubsection{Unit} We have $\top_i : \Ty\,\Gamma\,i$ with the unique inhabitant $\ttt$. Note that unlike the empty type, the unit
type is included in every universe. As we explained in Section \ref{TODO}, this allows us to define a type lifting operation.

\subsubsection{Booleans} Type formation is $\Bool : \Ty\,\Gamma\,0$ with constructors $\true$ and $\false$. Elimination is as follows.
\begin{alignat*}{3}
  &\BoolElim : (P : \Ty\,(\Gamma \ext \Bool)\,i) \to \Tm\,\Gamma\,P[\id,\,\true] \to \Tm\,\Gamma\,P[\id,\,\false]\\
  &\hspace{4.5em}             \to (t : \Tm\,\Gamma\,\Bool) \to \Tm\,\Gamma\,P[\id,\,t]\\
  & \BoolElim\,P\,t\,f\,\true\hspace{0.2em} = t\\
  & \BoolElim\,P\,t\,f\,\false = f
\end{alignat*}
\emph{Notation \& conventions.} At this point we start building conventions
for notation and desugaring, because raw CwF combinators and De Bruijn indices get very hard to read
for more complicated specifications like identity elimination or the specification of IR types.
\begin{itemize}
\item Assuming $t : \Tm\,\Gamma\,(\Pi\,A\,B)$ and $u : \Tm\,\Gamma\,A$, traditional binary function application
  can be derived as $(\app\,t)[\id,\,u] : \Tm\,\Gamma\,B[\id,\,u]$. We overload the metatheoretic whitespace
  operator for this kind of object-level application.
\item We may give a name to a binder (a binder can be a context extension or a $\Pi$, $\Sigma$ or $\lam$ binder),
  and in the scope of the binder all occurrence of the name is desugared to the right De Bruijn index.
  We write $\Pi$-types using the same notation as in the metatheory. For example, $(A :
  \U_i) \to A \to A$ is desugared to $\Pi\,\U_i\,(\Pi\,\q\,\q[\p])$. We also reuse the notation and
  behavior of implicit functions. We write object-level lambda abstraction as $\lam\,x.t$.
\item In term formation rules, we will use a style where each term former is a constant with an
  iterated $\Pi$-type.  In general, the choice between specifying something with a meta-level or
  object-level function is arbitrary (i.e.\ the two-versions are inter-derivable). Sticking to
  object-level functions lets us consistently use the desugaring for named binders.
\end{itemize}

\subsubsection{Identity types} We start using the previously introduced convention.
Type and term formation is as follows.
\begin{alignat*}{3}
  &\Id   &&: \Tm\,\Gamma\,((A : \U_i) \to A \to A \to \U_i)\\
  &\refl &&: \Tm\,\Gamma\,(\{A : \U_i\}(t : A) \to \Id\,A\,t\,t)
\end{alignat*}
One more example for desugaring: the type of $\refl$ becomes
$\Tm\,\Gamma\,(\Pi\,\U_i\,(\Pi\,\q\,(\Id\,\q[\p]\,\q\,\q)))$.  Identity elimination is the
following.
\begin{alignat*}{3}
  &\J : \Tm\,\Gamma\,(\{A : \U_i\}\{x : A\}(P : (y : A) \to \Id\,A\,x\,y \to \U_k)\\
  & \hspace{3.5em}\to P\,(\refl\,x) \to \{y : A\}(p : \Id\,A\,x\,y) \to P\,y\,p)&&
  &\\
  &\J\,P\,r\,(\refl\,x) = r
\end{alignat*}

\subsubsection{IR types} First, we specify the type of signatures as an inductive type. We assume levels $i$
and $j$.
\begin{alignat*}{3}
  &\Sig_i  &&: \Tm\,\Gamma\,((O : \U_j) \to \U_{\max(i+1,\,j)})\\
  &\iota   &&: \Tm\,\Gamma\,(\{O : \U_j\} \to O \to \Sig_i\,O)\\
  &\sigma  &&: \Tm\,\Gamma\,(\{O : \U_j\}(A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O)\\
  &\delta  &&: \Tm\,\Gamma\,(\{O : \U_j\}(A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O)
\end{alignat*}
\begin{alignat*}{3}
  &\SigElim : \Tm\,\Gamma\,(\{O : \U_j\}(P : \Sig_i\,O \to \U_k)\\
  &           \hspace{2.2em}\to ((o : O) \to P\,(\iota\,o))\\
  &           \hspace{2.2em}\to ((A : \U_i)(S : A \to \Sig_i\,O) \to ((a : A) \to P\,(S\,a)) \to P\,(\sigma\,A\,S))\\
  &           \hspace{2.2em}\to ((A : \U_i)(S : (A \to O) \to \Sig_i\,O) \to ((f : A \to O) \to P\,(S\,f)) \to P\,(\delta\,A\,S))\\
  &           \hspace{2.2em}\to (S : \Sig_i\,O) \to P\,S)\\
  &\\
  &\SigElim\,P\,i\,s\,d\,(\iota\,o) \hspace{1.1em} = i\\
  &\SigElim\,P\,i\,s\,d\,(\sigma\,A\,S) = s\,A\,S\,(\lam\,a.\,\SigElim\,P\,i\,s\,d\,(S\,a))\\
  &\SigElim\,P\,i\,s\,d\,(\delta\,A\,S) \hspace{0.1em}= d\,A\,S\,(\lam\,f.\,\SigElim\,P\,i\,s\,d\,(S\,f))
\end{alignat*}

\todo{Move sugar to right after universes and functions}


  %% SigElim : ∀ {k}(P : Sig → Set k)
  %%           → ((o : O) → P (ι o))
  %%           → ((A : Set i) (S : A → Sig) → ((a : A) → P (S a)) → P (σ A S))
  %%           → ((A : Set i) (S : (A → O) → Sig) → ((f : A → O) → P (S f)) → P (δ A S))
  %%           → ∀ S → P S
  %% SigElim P ι' σ' δ' (ι o)   = ι' o
  %% SigElim P ι' σ' δ' (σ A S) = σ' A S (SigElim P ι' σ' δ' ∘ S)
  %% SigElim P ι' σ' δ' (δ A S) = δ' A S (SigElim P ι' σ' δ' ∘ S)

  %% data Sig : Set (lsuc i ⊔ j) where
  %%   ι : O → Sig
  %%   σ : (A : Set i) → (A → Sig) → Sig
  %%   δ : (A : Set i) → ((A → O) → Sig) → Sig


%% We have $\Id : (A : \Ty\,\Gamma\,i) \to \Tm\,\Gamma\,A \to \Tm\,\Gamma\,A \to \Ty\,\Gamma\,i$
%% and $\refl : (t : \Tm\,\Gamma\,A) \to \Tm\,\Gamma\,(\Id\,









%% \subsubsection{IR signatures}
%% We specify the type of IR signatures in the following as an inductive type. We assume $i, j : \Nat$ and
%% $O : \Ty\,\Gamma\,j$ as parameters.
%% \begin{alignat*}{3}
%%   & \Sig_i\,O &&: \Ty\,\Gamma\,\max(i+1,\,j) \\
%%   & \iota     &&: \Tm\,\Gamma\,O \to \Tm\,\Gamma\,(\Sig_i\,O)\\
%%   & \sigma    &&: (A : \Ty\,\Gamma\,\U_i) \to \Tm\,\Gamma\,(A \fun \Sig_i\,O) \to \Tm\,\Gamma\,(\Sig_i\,O)\\
%%   & \delta    &&: (A : \Ty\,\Gamma\,\U_i) \to \Tm\,\Gamma\,((A \fun O) \fun \Sig_i\,O) \to \Tm\,\Gamma\,(\Sig_i\,O)
%% \end{alignat*}
%% Note that we have some choice whether to represent function arguments as internal function types,
%% context extension, or meta-level function types. For example, $\Tm\,\Gamma\,(A \fun \Sig_i\,O)$
%% could be represented as $\Tm\,(\Gamma\ext A)\,(\Sig_i\,O[\p])$ as well. Also, since we have
%% universes and $\Pi$-types, we could choose to specify all of $\iota$, $\sigma$ and $\delta$ as term
%% constants with a function type. All of these choices yield inter-derivable specifications.

%% We proceed to the elimination principle. Here, the native CwF notation becomes difficult to read, so
%% we introduce some syntactic sugar. We can give names to binders, and we can refer to a variable by
%% name in a possibly larger context. Every mention of the variable name is desugared to a De Bruijn
%% index.
%% \begin{alignat*}{3}
%%   &\SigElim_k :\,(P : \Tm\,\Gamma\,(\Sig_i\,O \fun \U_k))\\
%%   & \hspace{3em}\to \Tm\,\Gamma\,(\Pi\,(o : O)\,(P[\p]\,\$\,(\iota\,o)))\\
%%   & \hspace{3em}\to \Tm\,\Gamma\,(\Pi\,(A : \U_i)\,(\Pi\,(S : A \fun \Sig_i\,O[\p^2])\,((\Pi\,(a : A)\,(P[\p^3]\,\$\,(S\,\$\,a))) \fun P[\p^2]\,\$\,(\sigma\,A\,S))))\\
%%   & \hspace{3em}\to \Tm\,\Gamma\,(\Pi\,(A : \U_i)\,(\Pi\,(S : (A \fun O[\p]) \fun \Sig_i\,O[\p^2])\\
%%   & \hspace{6.85em}                 ((\Pi\,(f : A \fun O[\p^2])\,(P[\p^3]\,\$\,(S\,\$\,f))) \fun P[\p^2]\,\$\,(\delta\,A\,S))))\\
%%   & \hspace{3em}\to (S : \Tm\,\Gamma\,(\Sig_i\,O))\\
%%   & \hspace{3em}\to \Tm\,\Gamma\,(P\,\$\,S)
%% \end{alignat*}
%% \begin{alignat*}{3}
%%   &\SigElim_k\,P\,i\,s\,d\,(\iota\,o) && = i\,\$\,o\\
%%   &\SigElim_k\,P\,i\,s\,d\,(\sigma\,A\,S) && = s\,\$\,A\,\$\,S\,\$\,(\lam\,a\,(\SigElim_k\,P[\p]\,i[\p]\,s[\p]\,d[\p]\,(S[\p]\,\$\,a)))\\
%%   &\SigElim_k\,P\,i\,s\,d\,(\delta\,A\,S) && = s\,\$\,A\,\$\,S\,\$\,(\lam\,f\,(\SigElim_k\,P[\p]\,i[\p]\,s[\p]\,d[\p]\,(S[\p]\,\$\,f)))
%% \end{alignat*}
%% For example,
%% \[ \Pi\,(A : \U_i)\,(\Pi\,(S : A \fun \Sig_i\,O[\p^2])\,((\Pi\,(a : A)\,(P[\p^3]\,\$\,(S\,\$\,a))) \fun P[\p^2]\,\$\,(\sigma\,A\,S))) \]
%% is desugared to
%% \[ \Pi\,\U_i\,(\Pi\,(\q \fun \Sig_i\,O[\p^2])\,((\Pi\,\q[\p]\,(P[\p^3]\,\$\,(\q[\p]\,\$\,\q))) \fun P[\p^2]\,\$\,(\sigma\,\q[\p]\,\q))). \]
%% Or, with numeric De Bruijn indices:
%% \[ \Pi\,\U_i\,(\Pi\,(0 \fun \Sig_i\,O[\p^2])\,((\Pi\,1\,(P[\p^3]\,\$\,(1\,\$\,0))) \fun P[\p^2]\,\$\,(\sigma\,1\,0))) \]
%% Either way, De Bruijn indices are just not readable. Fortunately, as we will see shortly, we can
%% avoid De Bruijn indices in the crucial parts of the canonicity proof.

%% \subsubsection{IR types}
%% \begin{alignat*}{3}
%%   \IR : \Tm\,\Gamma\,\Sig_i\,O \to
%% \end{alignat*}

%% QUESTION: encode everything in IR with full function types and named binders, and give some examples
%% of desugaring?? This works in the canonicity model.

  %% data IR (S : Sig) : Set i
  %% El : ∀ {S} → IR S → O

  %% data IR S where
  %%   wrap : F0 S (IR S) El → IR S

  %% {-# TERMINATING #-}
  %% El {S} (wrap t) = F1 S t

  %% {-# TERMINATING #-}
  %% elim : ∀ {k} S (P : IR S → Set k) → (∀ x → IH S P x → P (wrap x)) → ∀ x → P x
  %% elim S P f (wrap x) = f x (mapIH S P (elim S P f) x)


\section{TODO}


\begin{itemize}
  \item Definitions, notations, IR-IRR disambiguation in derivation section
  \item Rename wrap to intro in Agda. Rename DeriveIndexed F0 equivalence in Agda.
  \item Canonicity metatheory: Loic, Anton says it looks OK

\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
