
%% build: latexmk -pdf -pvc paper.tex

\documentclass[acmsmall,screen,review,anonymous]{acmart}
%% \documentclass[nonacm,acmsmall]{acmart}
%% \documentclass[acmsmall]{acmart}
%% \raggedbottom

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%% --------------------------------------------------------------------------------

\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
\usepackage{bm}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage[title]{appendix}

\newcommand{\mit}[1]{{\mathsf{#1}}}
\newcommand{\msf}[1]{{\mathsf{#1}}}
\newcommand{\mbf}[1]{{\mathbf{#1}}}
\newcommand{\mbb}[1]{\mathbb{#1}}
%% \newcommand{\rel}{^{\approx}}
%% \newcommand{\U}{\mathsf{U}}
%% \newcommand{\Id}{\msf{Id}}
%% \newcommand{\p}{\mathsf{p}}
%% \newcommand{\q}{\mathsf{q}}
%% \newcommand{\code}{\mathsf{code}}
%% \newcommand{\bs}[1]{\boldsymbol{#1}}
%% \newcommand{\wh}[1]{\widehat{#1}}
%% \newcommand{\mdo}{\mbf{do}\,}
%% \newcommand{\ind}{\hspace{1em}}
%% \newcommand{\bif}{\mbf{if}\,}
%% \newcommand{\bthen}{\mbf{then}\,}
%% \newcommand{\belse}{\mbf{else}\,}
%% \newcommand{\return}{\mbf{return}\,}
%% \newcommand{\pure}{\mbf{pure}\,}
%% \newcommand{\lam}{\lambda\,}
%% \newcommand{\data}{\mbf{data}\,}
%% \newcommand{\where}{\mbf{where}}
%% \newcommand{\M}{\msf{M}}
%% \newcommand{\letrec}{\mbf{letrec}\,}

%% \newcommand{\of}{\mbf{of}\,}
%% \newcommand{\go}{\mit{go}}
%% \newcommand{\add}{\mit{add}}
%% \newcommand{\letdef}{\mbf{let\,}}
%% \newcommand{\map}{\mit{map}}
%% \newcommand{\emptycon}{\scaleobj{.75}\bullet}
%% \newcommand{\Tyo}{\msf{Ty}_{\mbbo}}
%% \newcommand{\Tmo}{\msf{Tm}_{\mbbo}}
%% \newcommand{\Cono}{\msf{Con}_{\mbbo}}
%% \newcommand{\Subo}{\msf{Sub}_{\mbbo}}
%% \newcommand{\whset}{\wh{\Set}}
%% \newcommand{\ev}{\mbb{E}}
%% \newcommand{\re}{\mbb{R}}
%% \newcommand{\welim}{\vW{-}\msf{elim}}

%% \newcommand{\mbbc}{\mbb{C}}
%% \newcommand{\mbbo}{\mbb{O}}

%% \newcommand{\vas}{\mathsf{as}}
%% \newcommand{\vbs}{\mathsf{bs}}
%% \newcommand{\vcs}{\mathsf{cs}}
%% \newcommand{\vxs}{\mathsf{xs}}
%% \newcommand{\vys}{\mathsf{ys}}
%% \newcommand{\vsp}{\mathsf{sp}}
%% \newcommand{\vma}{\mathsf{ma}}
%% \newcommand{\vga}{\mathsf{ga}}
%% \newcommand{\vm}{\mathsf{m}}
%% \newcommand{\vn}{\mathsf{n}}
%% \newcommand{\vk}{\mathsf{k}}
%% \newcommand{\vA}{\mathsf{A}}
%% \newcommand{\vB}{\mathsf{B}}
%% \newcommand{\vC}{\mathsf{C}}
%% \newcommand{\vS}{\mathsf{S}}
%% \newcommand{\vF}{\mathsf{F}}
%% \newcommand{\vR}{\mathsf{R}}
%% \newcommand{\vM}{\mathsf{M}}
%% \newcommand{\vmb}{\mathsf{mb}}
%% \newcommand{\mAs}{\mathsf{As}}
%% \newcommand{\va}{\mathsf{a}}
%% \newcommand{\vb}{\mathsf{b}}
%% \newcommand{\vc}{\mathsf{c}}
%% \newcommand{\vd}{\mathsf{d}}
%% \newcommand{\vx}{\mathsf{x}}
%% \newcommand{\vy}{\mathsf{y}}
%% \newcommand{\vz}{\mathsf{z}}
%% \newcommand{\vf}{\mathsf{f}}
%% \newcommand{\vfs}{\mathsf{fs}}
%% \newcommand{\vg}{\mathsf{g}}
%% \newcommand{\vh}{\mathsf{h}}
%% \newcommand{\vt}{\mathsf{t}}
%% \newcommand{\vs}{\mathsf{s}}
%% \newcommand{\vr}{\mathsf{r}}
%% \newcommand{\vu}{\mathsf{u}}
%% \newcommand{\vl}{\mathsf{l}}
%% \newcommand{\vns}{\mathsf{ns}}
%% \newcommand{\vW}{\mathsf{W}}
%% \newcommand{\vsup}{\mathsf{sup}}
%% \newcommand{\vid}{\mathsf{id}}
%% \newcommand{\whW}{\wh{\vW}}


%% \newcommand{\SOP}{\msf{SOP}}
%% \newcommand{\El}{\msf{El}}
%% \newcommand{\USOP}{\msf{U}_{\msf{SOP}}}
%% \newcommand{\Uprod}{\msf{U_P}}
%% \newcommand{\Elprod}{\msf{El_{P}}}
%% \newcommand{\IsSOP}{\msf{IsSOP}}
%% \newcommand{\forEach}{\msf{forEach}}
%% \newcommand{\single}{\msf{single}}
%% \newcommand{\msplit}{\msf{split}}
%% \newcommand{\mapGen}{\msf{mapGen}}
%% \newcommand{\genPull}{\msf{gen_{Pull}}}
%% \newcommand{\Set}{\msf{Set}}
%% \newcommand{\casePull}{\msf{case_{Pull}}}
%% \newcommand{\appull}{\ap_{\Pull}}

%% \newcommand{\Con}{\msf{Con}}
%% \newcommand{\Sub}{\msf{Sub}}
%% \newcommand{\Tm}{\msf{Tm}}

%% \newcommand{\ext}{\triangleright}

%% \newcommand{\Int}{\msf{Int}}
%% \newcommand{\List}{\msf{List}}
%% \newcommand{\Tree}{\msf{Tree}}
%% \newcommand{\Node}{\msf{Node}}
%% \newcommand{\Leaf}{\msf{Leaf}}
%% \newcommand{\Nil}{\msf{Nil}}
%% \newcommand{\Cons}{\msf{Cons}}
%% \newcommand{\Reader}{\msf{Reader}}
%% \newcommand{\ReaderT}{\msf{ReaderT}}
%% \newcommand{\Monad}{\msf{Monad}}
%% \newcommand{\Applicative}{\msf{Applicative}}
%% \newcommand{\class}{\msf{class}}
%% \newcommand{\Functor}{\msf{Functor}}
%% \newcommand{\Bool}{\msf{Bool}}
%% \newcommand{\Statel}{\msf{State}}
%% \newcommand{\fro}{\leftarrow}
%% \newcommand{\case}{\mbf{case\,}}
%% \newcommand{\foldr}{\msf{foldr}}
%% \newcommand{\foldl}{\msf{foldl}}
%% \newcommand{\rep}{\msf{rep}}
%% \newcommand{\concatMap}{\msf{concatMap}}

%% \newcommand{\Lift}{{\Uparrow}}
%% \newcommand{\Up}{{\Uparrow}}
%% \newcommand{\spl}{{\bs{\sim}}}
%% \newcommand{\ql}{{\bs{\langle}}}
%% \newcommand{\qr}{{\bs{\rangle}}}
%% \newcommand{\bind}{\mathbin{>\!\!>\mkern-6.7mu=}}

%% \newcommand{\MTy}{\msf{MetaTy}}
%% \newcommand{\MTm}{\msf{MetaTm}}
%% \newcommand{\VTy}{\msf{ValTy}}
%% \newcommand{\Ty}{\msf{Ty}}
%% \newcommand{\CTy}{\msf{CompTy}}
%% \newcommand{\True}{\msf{True}}
%% \newcommand{\False}{\msf{False}}
%% \newcommand{\fst}{\msf{fst}}
%% \newcommand{\snd}{\msf{snd}}

%% \newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}

%% \newcommand{\Nat}{\msf{Nat}}
%% \newcommand{\Zero}{\msf{Zero}}
%% \newcommand{\Suc}{\msf{Suc}}
%% \newcommand{\Maybe}{\msf{Maybe}}
%% \newcommand{\MaybeT}{\msf{MaybeT}}
%% \newcommand{\Nothing}{\msf{Nothing}}
%% \newcommand{\Just}{\msf{Just}}

%% \theoremstyle{remark}
%% \newtheorem{notation}{Notation}
%% \newtheorem*{axiom}{Axiom}

%% \newcommand{\id}{\mit{id}}
%% \newcommand{\mup}{\mbf{up}}
%% \newcommand{\mdown}{\mbf{down}}
%% \newcommand{\tyclass}{\mbf{class}}
%% \newcommand{\instance}{\mbf{instance}\,}
%% \newcommand{\Improve}{\msf{Improve}}
%% \newcommand{\Gen}{\msf{Gen}}
%% \newcommand{\unGen}{\mit{unGen}}
%% \renewcommand{\Vec}{\msf{Vec}}
%% \newcommand{\gen}{\mit{gen}}
%% \newcommand{\genRec}{\mit{genRec}}
%% \newcommand{\fmap}{<\!\!\$\!\!>}
%% \newcommand{\ap}{{<\!\!*\!\!>}}
%% \newcommand{\runGen}{\mit{runGen}}
%% \newcommand{\qt}[1]{\ql#1\qr}
%% \newcommand{\lift}{\mit{lift}}
%% \newcommand{\liftGen}{\mit{liftGen}}
%% \newcommand{\MonadGen}{\msf{MonadGen}}
%% \newcommand{\MonadState}{\msf{MonadState}}
%% \newcommand{\MonadReader}{\msf{MonadReader}}
%% \newcommand{\RA}{\Rightarrow}
%% \newcommand{\EitherT}{\msf{EitherT}}
%% \newcommand{\Either}{\msf{Either}}
%% \newcommand{\Left}{\msf{Left}}
%% \newcommand{\Right}{\msf{Right}}
%% \newcommand{\StateT}{\msf{StateT}}
%% \newcommand{\Identity}{\msf{Identity}}

%% \newcommand{\Stop}{\msf{Stop}}
%% \newcommand{\Skip}{\msf{Skip}}
%% \newcommand{\Yield}{\msf{Yield}}

%% \newcommand{\runIdentity}{\mit{runIdentity}}
%% \newcommand{\runReaderT}{\mit{runReaderT}}
%% \newcommand{\newtype}{\mbf{newtype}\,}
%% \newcommand{\runMaybeT}{\mit{runMaybeT}}
%% \newcommand{\runStateT}{\mit{runStateT}}
%% \newcommand{\runState}{\mit{runState}}
%% \newcommand{\dlr}{\,\$\,}

%% \newcommand{\ImproveF}{\msf{ImproveF}}
%% \newcommand{\ExceptT}{\msf{ExceptT}}
%% \newcommand{\State}{\msf{State}}
%% \newcommand{\SumVS}{\msf{SumVS}}
%% \newcommand{\ProdCS}{\msf{ProdCS}}
%% \newcommand{\Here}{\msf{Here}}
%% \newcommand{\There}{\msf{There}}
%% \newcommand{\IsSumVS}{\msf{IsSumVS}}
%% \newcommand{\MonadJoin}{\msf{MonadJoin}}
%% \newcommand{\Stream}{\msf{Stream}}
%% \newcommand{\join}{\mit{join}}
%% \newcommand{\modify}{\mit{modify}}
%% \newcommand{\get}{\mit{get}}
%% \newcommand{\mput}{\mit{put}}
%% \newcommand{\Rep}{\mit{Rep}}
%% \newcommand{\encode}{\mit{encode}}
%% \newcommand{\decode}{\mit{decode}}
%% \newcommand{\mindex}{\mit{index}}
%% \newcommand{\mtabulate}{\mit{tabulate}}
%% \newcommand{\States}{\mit{States}}
%% \newcommand{\seed}{\mit{seed}}
%% \newcommand{\step}{\mit{step}}
%% \newcommand{\Step}{\msf{Step}}
%% \newcommand{\Pull}{\msf{Pull}}
%% \newcommand{\MkPull}{\msf{MkPull}}

%% --------------------------------------------------------------------------------

%%
%% end of the preamble, start of the body of the document source.
%% \hypersetup{draft}
\begin{document}


\title{Canonicity for Indexed Inductive-Recursive Types}

\author{András Kovács}
\orcid{0000-0002-6375-9781}
\affiliation{%
  \institution{University of Gothenburg \& Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}
\email{andrask@chalmers.se}


\begin{abstract}
We prove canonicity for a Martin-Löf type theory that supports a countable universe hierarchy where
each universe supports indexed inductive-recursive (IIR) types. We proceed in two steps. First, we
construct IIR types from inductive-recursive (IR) types and intensional identity types, in order to
simplify the subsequent canonicity proof. The constructed IIR types support the same definitional
computation rules that are available in Agda's native IIR implementation. Second, we give a
canonicity proof for IR types, building on the well-known method of Artin gluing. The main idea is
to represent the canonicity predicate for each IR type using a metatheoretic IIR type. In short,
we use metatheoretic IIR types to prove canonicity for IR types.
\end{abstract}

%% \begin{CCSXML}
%% \end{CCSXML}
%% \ccsdesc[500]{Theory of computation~Type theory}
%% \ccsdesc[500]{Software and its engineering~Source code generation}
%% \keywords{}

\maketitle

\section{Introduction}\label{sec:introduction}

Induction-recursion (IR) was first used by Martin-Löf in an informal way \cite{TODO}, then made
formal by Dybjer and Setzer \cite{TODO}, who also developed set-theoretic and categorical semantics
\cite{TODO}. A common application of IR is to define custom universe hierarchies inside a type
theory. In the proof assistant Agda, we can use IR to define a universe closed under a choice of
type formers.
\begin{alignat*}{3}
& TODO
\end{alignat*}


This can
be used in building metatheory for type theories with universe hierarchies. For example, IR has been
used to prove normalization \cite{TODO} and to build semantics for first-class universe levels
\cite{TODO} and to prove canonicity for them \cite{TODO}. Another application is in generic
programming, where IR is used to define custom universes of datatype descriptions \cite{TODO}.







\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
