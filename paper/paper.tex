
%% build: latexmk -pdf -pvc paper.tex

\documentclass[acmsmall,screen,review,anonymous]{acmart}
%% \documentclass[nonacm,acmsmall]{acmart}
%% \documentclass[acmsmall]{acmart}
%% \raggedbottom

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%% --------------------------------------------------------------------------------

\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
\usepackage{bm}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage[title]{appendix}

\newcommand{\mit}[1]{{\mathsf{#1}}}
\newcommand{\msf}[1]{{\mathsf{#1}}}
\newcommand{\mbf}[1]{{\mathbf{#1}}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\data}{\mbf{data}}
\newcommand{\U}{\msf{U}}
\newcommand{\Set}{\msf{Set}}
\newcommand{\where}{\mbf{where}}
\newcommand{\Nat}{\msf{Nat}}
\newcommand{\zero}{\msf{zero}}
\newcommand{\suc}{\msf{suc}}
\newcommand{\Nil}{\msf{Nil}}
\newcommand{\Cons}{\msf{Cons}}
\newcommand{\El}{\msf{El}}
\newcommand{\Lift}{\msf{Lift}}
\newcommand{\lup}{\uparrow}
\newcommand{\ldown}{\downarrow}
\newcommand{\Sig}{\msf{Sig}}
\newcommand{\Code}{\msf{Code}}
\newcommand{\Tag}{\msf{Tag}}
\newcommand{\case}{\mbf{case}}
\newcommand{\of}{\mbf{of}}
\newcommand{\ttt}{\msf{tt}}
\newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}
\newcommand{\ir}{{ir}}
\newcommand{\el}{{el}}
\newcommand{\ix}{{ix}}
\newcommand{\IR}{\msf{IR}}
\newcommand{\intro}{\msf{intro}}
\newcommand{\IH}{\msf{IH}}
\newcommand{\map}{\msf{map}}
\newcommand{\elim}{\msf{elim}}
\newcommand{\inj}{\msf{inj}}





%% \newcommand{\rel}{^{\approx}}

%% \newcommand{\Id}{\msf{Id}}
%% \newcommand{\p}{\mathsf{p}}
%% \newcommand{\q}{\mathsf{q}}
%% \newcommand{\code}{\mathsf{code}}
%% \newcommand{\bs}[1]{\boldsymbol{#1}}
%% \newcommand{\wh}[1]{\widehat{#1}}
%% \newcommand{\mdo}{\mbf{do}\,}
%% \newcommand{\ind}{\hspace{1em}}
%% \newcommand{\bif}{\mbf{if}\,}
%% \newcommand{\bthen}{\mbf{then}\,}
%% \newcommand{\belse}{\mbf{else}\,}
%% \newcommand{\return}{\mbf{return}\,}
%% \newcommand{\pure}{\mbf{pure}\,}
%% \newcommand{\lam}{\lambda\,}
%% \newcommand{\data}{\mbf{data}\,}
%% \newcommand{\where}{\mbf{where}}
%% \newcommand{\M}{\msf{M}}
%% \newcommand{\letrec}{\mbf{letrec}\,}

%% \newcommand{\of}{\mbf{of}\,}
%% \newcommand{\go}{\mit{go}}
%% \newcommand{\add}{\mit{add}}
%% \newcommand{\letdef}{\mbf{let\,}}
%% \newcommand{\map}{\mit{map}}
%% \newcommand{\emptycon}{\scaleobj{.75}\bullet}
%% \newcommand{\Tyo}{\msf{Ty}_{\mbbo}}
%% \newcommand{\Tmo}{\msf{Tm}_{\mbbo}}
%% \newcommand{\Cono}{\msf{Con}_{\mbbo}}
%% \newcommand{\Subo}{\msf{Sub}_{\mbbo}}
%% \newcommand{\whset}{\wh{\Set}}
%% \newcommand{\ev}{\mbb{E}}
%% \newcommand{\re}{\mbb{R}}
%% \newcommand{\welim}{\vW{-}\msf{elim}}

%% \newcommand{\mbbc}{\mbb{C}}
%% \newcommand{\mbbo}{\mbb{O}}

%% \newcommand{\vas}{\mathsf{as}}
%% \newcommand{\vbs}{\mathsf{bs}}
%% \newcommand{\vcs}{\mathsf{cs}}
%% \newcommand{\vxs}{\mathsf{xs}}
%% \newcommand{\vys}{\mathsf{ys}}
%% \newcommand{\vsp}{\mathsf{sp}}
%% \newcommand{\vma}{\mathsf{ma}}
%% \newcommand{\vga}{\mathsf{ga}}
%% \newcommand{\vm}{\mathsf{m}}
%% \newcommand{\vn}{\mathsf{n}}
%% \newcommand{\vk}{\mathsf{k}}
%% \newcommand{\vA}{\mathsf{A}}
%% \newcommand{\vB}{\mathsf{B}}
%% \newcommand{\vC}{\mathsf{C}}
%% \newcommand{\vS}{\mathsf{S}}
%% \newcommand{\vF}{\mathsf{F}}
%% \newcommand{\vR}{\mathsf{R}}
%% \newcommand{\vM}{\mathsf{M}}
%% \newcommand{\vmb}{\mathsf{mb}}
%% \newcommand{\mAs}{\mathsf{As}}
%% \newcommand{\va}{\mathsf{a}}
%% \newcommand{\vb}{\mathsf{b}}
%% \newcommand{\vc}{\mathsf{c}}
%% \newcommand{\vd}{\mathsf{d}}
%% \newcommand{\vx}{\mathsf{x}}
%% \newcommand{\vy}{\mathsf{y}}
%% \newcommand{\vz}{\mathsf{z}}
%% \newcommand{\vf}{\mathsf{f}}
%% \newcommand{\vfs}{\mathsf{fs}}
%% \newcommand{\vg}{\mathsf{g}}
%% \newcommand{\vh}{\mathsf{h}}
%% \newcommand{\vt}{\mathsf{t}}
%% \newcommand{\vs}{\mathsf{s}}
%% \newcommand{\vr}{\mathsf{r}}
%% \newcommand{\vu}{\mathsf{u}}
%% \newcommand{\vl}{\mathsf{l}}
%% \newcommand{\vns}{\mathsf{ns}}
%% \newcommand{\vW}{\mathsf{W}}
%% \newcommand{\vsup}{\mathsf{sup}}
%% \newcommand{\vid}{\mathsf{id}}
%% \newcommand{\whW}{\wh{\vW}}


%% \newcommand{\SOP}{\msf{SOP}}
%% \newcommand{\El}{\msf{El}}
%% \newcommand{\USOP}{\msf{U}_{\msf{SOP}}}
%% \newcommand{\Uprod}{\msf{U_P}}
%% \newcommand{\Elprod}{\msf{El_{P}}}
%% \newcommand{\IsSOP}{\msf{IsSOP}}
%% \newcommand{\forEach}{\msf{forEach}}
%% \newcommand{\single}{\msf{single}}
%% \newcommand{\msplit}{\msf{split}}
%% \newcommand{\mapGen}{\msf{mapGen}}
%% \newcommand{\genPull}{\msf{gen_{Pull}}}
%% \newcommand{\Set}{\msf{Set}}
%% \newcommand{\casePull}{\msf{case_{Pull}}}
%% \newcommand{\appull}{\ap_{\Pull}}

%% \newcommand{\Con}{\msf{Con}}
%% \newcommand{\Sub}{\msf{Sub}}
%% \newcommand{\Tm}{\msf{Tm}}

%% \newcommand{\ext}{\triangleright}

%% \newcommand{\Int}{\msf{Int}}
%% \newcommand{\List}{\msf{List}}
%% \newcommand{\Tree}{\msf{Tree}}
%% \newcommand{\Node}{\msf{Node}}
%% \newcommand{\Leaf}{\msf{Leaf}}
%% \newcommand{\Nil}{\msf{Nil}}
%% \newcommand{\Cons}{\msf{Cons}}
%% \newcommand{\Reader}{\msf{Reader}}
%% \newcommand{\ReaderT}{\msf{ReaderT}}
%% \newcommand{\Monad}{\msf{Monad}}
%% \newcommand{\Applicative}{\msf{Applicative}}
%% \newcommand{\class}{\msf{class}}
%% \newcommand{\Functor}{\msf{Functor}}
%% \newcommand{\Bool}{\msf{Bool}}
%% \newcommand{\Statel}{\msf{State}}
%% \newcommand{\fro}{\leftarrow}
%% \newcommand{\case}{\mbf{case\,}}
%% \newcommand{\foldr}{\msf{foldr}}
%% \newcommand{\foldl}{\msf{foldl}}
%% \newcommand{\rep}{\msf{rep}}
%% \newcommand{\concatMap}{\msf{concatMap}}

%% \newcommand{\Lift}{{\Uparrow}}
%% \newcommand{\Up}{{\Uparrow}}
%% \newcommand{\spl}{{\bs{\sim}}}
%% \newcommand{\ql}{{\bs{\langle}}}
%% \newcommand{\qr}{{\bs{\rangle}}}
%% \newcommand{\bind}{\mathbin{>\!\!>\mkern-6.7mu=}}

%% \newcommand{\MTy}{\msf{MetaTy}}
%% \newcommand{\MTm}{\msf{MetaTm}}
%% \newcommand{\VTy}{\msf{ValTy}}
%% \newcommand{\Ty}{\msf{Ty}}
%% \newcommand{\CTy}{\msf{CompTy}}
%% \newcommand{\True}{\msf{True}}
%% \newcommand{\False}{\msf{False}}
%% \newcommand{\fst}{\msf{fst}}
%% \newcommand{\snd}{\msf{snd}}



%% \newcommand{\Nat}{\msf{Nat}}
%% \newcommand{\Zero}{\msf{Zero}}
%% \newcommand{\Suc}{\msf{Suc}}
%% \newcommand{\Maybe}{\msf{Maybe}}
%% \newcommand{\MaybeT}{\msf{MaybeT}}
%% \newcommand{\Nothing}{\msf{Nothing}}
%% \newcommand{\Just}{\msf{Just}}

%% \theoremstyle{remark}
%% \newtheorem{notation}{Notation}
%% \newtheorem*{axiom}{Axiom}

%% \newcommand{\id}{\mit{id}}
%% \newcommand{\mup}{\mbf{up}}
%% \newcommand{\mdown}{\mbf{down}}
%% \newcommand{\tyclass}{\mbf{class}}
%% \newcommand{\instance}{\mbf{instance}\,}
%% \newcommand{\Improve}{\msf{Improve}}
%% \newcommand{\Gen}{\msf{Gen}}
%% \newcommand{\unGen}{\mit{unGen}}
%% \renewcommand{\Vec}{\msf{Vec}}
%% \newcommand{\gen}{\mit{gen}}
%% \newcommand{\genRec}{\mit{genRec}}
%% \newcommand{\fmap}{<\!\!\$\!\!>}
%% \newcommand{\ap}{{<\!\!*\!\!>}}
%% \newcommand{\runGen}{\mit{runGen}}
%% \newcommand{\qt}[1]{\ql#1\qr}
%% \newcommand{\lift}{\mit{lift}}
%% \newcommand{\liftGen}{\mit{liftGen}}
%% \newcommand{\MonadGen}{\msf{MonadGen}}
%% \newcommand{\MonadState}{\msf{MonadState}}
%% \newcommand{\MonadReader}{\msf{MonadReader}}
%% \newcommand{\RA}{\Rightarrow}
%% \newcommand{\EitherT}{\msf{EitherT}}
%% \newcommand{\Either}{\msf{Either}}
%% \newcommand{\Left}{\msf{Left}}
%% \newcommand{\Right}{\msf{Right}}
%% \newcommand{\StateT}{\msf{StateT}}
%% \newcommand{\Identity}{\msf{Identity}}

%% \newcommand{\Stop}{\msf{Stop}}
%% \newcommand{\Skip}{\msf{Skip}}
%% \newcommand{\Yield}{\msf{Yield}}

%% \newcommand{\runIdentity}{\mit{runIdentity}}
%% \newcommand{\runReaderT}{\mit{runReaderT}}
%% \newcommand{\newtype}{\mbf{newtype}\,}
%% \newcommand{\runMaybeT}{\mit{runMaybeT}}
%% \newcommand{\runStateT}{\mit{runStateT}}
%% \newcommand{\runState}{\mit{runState}}
%% \newcommand{\dlr}{\,\$\,}

%% \newcommand{\ImproveF}{\msf{ImproveF}}
%% \newcommand{\ExceptT}{\msf{ExceptT}}
%% \newcommand{\State}{\msf{State}}
%% \newcommand{\SumVS}{\msf{SumVS}}
%% \newcommand{\ProdCS}{\msf{ProdCS}}
%% \newcommand{\Here}{\msf{Here}}
%% \newcommand{\There}{\msf{There}}
%% \newcommand{\IsSumVS}{\msf{IsSumVS}}
%% \newcommand{\MonadJoin}{\msf{MonadJoin}}
%% \newcommand{\Stream}{\msf{Stream}}
%% \newcommand{\join}{\mit{join}}
%% \newcommand{\modify}{\mit{modify}}
%% \newcommand{\get}{\mit{get}}
%% \newcommand{\mput}{\mit{put}}
%% \newcommand{\Rep}{\mit{Rep}}
%% \newcommand{\encode}{\mit{encode}}
%% \newcommand{\decode}{\mit{decode}}
%% \newcommand{\mindex}{\mit{index}}
%% \newcommand{\mtabulate}{\mit{tabulate}}
%% \newcommand{\States}{\mit{States}}
%% \newcommand{\seed}{\mit{seed}}
%% \newcommand{\step}{\mit{step}}
%% \newcommand{\Step}{\msf{Step}}
%% \newcommand{\Pull}{\msf{Pull}}
%% \newcommand{\MkPull}{\msf{MkPull}}

%% --------------------------------------------------------------------------------

%%
%% end of the preamble, start of the body of the document source.
%% \hypersetup{draft}
\begin{document}


\title{Canonicity for Indexed Inductive-Recursive Types}

\author{András Kovács}
\orcid{0000-0002-6375-9781}
\affiliation{%
  \institution{University of Gothenburg \& Chalmers University of Technology}
  \city{Gothenburg}
  \country{Sweden}
}
\email{andrask@chalmers.se}


\begin{abstract}
We prove canonicity for a Martin-Löf type theory that supports a countable universe hierarchy where
each universe supports indexed inductive-recursive (IIR) types. We proceed in two steps. First, we
construct IIR types from inductive-recursive (IR) types and intensional identity types, in order to
simplify the subsequent canonicity proof. The constructed IIR types support the same definitional
computation rules that are available in Agda's native IIR implementation. Second, we give a
canonicity proof for IR types, building on the well-known method of Artin gluing. The main idea is
to encode the canonicity predicate for each IR type using a metatheoretic IIR type.
\end{abstract}

%% \begin{CCSXML}
%% \end{CCSXML}
%% \ccsdesc[500]{Theory of computation~Type theory}
%% \ccsdesc[500]{Software and its engineering~Source code generation}
%% \keywords{}

\maketitle

\section{Introduction}\label{sec:introduction}

Induction-recursion (IR) was first used by Martin-Löf in an informal way \cite{TODO}, then made
formal by Dybjer and Setzer \cite{TODO}, who also developed set-theoretic and categorical semantics
\cite{TODO}. A common application of IR is to define custom universe hierarchies inside a type
theory. In the proof assistant Agda, we can use IR to define a universe that is closed under our
choice of type formers:
\begin{alignat*}{3}
  & \mbf{mutual} \\
  & \quad\data\,\Code : \Set_0\,\where \\
  & \quad\quad \Nat' : \U\\
  & \quad\quad \Pi' \hspace{0.8em} : (A : \Code) \to (\El\,A \to \Code) \to \Code
  & \\
  & \\
  & \quad\El : \Code \to \Set_0 \\
  & \quad\El\,\Nat'\hspace{1.5em}  = \Nat \\
  & \quad\El\,(\Pi'\,A\,B) = (a : \El\,A) \to \El\,(B\,a)
\end{alignat*}
Here, $\Code$ is a type of codes of types which behaves as a custom Tarski-style universe. This
universe, unlike the ambient $\Set_0$ universe, supports an induction principle and can be used to
define type-generic functions. \emph{Indexed induction-recursion} (IIR) additionally allows indexing
$\Code$ over some type, which lets us define inductive-recursive predicates \cite{TODO}.

One application of IR has been to develop semantics for object theories that support universe
hierarchies. IR has been used in normalization proofs \cite{TODO}, in modeling first-class universe
levels \cite{TODO} and proving canonicity for them \cite{TODO}, and in characterizing domains of
partial functions \cite{TODO}. Another application is to do generic programming over universes of
type descriptions \cite{TODO} or data layout descriptions \cite{TODO}.

IIR has been supported in Agda 2 since the early days of the system \cite{TODO}, and it is also
available in Idris 1 and Idris 2 \cite{TODO}. In these systems, IR has been implemented in the
``obvious'' way, supporting closed program execution in compiler backends and normalization during
type checking, but without any formal justification.

Our \textbf{main contribution} is to \textbf{show canonicity} for a Martin-Löf type theory that
supports a countable universe hierarchy, where each universe supports indexed inductive-recursive
types. Canonicity means that every closed term is definitionally equal to a canonical
term. Canonical terms are built only from constructors; for instance, a canonical natural number
term is a numeral. Hence, canonicity justifies evaluation for closed terms. The outline of our
development is as follows.

\begin{enumerate}
\item In Section \ref{TODO} we specify what it means to support IR and IIR, using Dybjer and
  Setzer's rules with minor modifications \cite{TODO}. We use first-class signatures,
  meaning that descriptions of (I)IR types are given as ordinary inductive types internally.
\item In Section \ref{TODO} we construct IIR types from IR types and other basic type formers. This
  allows us to only consider IR types in the subsequent canonicity proof, which is a significant
  simplification. In the construction of IIR types, we lose some definitional equalities when IIR
  signatures are neutral, but we still get strict computation for canonical signatures. This matches
  the computational behavior of Agda and Idris, where IIR signatures are second-class and
  necessarily canonical. We formalize the construction in Agda.
\item In Section \ref{TODO}, we give a proof-relevant logical predicate interpretation of the type
  theory, from which canonicity follows. We build on the well-known method of Artin gluing
  \cite{TODO}. The main challenge here is to give a logical predicate interpretation of IR types. We
  do this by using IIR in the metatheory: from each object-theoretic signature we compute a
  metatheoretic IIR signature which encodes the canonicity predicate for the corresponding IR type.
  We formalize the predicate interpretation of IR types in Agda, using a shallow embedding of the
  syntax of the object theory. Hence, there is a gap between the Agda version and the fully formal
  construction, but we argue that it is a modest gap.

\end{enumerate}

\section{Specification for (I)IR types}\label{sec:specification}

In this section we describe the object type theory, focusing on the specification of IR and IIR
types. We do not yet go into the formal details; instead, we shall mostly work with internal
definitions in an Agda-like syntax. In Section \ref{TODO} we will give a rigorous specification that
is based on categories-with-families.

\paragraph{Basic type formers} We have a countable hierarchy of Russell-style universes, written as $\U_i$, where $i$ is an
external natural number. We have $\U_i : \U_{i + 1}$. We have $\Pi$-types as $(x : A) \to B\,x$,
which has type $\U_{\max(i,\,j)}$ when $A : \U_i$ and $B : A \to \U_j$. We also have a lifting
operation $\Lift\,i\,j : \U_i \to \U_j$ together with $\lup : A \to \Lift\,i\,j\,A$ and $\ldown :
\Lift\,i\,j\,A \to A$ such that $\lup$ and $\ldown$ are definitional inverses. We have intensional
identity types, as $t = u : \U_i$ for $t : A : \U_i$.  We have $\top : \U_0$ for the unit type with
the unique inhabitant $\ttt$. We have $\Sigma$-types, written as $(x : A) \times B\,x$, where the type
also lands in $\U_{\max(i,\,j)}$. Finally, we have binary sum types, written as $A + B$ with constructors
$\inj_1$ and $\inj_2$.

\subsection{IR types}
The object theory additionally supports inductive-recursive types. On a high level, the specification consists
of the following.
\begin{enumerate}
\item A type of signatures. Each signature describes an IR type. Also, we internally define some
  functions on signatures which are required in the specification of other rules.
\item Rules for type formation, term formation and the recursive function, with a computation rule
  for the recursive function.
\item The induction principle with a $\beta$ rule.
\end{enumerate}

\subsubsection{IR signatures}\label{sec:ir-signatures}
Signatures are parameterized by the following data:
\begin{itemize}
\item The level $i$ is the size of the IR type that is being specified.
\item The level $j$ is the size of the recursive output type.
\item $O : \U_j$ is the output type.
\end{itemize}
IR signatures are specified by the following inductive type. We only mark $i$ and $O$ as parameters to $\Sig$,
since $j$ is inferable from $O$.
\begin{alignat*}{4}
  &\data\, \Sig_i\,O : \U_{\max(i+1,\,j)}\\
  &\quad \iota\hspace{0.25em}  : O \to \Sig_i\,O \\
  &\quad \sigma               : (A : \U_i) \to (A \to \Sig_i\,O) \to \Sig_i\,O \\
  &\quad \delta\hspace{0.1em} : (A : \U_i) \to ((A \to O) \to \Sig_i\,O) \to \Sig_i\,O
\end{alignat*}
Formally, we can view $\Sig$ in two ways. We can either view it as just a particular family of $\msf{W}$-types,
or as an inductive type that is primitively part of the object theory. The choice is not important, since inductive
families are constructible from $\msf{W}$-types \cite{whynotw}.

\begin{example}
We can reproduce the Agda example from Figure \cite{TODO}. First, we need an enumeration type to
represent the constructor labels of $\Code$. We assume this as $\Tag : \U_0$ with constructors
$\Nat'$ and $\Pi'$, and we use an informal case splitting operation for it. We also assume $\Nat :
\U_0$ for natural numbers and a right-associative $\blank\!\$\!\blank$ operator for function application.
\begin{alignat*}{4}
  & S : \Sig_0\,\U_0\\
  & S := \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nat' \to \iota\,\Nat \\
  & \quad \Pi'\hspace{0.85em} \to \delta\,\top\,\$\,\lambda\,{ElA}.\, \delta\,({ElA}\,\ttt)\,\$\,\lambda\,{ElB}.\,
      \iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)
\end{alignat*}
First, we introduce a choice between two constructors by $\sigma\,\Tag$. In the $\Nat'$ branch, we
specify that the recursive function maps the constructor to $\Nat$. In the $\Pi'$ branch, we first
introduce a single inductive constructor field by $\delta\,\top$, where $\top$ represents the number
of introduced fields. The naming of the freshly bound variable ${ElA}$ is meant to suggest that it
represent the recursive function's output for the inductive field. It has type $\top \to \U_0$.
Next, we introduce $({ElA}\,\ttt)$-many inductive fields, and bind ${ElB} : {ElA}\,\ttt \to \U_0$ to
represent the corresponding recursive output. Finally, $\iota\, ((x : {ElA}\,\ttt) \to {ElB}\,x)$
specifies the output of the recursive function for a $\Pi'$ constructor.
\end{example}

Our signatures are identical to Dybjer and Setzer's \cite{TODO}, except for one difference.  We have
countable universe levels, while Dybjer and Setzer use a logical framework presentation with only
three universes, $\msf{set}$, $\msf{stype}$ and $\msf{type}$, where $\msf{set}$ contains the
inductively specified type, $\msf{stype}$ contains the non-inductive constructor arguments and
$\msf{type}$ contains the recursive output type and the type of signatures.

\subsubsection{Type and term formation}\label{sec:signature-semantics}

In this section we also follow Dybjer and Setzer \cite{TODO}, with minor differences of notation, and
also accounting for the refinement of universe levels.

First, assuming $i$ and $O : \U_j$, a signature $S : \Sig_i\,O$ can be interpreted as a function
from $(A : \U_i) \times (A \to O)$ to $(A : \U_i) \times (A \to O)$. This can be extended to an
endofunctor on the slice category $\U_i/O$, but in the following we only need the action on
objects. We split this action to two functions, to aid readability:
\begin{alignat*}{3}
  &\rlap{$\blank_0 : \Sig_i\,O \to (\ir : \U_i) \to (\ir \to O) \to \U_i$} \\
  &S_0\,(\iota\,o)    \,&&\ir\,\el && \hspace{-0.7em}= \Lift\,\top\\
  &S_0\,(\sigma\,A\,S)\,&&\ir\,\el && \hspace{-0.7em}= (a : A) \times (S\,a)_0\,\ir\,\el\\
  &S_0\,(\delta\,A\,S)\,&&\ir\,\el && \hspace{-0.7em}= (f : A \to \ir) \times (S\,(\el \circ f))_0\,\ir\,\el\\
  & && &&\\
  &\rlap{$\blank_1 : (S : \Sig_i\,O) \to S_0\,\ir\,\el \to O$} \\
  &S_1\,(\iota\,o)    \,&&x       && = o\\
  &S_1\,(\sigma\,A\,S)\,&&(a,\,x) && = (S\,i)_1\,x\\
  &S_1\,(\delta\,A\,S)\,&&(f,\,x) && = (S\,(\el \circ f))_1\,x
\end{alignat*}
Although we use Agda-like pattern matching notation above, these functions are formally defined by
the elimination principle of $\Sig$. Also note the quantification of the $i$ and $j$ universe
levels. The object theory does not support universe polymorphism, so this quantification is
understood to happen in the metatheory. The introduction rules are the following.
\begin{alignat*}{3}
  &\IR                && : (S : \Sig_i\,O) \to \U_i\\
  &\El                && : \IR\,S \to O\\
  &\intro             && : S_0\,(\IR\,S)\,\El \to \IR\,S\\
  &\msf{El\!\!-\!\!intro} && : \El\,(\intro\,x) \equiv S_1\,x
\end{alignat*}
Above, we leave some rule arguments implicit, like $S$ in $\El$, $\intro$ and
$\msf{El\!\!-\!\!intro}$. The rule $\msf{El\!\!-\!\!intro}$ specifies a definitional equality.  Note
that these rules are not internal definitions but part of the specification of the object
theory. Hence, they are also assumed to be stable under object-theoretic substitution, formally
speaking (we omit the substitution rules here). On a high level, the introduction rules express the
existence of an $S$-algebra where we view $S$ as an endofunctor on $\U_i/O$.

\subsubsection{Elimination}\label{sec:ir-elimination}

Here we follow the specification in \cite{TODO}. We assume another universe level $k$ that specifies
the size of the type into which we eliminate. We define two additional functions on signatures:
\begin{alignat*}{3}
  &\rlap{$\blank_\IH : (S : \Sig_i\,O)(P : \ir \to \U_k) \to S_0\,\ir\,\el \to \U_{\max(i,\,k)}$} \\
  &(\iota\,o)_\IH    \,&&P\,x       &&= \Lift\,\top \\
  &(\sigma\,A\,S)_\IH\,&&P\,(a,\,x) &&= (S\,a)_\IH\,P\,x \\
  &(\delta\,A\,S)_\IH\,&&P\,(f,\,x) &&= ((a : A) \to P\,(f\,a)) \times (S\,(\el \circ f))_\IH\,P\,x
\end{alignat*}
\begin{alignat*}{3}
  &\hspace{-8em}\rlap{$\blank_\map : (S : \Sig_i\,O)(P : \ir \to \U_k) \to ((x : \ir) \to P\,x) \to (x : S_0\,\ir\,\el) \to S_\IH\,\ir\,\el\,P\,x$} \\
  &\hspace{-8em}(\iota\,o)_\map    \,&&P\,h\,x       &&=\,\lup\!\ttt \\
  &\hspace{-8em}(\sigma\,A\,S)_\map\,&&P\,h\,(a,\,x) &&= (S\,a)_\map\,P\,h\,x \\
  &\hspace{-8em}(\delta\,A\,S)_\map\,&&P\,h\,(f,\,x) &&= (\el \circ h,\,(S\,(\el \circ f))_\map\,P\,h\,x)
\end{alignat*}
$S_\IH$ stands for ``induction hypothesis'': it specifies having a witness of a predicate $P$ for
each inductive field in a value of $S_0\,\ir\,\el$. $S_\map$ maps over $S_0\,\ir\,\el$, applying the
section $h : (x : \ir) \to P\,x$ to each inductive field. Elimination is specified as follows.
\begin{alignat*}{3}
  &\elim           &&: (P : \IR\,S \to \U_k) \to ((x : S_0\,(\IR\,S)\,\El) \to S_\IH\,P\,x \to P\,(\intro\,x)) \to (x : \IR\,S) \to P\,x \\
  &\elim\!-\!\beta &&: \elim\,P\,f\,(\intro\,x) \equiv f\,x\,(S_\map\,P\,(\elim\,P\,f)\,x)
\end{alignat*}
If we have function extensionality, this specification of elimination can be shown to be equivalent
to the initiality of $\IR\,S$ and $\El$ as an $S$-algebra \cite{TODO}.

\subsection{IIR types}

Dybjer and Setzer originally considered two variants of IIR, \emph{restricted} and \emph{general}
\cite{TODO}.  A restricted IIR signature requires that every constructor has a non-inductive first
field from which the constructor index can be determined. General IIR allows constructor indices to
depend on any non-inductive field. We use general IIR with a mild modification borrowed from Hancock
et al.'s small IIR \cite{TODO}. Since IIR is quite similar to IR, we give a more terse presentation
of the rules and definitions in the following.

\subsubsection{Signatures} We assume levels $i$, $j$, $k$, an indexing type $I : \U_k$ and a type family
for the recursive output as $O : I \to \U_j$. Signatures are as follows.
\begin{alignat*}{4}
  &\data\, \Sig_i\,I\,O : \U_{\max(i+1,\,j,\,k)}\\
  &\quad \iota\hspace{0.25em}  : (i : I) \to O\,i \to \Sig_i\,I\,O \\
  &\quad \sigma                : (A : \U_i) \to (A \to \Sig_i\,I\,O) \to \Sig_i\,I\,O \\
  &\quad \delta\hspace{0.1em}  : (A : \U_i)(\ix : A \to I) \to (((a : A) \to O\,(\ix\,a)) \to \Sig_i\,I\,O) \to \Sig_i\,I\,O
\end{alignat*}

\begin{example} We reproduce length-indexed vectors as an IIR type. We assume $A : \U_0$ for a type of elements in the vector,
and a type $\Tag : \U_0$ with inhabitants $\Nil'$ and $\Cons'$.
\begin{alignat*}{4}
  & S : \Sig_0\,\Nat\,(\lambda\,\_.\,\top)\\
  & S := \sigma\,\Tag\,\$\,\lambda\,t.\,\case\,t\,\of \\
  & \quad \Nil'\hspace{0.85em} \to \iota\,\zero\,\ttt \\
  & \quad \Cons'\to \sigma\,\Nat\,\$\,\lambda\,n.\,\sigma\,A\,\$\,\lambda\,\_.\,\delta\,\top\,(\lambda\,\_.\,n)\,\$\,\lambda\,\_.\,\iota\,(\suc\,n)\,\ttt
\end{alignat*}
We set $O$ to be constant $\top$ because vectors do not have an associated recursive function. In
the $\Nil'$ case, we simply set the constructor index to $\zero$. In the $\Cons'$ case, we introduce
a non-inductive field, binding $n$ for the length of the tail of the vector. Then, when we introduce
the inductive field using $\delta$, we use $(\lambda\,\_.\,n)$ to specify that the length of the
(single) inductive field is indeed $n$. Finally, the length of the $\Cons'$ constructor is $\suc\,n$.
\end{example}














\section{TODO}

\begin{itemize}
  \item Small IIR paper: reduction of small IIR to IR + identity, similar to mine
  \item Bove-Capretta: IIR is used to model domains of partial functions.
  \item Canonicity metatheory: Loic, Anton say it looks OK
\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
\endinput
